import "./chunk-76J2PTFD.js";

// node_modules/helios-web/dist/helios.js
var un = (t4) => +t4;
function Cr(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}
var Lt = "http://www.w3.org/1999/xhtml";
var hn = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Lt,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function At(t4) {
  var e = t4 += "", n = e.indexOf(":");
  return n >= 0 && (e = t4.slice(0, n)) !== "xmlns" && (t4 = t4.slice(n + 1)), hn.hasOwnProperty(e) ? { space: hn[e], local: t4 } : t4;
}
function Ir(t4) {
  return function() {
    var e = this.ownerDocument, n = this.namespaceURI;
    return n === Lt && e.documentElement.namespaceURI === Lt ? e.createElement(t4) : e.createElementNS(n, t4);
  };
}
function Br(t4) {
  return function() {
    return this.ownerDocument.createElementNS(t4.space, t4.local);
  };
}
function Hn(t4) {
  var e = At(t4);
  return (e.local ? Br : Ir)(e);
}
function Fr() {
}
function en(t4) {
  return t4 == null ? Fr : function() {
    return this.querySelector(t4);
  };
}
function Mr(t4) {
  typeof t4 != "function" && (t4 = en(t4));
  for (var e = this._groups, n = e.length, r = new Array(n), i = 0; i < n; ++i)
    for (var a = e[i], o = a.length, s = r[i] = new Array(o), l, h, u = 0; u < o; ++u)
      (l = a[u]) && (h = t4.call(l, l.__data__, u, a)) && ("__data__" in l && (h.__data__ = l.__data__), s[u] = h);
  return new $(r, this._parents);
}
function Rr(t4) {
  return t4 == null ? [] : Array.isArray(t4) ? t4 : Array.from(t4);
}
function Sr() {
  return [];
}
function Yn(t4) {
  return t4 == null ? Sr : function() {
    return this.querySelectorAll(t4);
  };
}
function Tr(t4) {
  return function() {
    return Rr(t4.apply(this, arguments));
  };
}
function Nr(t4) {
  typeof t4 == "function" ? t4 = Tr(t4) : t4 = Yn(t4);
  for (var e = this._groups, n = e.length, r = [], i = [], a = 0; a < n; ++a)
    for (var o = e[a], s = o.length, l, h = 0; h < s; ++h)
      (l = o[h]) && (r.push(t4.call(l, l.__data__, h, o)), i.push(l));
  return new $(r, i);
}
function qn(t4) {
  return function() {
    return this.matches(t4);
  };
}
function Xn(t4) {
  return function(e) {
    return e.matches(t4);
  };
}
var Pr = Array.prototype.find;
function Or(t4) {
  return function() {
    return Pr.call(this.children, t4);
  };
}
function zr() {
  return this.firstElementChild;
}
function Dr(t4) {
  return this.select(t4 == null ? zr : Or(typeof t4 == "function" ? t4 : Xn(t4)));
}
var Lr = Array.prototype.filter;
function Ur() {
  return Array.from(this.children);
}
function Qr(t4) {
  return function() {
    return Lr.call(this.children, t4);
  };
}
function Gr(t4) {
  return this.selectAll(t4 == null ? Ur : Qr(typeof t4 == "function" ? t4 : Xn(t4)));
}
function Vr(t4) {
  typeof t4 != "function" && (t4 = qn(t4));
  for (var e = this._groups, n = e.length, r = new Array(n), i = 0; i < n; ++i)
    for (var a = e[i], o = a.length, s = r[i] = [], l, h = 0; h < o; ++h)
      (l = a[h]) && t4.call(l, l.__data__, h, a) && s.push(l);
  return new $(r, this._parents);
}
function jn(t4) {
  return new Array(t4.length);
}
function Wr() {
  return new $(this._enter || this._groups.map(jn), this._parents);
}
function ot(t4, e) {
  this.ownerDocument = t4.ownerDocument, this.namespaceURI = t4.namespaceURI, this._next = null, this._parent = t4, this.__data__ = e;
}
ot.prototype = {
  constructor: ot,
  appendChild: function(t4) {
    return this._parent.insertBefore(t4, this._next);
  },
  insertBefore: function(t4, e) {
    return this._parent.insertBefore(t4, e);
  },
  querySelector: function(t4) {
    return this._parent.querySelector(t4);
  },
  querySelectorAll: function(t4) {
    return this._parent.querySelectorAll(t4);
  }
};
function Hr(t4) {
  return function() {
    return t4;
  };
}
function Yr(t4, e, n, r, i, a) {
  for (var o = 0, s, l = e.length, h = a.length; o < h; ++o)
    (s = e[o]) ? (s.__data__ = a[o], r[o] = s) : n[o] = new ot(t4, a[o]);
  for (; o < l; ++o)
    (s = e[o]) && (i[o] = s);
}
function qr(t4, e, n, r, i, a, o) {
  var s, l, h = /* @__PURE__ */ new Map(), u = e.length, f = a.length, c = new Array(u), d;
  for (s = 0; s < u; ++s)
    (l = e[s]) && (c[s] = d = o.call(l, l.__data__, s, e) + "", h.has(d) ? i[s] = l : h.set(d, l));
  for (s = 0; s < f; ++s)
    d = o.call(t4, a[s], s, a) + "", (l = h.get(d)) ? (r[s] = l, l.__data__ = a[s], h.delete(d)) : n[s] = new ot(t4, a[s]);
  for (s = 0; s < u; ++s)
    (l = e[s]) && h.get(c[s]) === l && (i[s] = l);
}
function Xr(t4) {
  return t4.__data__;
}
function jr(t4, e) {
  if (!arguments.length)
    return Array.from(this, Xr);
  var n = e ? qr : Yr, r = this._parents, i = this._groups;
  typeof t4 != "function" && (t4 = Hr(t4));
  for (var a = i.length, o = new Array(a), s = new Array(a), l = new Array(a), h = 0; h < a; ++h) {
    var u = r[h], f = i[h], c = f.length, d = $r(t4.call(u, u && u.__data__, h, r)), v = d.length, g = s[h] = new Array(v), p = o[h] = new Array(v), x = l[h] = new Array(c);
    n(u, f, g, p, x, d, e);
    for (var w = 0, b = 0, m, _; w < v; ++w)
      if (m = g[w]) {
        for (w >= b && (b = w + 1); !(_ = p[b]) && ++b < v; )
          ;
        m._next = _ || null;
      }
  }
  return o = new $(o, r), o._enter = s, o._exit = l, o;
}
function $r(t4) {
  return typeof t4 == "object" && "length" in t4 ? t4 : Array.from(t4);
}
function Zr() {
  return new $(this._exit || this._groups.map(jn), this._parents);
}
function Kr(t4, e, n) {
  var r = this.enter(), i = this, a = this.exit();
  return typeof t4 == "function" ? (r = t4(r), r && (r = r.selection())) : r = r.append(t4 + ""), e != null && (i = e(i), i && (i = i.selection())), n == null ? a.remove() : n(a), r && i ? r.merge(i).order() : i;
}
function Jr(t4) {
  for (var e = t4.selection ? t4.selection() : t4, n = this._groups, r = e._groups, i = n.length, a = r.length, o = Math.min(i, a), s = new Array(i), l = 0; l < o; ++l)
    for (var h = n[l], u = r[l], f = h.length, c = s[l] = new Array(f), d, v = 0; v < f; ++v)
      (d = h[v] || u[v]) && (c[v] = d);
  for (; l < i; ++l)
    s[l] = n[l];
  return new $(s, this._parents);
}
function ei() {
  for (var t4 = this._groups, e = -1, n = t4.length; ++e < n; )
    for (var r = t4[e], i = r.length - 1, a = r[i], o; --i >= 0; )
      (o = r[i]) && (a && o.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(o, a), a = o);
  return this;
}
function ti(t4) {
  t4 || (t4 = ni);
  function e(f, c) {
    return f && c ? t4(f.__data__, c.__data__) : !f - !c;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), a = 0; a < r; ++a) {
    for (var o = n[a], s = o.length, l = i[a] = new Array(s), h, u = 0; u < s; ++u)
      (h = o[u]) && (l[u] = h);
    l.sort(e);
  }
  return new $(i, this._parents).order();
}
function ni(t4, e) {
  return t4 < e ? -1 : t4 > e ? 1 : t4 >= e ? 0 : NaN;
}
function ri() {
  var t4 = arguments[0];
  return arguments[0] = this, t4.apply(null, arguments), this;
}
function ii() {
  return Array.from(this);
}
function ai() {
  for (var t4 = this._groups, e = 0, n = t4.length; e < n; ++e)
    for (var r = t4[e], i = 0, a = r.length; i < a; ++i) {
      var o = r[i];
      if (o)
        return o;
    }
  return null;
}
function si() {
  let t4 = 0;
  for (const e of this)
    ++t4;
  return t4;
}
function oi() {
  return !this.node();
}
function li(t4) {
  for (var e = this._groups, n = 0, r = e.length; n < r; ++n)
    for (var i = e[n], a = 0, o = i.length, s; a < o; ++a)
      (s = i[a]) && t4.call(s, s.__data__, a, i);
  return this;
}
function ui(t4) {
  return function() {
    this.removeAttribute(t4);
  };
}
function hi(t4) {
  return function() {
    this.removeAttributeNS(t4.space, t4.local);
  };
}
function fi(t4, e) {
  return function() {
    this.setAttribute(t4, e);
  };
}
function ci(t4, e) {
  return function() {
    this.setAttributeNS(t4.space, t4.local, e);
  };
}
function di(t4, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttribute(t4) : this.setAttribute(t4, n);
  };
}
function gi(t4, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttributeNS(t4.space, t4.local) : this.setAttributeNS(t4.space, t4.local, n);
  };
}
function vi(t4, e) {
  var n = At(t4);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((e == null ? n.local ? hi : ui : typeof e == "function" ? n.local ? gi : di : n.local ? ci : fi)(n, e));
}
function $n(t4) {
  return t4.ownerDocument && t4.ownerDocument.defaultView || t4.document && t4 || t4.defaultView;
}
function mi(t4) {
  return function() {
    this.style.removeProperty(t4);
  };
}
function pi(t4, e, n) {
  return function() {
    this.style.setProperty(t4, e, n);
  };
}
function Ai(t4, e, n) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.style.removeProperty(t4) : this.style.setProperty(t4, r, n);
  };
}
function _i(t4, e, n) {
  return arguments.length > 1 ? this.each((e == null ? mi : typeof e == "function" ? Ai : pi)(t4, e, n ?? "")) : Ce(this.node(), t4);
}
function Ce(t4, e) {
  return t4.style.getPropertyValue(e) || $n(t4).getComputedStyle(t4, null).getPropertyValue(e);
}
function yi(t4) {
  return function() {
    delete this[t4];
  };
}
function xi(t4, e) {
  return function() {
    this[t4] = e;
  };
}
function bi(t4, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? delete this[t4] : this[t4] = n;
  };
}
function wi(t4, e) {
  return arguments.length > 1 ? this.each((e == null ? yi : typeof e == "function" ? bi : xi)(t4, e)) : this.node()[t4];
}
function Zn(t4) {
  return t4.trim().split(/^|\s+/);
}
function tn(t4) {
  return t4.classList || new Kn(t4);
}
function Kn(t4) {
  this._node = t4, this._names = Zn(t4.getAttribute("class") || "");
}
Kn.prototype = {
  add: function(t4) {
    var e = this._names.indexOf(t4);
    e < 0 && (this._names.push(t4), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t4) {
    var e = this._names.indexOf(t4);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t4) {
    return this._names.indexOf(t4) >= 0;
  }
};
function Jn(t4, e) {
  for (var n = tn(t4), r = -1, i = e.length; ++r < i; )
    n.add(e[r]);
}
function er(t4, e) {
  for (var n = tn(t4), r = -1, i = e.length; ++r < i; )
    n.remove(e[r]);
}
function Ei(t4) {
  return function() {
    Jn(this, t4);
  };
}
function ki(t4) {
  return function() {
    er(this, t4);
  };
}
function Ci(t4, e) {
  return function() {
    (e.apply(this, arguments) ? Jn : er)(this, t4);
  };
}
function Ii(t4, e) {
  var n = Zn(t4 + "");
  if (arguments.length < 2) {
    for (var r = tn(this.node()), i = -1, a = n.length; ++i < a; )
      if (!r.contains(n[i]))
        return false;
    return true;
  }
  return this.each((typeof e == "function" ? Ci : e ? Ei : ki)(n, e));
}
function Bi() {
  this.textContent = "";
}
function Fi(t4) {
  return function() {
    this.textContent = t4;
  };
}
function Mi(t4) {
  return function() {
    var e = t4.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function Ri(t4) {
  return arguments.length ? this.each(t4 == null ? Bi : (typeof t4 == "function" ? Mi : Fi)(t4)) : this.node().textContent;
}
function Si() {
  this.innerHTML = "";
}
function Ti(t4) {
  return function() {
    this.innerHTML = t4;
  };
}
function Ni(t4) {
  return function() {
    var e = t4.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function Pi(t4) {
  return arguments.length ? this.each(t4 == null ? Si : (typeof t4 == "function" ? Ni : Ti)(t4)) : this.node().innerHTML;
}
function Oi() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function zi() {
  return this.each(Oi);
}
function Di() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Li() {
  return this.each(Di);
}
function Ui(t4) {
  var e = typeof t4 == "function" ? t4 : Hn(t4);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function Qi() {
  return null;
}
function Gi(t4, e) {
  var n = typeof t4 == "function" ? t4 : Hn(t4), r = e == null ? Qi : typeof e == "function" ? e : en(e);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function Vi() {
  var t4 = this.parentNode;
  t4 && t4.removeChild(this);
}
function Wi() {
  return this.each(Vi);
}
function Hi() {
  var t4 = this.cloneNode(false), e = this.parentNode;
  return e ? e.insertBefore(t4, this.nextSibling) : t4;
}
function Yi() {
  var t4 = this.cloneNode(true), e = this.parentNode;
  return e ? e.insertBefore(t4, this.nextSibling) : t4;
}
function qi(t4) {
  return this.select(t4 ? Yi : Hi);
}
function Xi(t4) {
  return arguments.length ? this.property("__data__", t4) : this.node().__data__;
}
function ji(t4) {
  return function(e) {
    t4.call(this, e, this.__data__);
  };
}
function $i(t4) {
  return t4.trim().split(/^|\s+/).map(function(e) {
    var n = "", r = e.indexOf(".");
    return r >= 0 && (n = e.slice(r + 1), e = e.slice(0, r)), { type: e, name: n };
  });
}
function Zi(t4) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var n = 0, r = -1, i = e.length, a; n < i; ++n)
        a = e[n], (!t4.type || a.type === t4.type) && a.name === t4.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++r] = a;
      ++r ? e.length = r : delete this.__on;
    }
  };
}
function Ki(t4, e, n) {
  return function() {
    var r = this.__on, i, a = ji(e);
    if (r) {
      for (var o = 0, s = r.length; o < s; ++o)
        if ((i = r[o]).type === t4.type && i.name === t4.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = a, i.options = n), i.value = e;
          return;
        }
    }
    this.addEventListener(t4.type, a, n), i = { type: t4.type, name: t4.name, value: e, listener: a, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function Ji(t4, e, n) {
  var r = $i(t4 + ""), i, a = r.length, o;
  if (arguments.length < 2) {
    var s = this.node().__on;
    if (s) {
      for (var l = 0, h = s.length, u; l < h; ++l)
        for (i = 0, u = s[l]; i < a; ++i)
          if ((o = r[i]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (s = e ? Ki : Zi, i = 0; i < a; ++i)
    this.each(s(r[i], e, n));
  return this;
}
function tr(t4, e, n) {
  var r = $n(t4), i = r.CustomEvent;
  typeof i == "function" ? i = new i(e, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(e, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(e, false, false)), t4.dispatchEvent(i);
}
function ea(t4, e) {
  return function() {
    return tr(this, t4, e);
  };
}
function ta(t4, e) {
  return function() {
    return tr(this, t4, e.apply(this, arguments));
  };
}
function na(t4, e) {
  return this.each((typeof e == "function" ? ta : ea)(t4, e));
}
function* ra() {
  for (var t4 = this._groups, e = 0, n = t4.length; e < n; ++e)
    for (var r = t4[e], i = 0, a = r.length, o; i < a; ++i)
      (o = r[i]) && (yield o);
}
var nr = [null];
function $(t4, e) {
  this._groups = t4, this._parents = e;
}
function We() {
  return new $([[document.documentElement]], nr);
}
function ia() {
  return this;
}
$.prototype = We.prototype = {
  constructor: $,
  select: Mr,
  selectAll: Nr,
  selectChild: Dr,
  selectChildren: Gr,
  filter: Vr,
  data: jr,
  enter: Wr,
  exit: Zr,
  join: Kr,
  merge: Jr,
  selection: ia,
  order: ei,
  sort: ti,
  call: ri,
  nodes: ii,
  node: ai,
  size: si,
  empty: oi,
  each: li,
  attr: vi,
  style: _i,
  property: wi,
  classed: Ii,
  text: Ri,
  html: Pi,
  raise: zi,
  lower: Li,
  append: Ui,
  insert: Gi,
  remove: Wi,
  clone: qi,
  datum: Xi,
  on: Ji,
  dispatch: na,
  [Symbol.iterator]: ra
};
function j(t4) {
  return typeof t4 == "string" ? new $([[document.querySelector(t4)]], [document.documentElement]) : new $([[t4]], nr);
}
function aa(t4) {
  let e;
  for (; e = t4.sourceEvent; )
    t4 = e;
  return t4;
}
function Ae(t4, e) {
  if (t4 = aa(t4), e === void 0 && (e = t4.currentTarget), e) {
    var n = e.ownerSVGElement || e;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = t4.clientX, r.y = t4.clientY, r = r.matrixTransform(e.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (e.getBoundingClientRect) {
      var i = e.getBoundingClientRect();
      return [t4.clientX - i.left - e.clientLeft, t4.clientY - i.top - e.clientTop];
    }
  }
  return [t4.pageX, t4.pageY];
}
var sa = { value: () => {
} };
function nn() {
  for (var t4 = 0, e = arguments.length, n = {}, r; t4 < e; ++t4) {
    if (!(r = arguments[t4] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new tt(n);
}
function tt(t4) {
  this._ = t4;
}
function oa(t4, e) {
  return t4.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !e.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
tt.prototype = nn.prototype = {
  constructor: tt,
  on: function(t4, e) {
    var n = this._, r = oa(t4 + "", n), i, a = -1, o = r.length;
    if (arguments.length < 2) {
      for (; ++a < o; )
        if ((i = (t4 = r[a]).type) && (i = la(n[i], t4.name)))
          return i;
      return;
    }
    if (e != null && typeof e != "function")
      throw new Error("invalid callback: " + e);
    for (; ++a < o; )
      if (i = (t4 = r[a]).type)
        n[i] = fn(n[i], t4.name, e);
      else if (e == null)
        for (i in n)
          n[i] = fn(n[i], t4.name, null);
    return this;
  },
  copy: function() {
    var t4 = {}, e = this._;
    for (var n in e)
      t4[n] = e[n].slice();
    return new tt(t4);
  },
  call: function(t4, e) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, a; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    for (a = this._[t4], r = 0, i = a.length; r < i; ++r)
      a[r].value.apply(e, n);
  },
  apply: function(t4, e, n) {
    if (!this._.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    for (var r = this._[t4], i = 0, a = r.length; i < a; ++i)
      r[i].value.apply(e, n);
  }
};
function la(t4, e) {
  for (var n = 0, r = t4.length, i; n < r; ++n)
    if ((i = t4[n]).name === e)
      return i.value;
}
function fn(t4, e, n) {
  for (var r = 0, i = t4.length; r < i; ++r)
    if (t4[r].name === e) {
      t4[r] = sa, t4 = t4.slice(0, r).concat(t4.slice(r + 1));
      break;
    }
  return n != null && t4.push({ name: e, value: n }), t4;
}
var Ut = { capture: true, passive: false };
function Qt(t4) {
  t4.preventDefault(), t4.stopImmediatePropagation();
}
function ua(t4) {
  var e = t4.document.documentElement, n = j(t4).on("dragstart.drag", Qt, Ut);
  "onselectstart" in e ? n.on("selectstart.drag", Qt, Ut) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function ha(t4, e) {
  var n = t4.document.documentElement, r = j(t4).on("dragstart.drag", null);
  e && (r.on("click.drag", Qt, Ut), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
function rn(t4, e, n) {
  t4.prototype = e.prototype = n, n.constructor = t4;
}
function rr(t4, e) {
  var n = Object.create(t4.prototype);
  for (var r in e)
    n[r] = e[r];
  return n;
}
function He() {
}
var Ue = 0.7;
var lt = 1 / Ue;
var ke = "\\s*([+-]?\\d+)\\s*";
var Qe = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var ie = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var fa = /^#([0-9a-f]{3,8})$/;
var ca = new RegExp(`^rgb\\(${ke},${ke},${ke}\\)$`);
var da = new RegExp(`^rgb\\(${ie},${ie},${ie}\\)$`);
var ga = new RegExp(`^rgba\\(${ke},${ke},${ke},${Qe}\\)$`);
var va = new RegExp(`^rgba\\(${ie},${ie},${ie},${Qe}\\)$`);
var ma = new RegExp(`^hsl\\(${Qe},${ie},${ie}\\)$`);
var pa = new RegExp(`^hsla\\(${Qe},${ie},${ie},${Qe}\\)$`);
var cn = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
rn(He, Ge, {
  copy(t4) {
    return Object.assign(new this.constructor(), this, t4);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: dn,
  // Deprecated! Use color.formatHex.
  formatHex: dn,
  formatHex8: Aa,
  formatHsl: _a,
  formatRgb: gn,
  toString: gn
});
function dn() {
  return this.rgb().formatHex();
}
function Aa() {
  return this.rgb().formatHex8();
}
function _a() {
  return ir(this).formatHsl();
}
function gn() {
  return this.rgb().formatRgb();
}
function Ge(t4) {
  var e, n;
  return t4 = (t4 + "").trim().toLowerCase(), (e = fa.exec(t4)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? vn(e) : n === 3 ? new q(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? Xe(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? Xe(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = ca.exec(t4)) ? new q(e[1], e[2], e[3], 1) : (e = da.exec(t4)) ? new q(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = ga.exec(t4)) ? Xe(e[1], e[2], e[3], e[4]) : (e = va.exec(t4)) ? Xe(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = ma.exec(t4)) ? An(e[1], e[2] / 100, e[3] / 100, 1) : (e = pa.exec(t4)) ? An(e[1], e[2] / 100, e[3] / 100, e[4]) : cn.hasOwnProperty(t4) ? vn(cn[t4]) : t4 === "transparent" ? new q(NaN, NaN, NaN, 0) : null;
}
function vn(t4) {
  return new q(t4 >> 16 & 255, t4 >> 8 & 255, t4 & 255, 1);
}
function Xe(t4, e, n, r) {
  return r <= 0 && (t4 = e = n = NaN), new q(t4, e, n, r);
}
function ya(t4) {
  return t4 instanceof He || (t4 = Ge(t4)), t4 ? (t4 = t4.rgb(), new q(t4.r, t4.g, t4.b, t4.opacity)) : new q();
}
function ut(t4, e, n, r) {
  return arguments.length === 1 ? ya(t4) : new q(t4, e, n, r ?? 1);
}
function q(t4, e, n, r) {
  this.r = +t4, this.g = +e, this.b = +n, this.opacity = +r;
}
rn(q, ut, rr(He, {
  brighter(t4) {
    return t4 = t4 == null ? lt : Math.pow(lt, t4), new q(this.r * t4, this.g * t4, this.b * t4, this.opacity);
  },
  darker(t4) {
    return t4 = t4 == null ? Ue : Math.pow(Ue, t4), new q(this.r * t4, this.g * t4, this.b * t4, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new q(xe(this.r), xe(this.g), xe(this.b), ht(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: mn,
  // Deprecated! Use color.formatHex.
  formatHex: mn,
  formatHex8: xa,
  formatRgb: pn,
  toString: pn
}));
function mn() {
  return `#${ye(this.r)}${ye(this.g)}${ye(this.b)}`;
}
function xa() {
  return `#${ye(this.r)}${ye(this.g)}${ye(this.b)}${ye((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function pn() {
  const t4 = ht(this.opacity);
  return `${t4 === 1 ? "rgb(" : "rgba("}${xe(this.r)}, ${xe(this.g)}, ${xe(this.b)}${t4 === 1 ? ")" : `, ${t4})`}`;
}
function ht(t4) {
  return isNaN(t4) ? 1 : Math.max(0, Math.min(1, t4));
}
function xe(t4) {
  return Math.max(0, Math.min(255, Math.round(t4) || 0));
}
function ye(t4) {
  return t4 = xe(t4), (t4 < 16 ? "0" : "") + t4.toString(16);
}
function An(t4, e, n, r) {
  return r <= 0 ? t4 = e = n = NaN : n <= 0 || n >= 1 ? t4 = e = NaN : e <= 0 && (t4 = NaN), new te(t4, e, n, r);
}
function ir(t4) {
  if (t4 instanceof te)
    return new te(t4.h, t4.s, t4.l, t4.opacity);
  if (t4 instanceof He || (t4 = Ge(t4)), !t4)
    return new te();
  if (t4 instanceof te)
    return t4;
  t4 = t4.rgb();
  var e = t4.r / 255, n = t4.g / 255, r = t4.b / 255, i = Math.min(e, n, r), a = Math.max(e, n, r), o = NaN, s = a - i, l = (a + i) / 2;
  return s ? (e === a ? o = (n - r) / s + (n < r) * 6 : n === a ? o = (r - e) / s + 2 : o = (e - n) / s + 4, s /= l < 0.5 ? a + i : 2 - a - i, o *= 60) : s = l > 0 && l < 1 ? 0 : o, new te(o, s, l, t4.opacity);
}
function ba(t4, e, n, r) {
  return arguments.length === 1 ? ir(t4) : new te(t4, e, n, r ?? 1);
}
function te(t4, e, n, r) {
  this.h = +t4, this.s = +e, this.l = +n, this.opacity = +r;
}
rn(te, ba, rr(He, {
  brighter(t4) {
    return t4 = t4 == null ? lt : Math.pow(lt, t4), new te(this.h, this.s, this.l * t4, this.opacity);
  },
  darker(t4) {
    return t4 = t4 == null ? Ue : Math.pow(Ue, t4), new te(this.h, this.s, this.l * t4, this.opacity);
  },
  rgb() {
    var t4 = this.h % 360 + (this.h < 0) * 360, e = isNaN(t4) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * e, i = 2 * n - r;
    return new q(
      Mt(t4 >= 240 ? t4 - 240 : t4 + 120, i, r),
      Mt(t4, i, r),
      Mt(t4 < 120 ? t4 + 240 : t4 - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new te(_n(this.h), je(this.s), je(this.l), ht(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t4 = ht(this.opacity);
    return `${t4 === 1 ? "hsl(" : "hsla("}${_n(this.h)}, ${je(this.s) * 100}%, ${je(this.l) * 100}%${t4 === 1 ? ")" : `, ${t4})`}`;
  }
}));
function _n(t4) {
  return t4 = (t4 || 0) % 360, t4 < 0 ? t4 + 360 : t4;
}
function je(t4) {
  return Math.max(0, Math.min(1, t4 || 0));
}
function Mt(t4, e, n) {
  return (t4 < 60 ? e + (n - e) * t4 / 60 : t4 < 180 ? n : t4 < 240 ? e + (n - e) * (240 - t4) / 60 : e) * 255;
}
var ar = (t4) => () => t4;
function wa(t4, e) {
  return function(n) {
    return t4 + n * e;
  };
}
function Ea(t4, e, n) {
  return t4 = Math.pow(t4, n), e = Math.pow(e, n) - t4, n = 1 / n, function(r) {
    return Math.pow(t4 + r * e, n);
  };
}
function ka(t4) {
  return (t4 = +t4) == 1 ? sr : function(e, n) {
    return n - e ? Ea(e, n, t4) : ar(isNaN(e) ? n : e);
  };
}
function sr(t4, e) {
  var n = e - t4;
  return n ? wa(t4, n) : ar(isNaN(t4) ? e : t4);
}
var yn = function t(e) {
  var n = ka(e);
  function r(i, a) {
    var o = n((i = ut(i)).r, (a = ut(a)).r), s = n(i.g, a.g), l = n(i.b, a.b), h = sr(i.opacity, a.opacity);
    return function(u) {
      return i.r = o(u), i.g = s(u), i.b = l(u), i.opacity = h(u), i + "";
    };
  }
  return r.gamma = t, r;
}(1);
function ce(t4, e) {
  return t4 = +t4, e = +e, function(n) {
    return t4 * (1 - n) + e * n;
  };
}
var Gt = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var Rt = new RegExp(Gt.source, "g");
function Ca(t4) {
  return function() {
    return t4;
  };
}
function Ia(t4) {
  return function(e) {
    return t4(e) + "";
  };
}
function Ba(t4, e) {
  var n = Gt.lastIndex = Rt.lastIndex = 0, r, i, a, o = -1, s = [], l = [];
  for (t4 = t4 + "", e = e + ""; (r = Gt.exec(t4)) && (i = Rt.exec(e)); )
    (a = i.index) > n && (a = e.slice(n, a), s[o] ? s[o] += a : s[++o] = a), (r = r[0]) === (i = i[0]) ? s[o] ? s[o] += i : s[++o] = i : (s[++o] = null, l.push({ i: o, x: ce(r, i) })), n = Rt.lastIndex;
  return n < e.length && (a = e.slice(n), s[o] ? s[o] += a : s[++o] = a), s.length < 2 ? l[0] ? Ia(l[0].x) : Ca(e) : (e = l.length, function(h) {
    for (var u = 0, f; u < e; ++u)
      s[(f = l[u]).i] = f.x(h);
    return s.join("");
  });
}
var xn = 180 / Math.PI;
var Vt = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function or(t4, e, n, r, i, a) {
  var o, s, l;
  return (o = Math.sqrt(t4 * t4 + e * e)) && (t4 /= o, e /= o), (l = t4 * n + e * r) && (n -= t4 * l, r -= e * l), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, l /= s), t4 * r < e * n && (t4 = -t4, e = -e, l = -l, o = -o), {
    translateX: i,
    translateY: a,
    rotate: Math.atan2(e, t4) * xn,
    skewX: Math.atan(l) * xn,
    scaleX: o,
    scaleY: s
  };
}
var $e;
function Fa(t4) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t4 + "");
  return e.isIdentity ? Vt : or(e.a, e.b, e.c, e.d, e.e, e.f);
}
function Ma(t4) {
  return t4 == null || ($e || ($e = document.createElementNS("http://www.w3.org/2000/svg", "g")), $e.setAttribute("transform", t4), !(t4 = $e.transform.baseVal.consolidate())) ? Vt : (t4 = t4.matrix, or(t4.a, t4.b, t4.c, t4.d, t4.e, t4.f));
}
function lr(t4, e, n, r) {
  function i(h) {
    return h.length ? h.pop() + " " : "";
  }
  function a(h, u, f, c, d, v) {
    if (h !== f || u !== c) {
      var g = d.push("translate(", null, e, null, n);
      v.push({ i: g - 4, x: ce(h, f) }, { i: g - 2, x: ce(u, c) });
    } else
      (f || c) && d.push("translate(" + f + e + c + n);
  }
  function o(h, u, f, c) {
    h !== u ? (h - u > 180 ? u += 360 : u - h > 180 && (h += 360), c.push({ i: f.push(i(f) + "rotate(", null, r) - 2, x: ce(h, u) })) : u && f.push(i(f) + "rotate(" + u + r);
  }
  function s(h, u, f, c) {
    h !== u ? c.push({ i: f.push(i(f) + "skewX(", null, r) - 2, x: ce(h, u) }) : u && f.push(i(f) + "skewX(" + u + r);
  }
  function l(h, u, f, c, d, v) {
    if (h !== f || u !== c) {
      var g = d.push(i(d) + "scale(", null, ",", null, ")");
      v.push({ i: g - 4, x: ce(h, f) }, { i: g - 2, x: ce(u, c) });
    } else
      (f !== 1 || c !== 1) && d.push(i(d) + "scale(" + f + "," + c + ")");
  }
  return function(h, u) {
    var f = [], c = [];
    return h = t4(h), u = t4(u), a(h.translateX, h.translateY, u.translateX, u.translateY, f, c), o(h.rotate, u.rotate, f, c), s(h.skewX, u.skewX, f, c), l(h.scaleX, h.scaleY, u.scaleX, u.scaleY, f, c), h = u = null, function(d) {
      for (var v = -1, g = c.length, p; ++v < g; )
        f[(p = c[v]).i] = p.x(d);
      return f.join("");
    };
  };
}
var Ra = lr(Fa, "px, ", "px)", "deg)");
var Sa = lr(Ma, ", ", ")", ")");
var Ta = 1e-12;
function bn(t4) {
  return ((t4 = Math.exp(t4)) + 1 / t4) / 2;
}
function Na(t4) {
  return ((t4 = Math.exp(t4)) - 1 / t4) / 2;
}
function Pa(t4) {
  return ((t4 = Math.exp(2 * t4)) - 1) / (t4 + 1);
}
var Oa = function t2(e, n, r) {
  function i(a, o) {
    var s = a[0], l = a[1], h = a[2], u = o[0], f = o[1], c = o[2], d = u - s, v = f - l, g = d * d + v * v, p, x;
    if (g < Ta)
      x = Math.log(c / h) / e, p = function(C) {
        return [
          s + C * d,
          l + C * v,
          h * Math.exp(e * C * x)
        ];
      };
    else {
      var w = Math.sqrt(g), b = (c * c - h * h + r * g) / (2 * h * n * w), m = (c * c - h * h - r * g) / (2 * c * n * w), _ = Math.log(Math.sqrt(b * b + 1) - b), A = Math.log(Math.sqrt(m * m + 1) - m);
      x = (A - _) / e, p = function(C) {
        var k = C * x, M = bn(_), P = h / (n * w) * (M * Pa(e * k + _) - Na(_));
        return [
          s + P * d,
          l + P * v,
          h * M / bn(e * k + _)
        ];
      };
    }
    return p.duration = x * 1e3 * e / Math.SQRT2, p;
  }
  return i.rho = function(a) {
    var o = Math.max(1e-3, +a), s = o * o, l = s * s;
    return t2(o, s, l);
  }, i;
}(Math.SQRT2, 2, 4);
var Ie = 0;
var De = 0;
var Fe = 0;
var ur = 1e3;
var ft;
var Le;
var ct = 0;
var be = 0;
var _t = 0;
var Ve = typeof performance == "object" && performance.now ? performance : Date;
var hr = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t4) {
  setTimeout(t4, 17);
};
function an() {
  return be || (hr(za), be = Ve.now() + _t);
}
function za() {
  be = 0;
}
function dt() {
  this._call = this._time = this._next = null;
}
dt.prototype = fr.prototype = {
  constructor: dt,
  restart: function(t4, e, n) {
    if (typeof t4 != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? an() : +n) + (e == null ? 0 : +e), !this._next && Le !== this && (Le ? Le._next = this : ft = this, Le = this), this._call = t4, this._time = n, Wt();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Wt());
  }
};
function fr(t4, e, n) {
  var r = new dt();
  return r.restart(t4, e, n), r;
}
function Da() {
  an(), ++Ie;
  for (var t4 = ft, e; t4; )
    (e = be - t4._time) >= 0 && t4._call.call(void 0, e), t4 = t4._next;
  --Ie;
}
function wn() {
  be = (ct = Ve.now()) + _t, Ie = De = 0;
  try {
    Da();
  } finally {
    Ie = 0, Ua(), be = 0;
  }
}
function La() {
  var t4 = Ve.now(), e = t4 - ct;
  e > ur && (_t -= e, ct = t4);
}
function Ua() {
  for (var t4, e = ft, n, r = 1 / 0; e; )
    e._call ? (r > e._time && (r = e._time), t4 = e, e = e._next) : (n = e._next, e._next = null, e = t4 ? t4._next = n : ft = n);
  Le = t4, Wt(r);
}
function Wt(t4) {
  if (!Ie) {
    De && (De = clearTimeout(De));
    var e = t4 - be;
    e > 24 ? (t4 < 1 / 0 && (De = setTimeout(wn, t4 - Ve.now() - _t)), Fe && (Fe = clearInterval(Fe))) : (Fe || (ct = Ve.now(), Fe = setInterval(La, ur)), Ie = 1, hr(wn));
  }
}
function En(t4, e, n) {
  var r = new dt();
  return e = e == null ? 0 : +e, r.restart((i) => {
    r.stop(), t4(i + e);
  }, e, n), r;
}
var Qa = nn("start", "end", "cancel", "interrupt");
var Ga = [];
var cr = 0;
var kn = 1;
var Ht = 2;
var nt = 3;
var Cn = 4;
var Yt = 5;
var rt = 6;
function yt(t4, e, n, r, i, a) {
  var o = t4.__transition;
  if (!o)
    t4.__transition = {};
  else if (n in o)
    return;
  Va(t4, n, {
    name: e,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Qa,
    tween: Ga,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: cr
  });
}
function sn(t4, e) {
  var n = ne(t4, e);
  if (n.state > cr)
    throw new Error("too late; already scheduled");
  return n;
}
function ae(t4, e) {
  var n = ne(t4, e);
  if (n.state > nt)
    throw new Error("too late; already running");
  return n;
}
function ne(t4, e) {
  var n = t4.__transition;
  if (!n || !(n = n[e]))
    throw new Error("transition not found");
  return n;
}
function Va(t4, e, n) {
  var r = t4.__transition, i;
  r[e] = n, n.timer = fr(a, 0, n.time);
  function a(h) {
    n.state = kn, n.timer.restart(o, n.delay, n.time), n.delay <= h && o(h - n.delay);
  }
  function o(h) {
    var u, f, c, d;
    if (n.state !== kn)
      return l();
    for (u in r)
      if (d = r[u], d.name === n.name) {
        if (d.state === nt)
          return En(o);
        d.state === Cn ? (d.state = rt, d.timer.stop(), d.on.call("interrupt", t4, t4.__data__, d.index, d.group), delete r[u]) : +u < e && (d.state = rt, d.timer.stop(), d.on.call("cancel", t4, t4.__data__, d.index, d.group), delete r[u]);
      }
    if (En(function() {
      n.state === nt && (n.state = Cn, n.timer.restart(s, n.delay, n.time), s(h));
    }), n.state = Ht, n.on.call("start", t4, t4.__data__, n.index, n.group), n.state === Ht) {
      for (n.state = nt, i = new Array(c = n.tween.length), u = 0, f = -1; u < c; ++u)
        (d = n.tween[u].value.call(t4, t4.__data__, n.index, n.group)) && (i[++f] = d);
      i.length = f + 1;
    }
  }
  function s(h) {
    for (var u = h < n.duration ? n.ease.call(null, h / n.duration) : (n.timer.restart(l), n.state = Yt, 1), f = -1, c = i.length; ++f < c; )
      i[f].call(t4, u);
    n.state === Yt && (n.on.call("end", t4, t4.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = rt, n.timer.stop(), delete r[e];
    for (var h in r)
      return;
    delete t4.__transition;
  }
}
function it(t4, e) {
  var n = t4.__transition, r, i, a = true, o;
  if (n) {
    e = e == null ? null : e + "";
    for (o in n) {
      if ((r = n[o]).name !== e) {
        a = false;
        continue;
      }
      i = r.state > Ht && r.state < Yt, r.state = rt, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", t4, t4.__data__, r.index, r.group), delete n[o];
    }
    a && delete t4.__transition;
  }
}
function Wa(t4) {
  return this.each(function() {
    it(this, t4);
  });
}
function Ha(t4, e) {
  var n, r;
  return function() {
    var i = ae(this, t4), a = i.tween;
    if (a !== n) {
      r = n = a;
      for (var o = 0, s = r.length; o < s; ++o)
        if (r[o].name === e) {
          r = r.slice(), r.splice(o, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function Ya(t4, e, n) {
  var r, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var a = ae(this, t4), o = a.tween;
    if (o !== r) {
      i = (r = o).slice();
      for (var s = { name: e, value: n }, l = 0, h = i.length; l < h; ++l)
        if (i[l].name === e) {
          i[l] = s;
          break;
        }
      l === h && i.push(s);
    }
    a.tween = i;
  };
}
function qa(t4, e) {
  var n = this._id;
  if (t4 += "", arguments.length < 2) {
    for (var r = ne(this.node(), n).tween, i = 0, a = r.length, o; i < a; ++i)
      if ((o = r[i]).name === t4)
        return o.value;
    return null;
  }
  return this.each((e == null ? Ha : Ya)(n, t4, e));
}
function on(t4, e, n) {
  var r = t4._id;
  return t4.each(function() {
    var i = ae(this, r);
    (i.value || (i.value = {}))[e] = n.apply(this, arguments);
  }), function(i) {
    return ne(i, r).value[e];
  };
}
function dr(t4, e) {
  var n;
  return (typeof e == "number" ? ce : e instanceof Ge ? yn : (n = Ge(e)) ? (e = n, yn) : Ba)(t4, e);
}
function Xa(t4) {
  return function() {
    this.removeAttribute(t4);
  };
}
function ja(t4) {
  return function() {
    this.removeAttributeNS(t4.space, t4.local);
  };
}
function $a(t4, e, n) {
  var r, i = n + "", a;
  return function() {
    var o = this.getAttribute(t4);
    return o === i ? null : o === r ? a : a = e(r = o, n);
  };
}
function Za(t4, e, n) {
  var r, i = n + "", a;
  return function() {
    var o = this.getAttributeNS(t4.space, t4.local);
    return o === i ? null : o === r ? a : a = e(r = o, n);
  };
}
function Ka(t4, e, n) {
  var r, i, a;
  return function() {
    var o, s = n(this), l;
    return s == null ? void this.removeAttribute(t4) : (o = this.getAttribute(t4), l = s + "", o === l ? null : o === r && l === i ? a : (i = l, a = e(r = o, s)));
  };
}
function Ja(t4, e, n) {
  var r, i, a;
  return function() {
    var o, s = n(this), l;
    return s == null ? void this.removeAttributeNS(t4.space, t4.local) : (o = this.getAttributeNS(t4.space, t4.local), l = s + "", o === l ? null : o === r && l === i ? a : (i = l, a = e(r = o, s)));
  };
}
function es(t4, e) {
  var n = At(t4), r = n === "transform" ? Sa : dr;
  return this.attrTween(t4, typeof e == "function" ? (n.local ? Ja : Ka)(n, r, on(this, "attr." + t4, e)) : e == null ? (n.local ? ja : Xa)(n) : (n.local ? Za : $a)(n, r, e));
}
function ts(t4, e) {
  return function(n) {
    this.setAttribute(t4, e.call(this, n));
  };
}
function ns(t4, e) {
  return function(n) {
    this.setAttributeNS(t4.space, t4.local, e.call(this, n));
  };
}
function rs(t4, e) {
  var n, r;
  function i() {
    var a = e.apply(this, arguments);
    return a !== r && (n = (r = a) && ns(t4, a)), n;
  }
  return i._value = e, i;
}
function is(t4, e) {
  var n, r;
  function i() {
    var a = e.apply(this, arguments);
    return a !== r && (n = (r = a) && ts(t4, a)), n;
  }
  return i._value = e, i;
}
function as(t4, e) {
  var n = "attr." + t4;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (e == null)
    return this.tween(n, null);
  if (typeof e != "function")
    throw new Error();
  var r = At(t4);
  return this.tween(n, (r.local ? rs : is)(r, e));
}
function ss(t4, e) {
  return function() {
    sn(this, t4).delay = +e.apply(this, arguments);
  };
}
function os(t4, e) {
  return e = +e, function() {
    sn(this, t4).delay = e;
  };
}
function ls(t4) {
  var e = this._id;
  return arguments.length ? this.each((typeof t4 == "function" ? ss : os)(e, t4)) : ne(this.node(), e).delay;
}
function us(t4, e) {
  return function() {
    ae(this, t4).duration = +e.apply(this, arguments);
  };
}
function hs(t4, e) {
  return e = +e, function() {
    ae(this, t4).duration = e;
  };
}
function fs(t4) {
  var e = this._id;
  return arguments.length ? this.each((typeof t4 == "function" ? us : hs)(e, t4)) : ne(this.node(), e).duration;
}
function cs(t4, e) {
  if (typeof e != "function")
    throw new Error();
  return function() {
    ae(this, t4).ease = e;
  };
}
function ds(t4) {
  var e = this._id;
  return arguments.length ? this.each(cs(e, t4)) : ne(this.node(), e).ease;
}
function gs(t4, e) {
  return function() {
    var n = e.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    ae(this, t4).ease = n;
  };
}
function vs(t4) {
  if (typeof t4 != "function")
    throw new Error();
  return this.each(gs(this._id, t4));
}
function ms(t4) {
  typeof t4 != "function" && (t4 = qn(t4));
  for (var e = this._groups, n = e.length, r = new Array(n), i = 0; i < n; ++i)
    for (var a = e[i], o = a.length, s = r[i] = [], l, h = 0; h < o; ++h)
      (l = a[h]) && t4.call(l, l.__data__, h, a) && s.push(l);
  return new he(r, this._parents, this._name, this._id);
}
function ps(t4) {
  if (t4._id !== this._id)
    throw new Error();
  for (var e = this._groups, n = t4._groups, r = e.length, i = n.length, a = Math.min(r, i), o = new Array(r), s = 0; s < a; ++s)
    for (var l = e[s], h = n[s], u = l.length, f = o[s] = new Array(u), c, d = 0; d < u; ++d)
      (c = l[d] || h[d]) && (f[d] = c);
  for (; s < r; ++s)
    o[s] = e[s];
  return new he(o, this._parents, this._name, this._id);
}
function As(t4) {
  return (t4 + "").trim().split(/^|\s+/).every(function(e) {
    var n = e.indexOf(".");
    return n >= 0 && (e = e.slice(0, n)), !e || e === "start";
  });
}
function _s(t4, e, n) {
  var r, i, a = As(e) ? sn : ae;
  return function() {
    var o = a(this, t4), s = o.on;
    s !== r && (i = (r = s).copy()).on(e, n), o.on = i;
  };
}
function ys(t4, e) {
  var n = this._id;
  return arguments.length < 2 ? ne(this.node(), n).on.on(t4) : this.each(_s(n, t4, e));
}
function xs(t4) {
  return function() {
    var e = this.parentNode;
    for (var n in this.__transition)
      if (+n !== t4)
        return;
    e && e.removeChild(this);
  };
}
function bs() {
  return this.on("end.remove", xs(this._id));
}
function ws(t4) {
  var e = this._name, n = this._id;
  typeof t4 != "function" && (t4 = en(t4));
  for (var r = this._groups, i = r.length, a = new Array(i), o = 0; o < i; ++o)
    for (var s = r[o], l = s.length, h = a[o] = new Array(l), u, f, c = 0; c < l; ++c)
      (u = s[c]) && (f = t4.call(u, u.__data__, c, s)) && ("__data__" in u && (f.__data__ = u.__data__), h[c] = f, yt(h[c], e, n, c, h, ne(u, n)));
  return new he(a, this._parents, e, n);
}
function Es(t4) {
  var e = this._name, n = this._id;
  typeof t4 != "function" && (t4 = Yn(t4));
  for (var r = this._groups, i = r.length, a = [], o = [], s = 0; s < i; ++s)
    for (var l = r[s], h = l.length, u, f = 0; f < h; ++f)
      if (u = l[f]) {
        for (var c = t4.call(u, u.__data__, f, l), d, v = ne(u, n), g = 0, p = c.length; g < p; ++g)
          (d = c[g]) && yt(d, e, n, g, c, v);
        a.push(c), o.push(u);
      }
  return new he(a, o, e, n);
}
var ks = We.prototype.constructor;
function Cs() {
  return new ks(this._groups, this._parents);
}
function Is(t4, e) {
  var n, r, i;
  return function() {
    var a = Ce(this, t4), o = (this.style.removeProperty(t4), Ce(this, t4));
    return a === o ? null : a === n && o === r ? i : i = e(n = a, r = o);
  };
}
function gr(t4) {
  return function() {
    this.style.removeProperty(t4);
  };
}
function Bs(t4, e, n) {
  var r, i = n + "", a;
  return function() {
    var o = Ce(this, t4);
    return o === i ? null : o === r ? a : a = e(r = o, n);
  };
}
function Fs(t4, e, n) {
  var r, i, a;
  return function() {
    var o = Ce(this, t4), s = n(this), l = s + "";
    return s == null && (l = s = (this.style.removeProperty(t4), Ce(this, t4))), o === l ? null : o === r && l === i ? a : (i = l, a = e(r = o, s));
  };
}
function Ms(t4, e) {
  var n, r, i, a = "style." + e, o = "end." + a, s;
  return function() {
    var l = ae(this, t4), h = l.on, u = l.value[a] == null ? s || (s = gr(e)) : void 0;
    (h !== n || i !== u) && (r = (n = h).copy()).on(o, i = u), l.on = r;
  };
}
function Rs(t4, e, n) {
  var r = (t4 += "") == "transform" ? Ra : dr;
  return e == null ? this.styleTween(t4, Is(t4, r)).on("end.style." + t4, gr(t4)) : typeof e == "function" ? this.styleTween(t4, Fs(t4, r, on(this, "style." + t4, e))).each(Ms(this._id, t4)) : this.styleTween(t4, Bs(t4, r, e), n).on("end.style." + t4, null);
}
function Ss(t4, e, n) {
  return function(r) {
    this.style.setProperty(t4, e.call(this, r), n);
  };
}
function Ts(t4, e, n) {
  var r, i;
  function a() {
    var o = e.apply(this, arguments);
    return o !== i && (r = (i = o) && Ss(t4, o, n)), r;
  }
  return a._value = e, a;
}
function Ns(t4, e, n) {
  var r = "style." + (t4 += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (e == null)
    return this.tween(r, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(r, Ts(t4, e, n ?? ""));
}
function Ps(t4) {
  return function() {
    this.textContent = t4;
  };
}
function Os(t4) {
  return function() {
    var e = t4(this);
    this.textContent = e ?? "";
  };
}
function zs(t4) {
  return this.tween("text", typeof t4 == "function" ? Os(on(this, "text", t4)) : Ps(t4 == null ? "" : t4 + ""));
}
function Ds(t4) {
  return function(e) {
    this.textContent = t4.call(this, e);
  };
}
function Ls(t4) {
  var e, n;
  function r() {
    var i = t4.apply(this, arguments);
    return i !== n && (e = (n = i) && Ds(i)), e;
  }
  return r._value = t4, r;
}
function Us(t4) {
  var e = "text";
  if (arguments.length < 1)
    return (e = this.tween(e)) && e._value;
  if (t4 == null)
    return this.tween(e, null);
  if (typeof t4 != "function")
    throw new Error();
  return this.tween(e, Ls(t4));
}
function Qs() {
  for (var t4 = this._name, e = this._id, n = vr(), r = this._groups, i = r.length, a = 0; a < i; ++a)
    for (var o = r[a], s = o.length, l, h = 0; h < s; ++h)
      if (l = o[h]) {
        var u = ne(l, e);
        yt(l, t4, n, h, o, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease
        });
      }
  return new he(r, this._parents, t4, n);
}
function Gs() {
  var t4, e, n = this, r = n._id, i = n.size();
  return new Promise(function(a, o) {
    var s = { value: o }, l = { value: function() {
      --i === 0 && a();
    } };
    n.each(function() {
      var h = ae(this, r), u = h.on;
      u !== t4 && (e = (t4 = u).copy(), e._.cancel.push(s), e._.interrupt.push(s), e._.end.push(l)), h.on = e;
    }), i === 0 && a();
  });
}
var Vs = 0;
function he(t4, e, n, r) {
  this._groups = t4, this._parents = e, this._name = n, this._id = r;
}
function vr() {
  return ++Vs;
}
var se = We.prototype;
he.prototype = {
  constructor: he,
  select: ws,
  selectAll: Es,
  selectChild: se.selectChild,
  selectChildren: se.selectChildren,
  filter: ms,
  merge: ps,
  selection: Cs,
  transition: Qs,
  call: se.call,
  nodes: se.nodes,
  node: se.node,
  size: se.size,
  empty: se.empty,
  each: se.each,
  on: ys,
  attr: es,
  attrTween: as,
  style: Rs,
  styleTween: Ns,
  text: zs,
  textTween: Us,
  remove: bs,
  tween: qa,
  delay: ls,
  duration: fs,
  ease: ds,
  easeVarying: vs,
  end: Gs,
  [Symbol.iterator]: se[Symbol.iterator]
};
var Ws = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Cr
};
function Hs(t4, e) {
  for (var n; !(n = t4.__transition) || !(n = n[e]); )
    if (!(t4 = t4.parentNode))
      throw new Error(`transition ${e} not found`);
  return n;
}
function Ys(t4) {
  var e, n;
  t4 instanceof he ? (e = t4._id, t4 = t4._name) : (e = vr(), (n = Ws).time = an(), t4 = t4 == null ? null : t4 + "");
  for (var r = this._groups, i = r.length, a = 0; a < i; ++a)
    for (var o = r[a], s = o.length, l, h = 0; h < s; ++h)
      (l = o[h]) && yt(l, t4, e, h, o, n || Hs(l, e));
  return new he(r, this._parents, t4, e);
}
We.prototype.interrupt = Wa;
We.prototype.transition = Ys;
var Ze = (t4) => () => t4;
function qs(t4, {
  sourceEvent: e,
  target: n,
  transform: r,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: t4, enumerable: true, configurable: true },
    sourceEvent: { value: e, enumerable: true, configurable: true },
    target: { value: n, enumerable: true, configurable: true },
    transform: { value: r, enumerable: true, configurable: true },
    _: { value: i }
  });
}
function ue(t4, e, n) {
  this.k = t4, this.x = e, this.y = n;
}
ue.prototype = {
  constructor: ue,
  scale: function(t4) {
    return t4 === 1 ? this : new ue(this.k * t4, this.x, this.y);
  },
  translate: function(t4, e) {
    return t4 === 0 & e === 0 ? this : new ue(this.k, this.x + this.k * t4, this.y + this.k * e);
  },
  apply: function(t4) {
    return [t4[0] * this.k + this.x, t4[1] * this.k + this.y];
  },
  applyX: function(t4) {
    return t4 * this.k + this.x;
  },
  applyY: function(t4) {
    return t4 * this.k + this.y;
  },
  invert: function(t4) {
    return [(t4[0] - this.x) / this.k, (t4[1] - this.y) / this.k];
  },
  invertX: function(t4) {
    return (t4 - this.x) / this.k;
  },
  invertY: function(t4) {
    return (t4 - this.y) / this.k;
  },
  rescaleX: function(t4) {
    return t4.copy().domain(t4.range().map(this.invertX, this).map(t4.invert, t4));
  },
  rescaleY: function(t4) {
    return t4.copy().domain(t4.range().map(this.invertY, this).map(t4.invert, t4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var _e = new ue(1, 0, 0);
ue.prototype;
function St(t4) {
  t4.stopImmediatePropagation();
}
function Me(t4) {
  t4.preventDefault(), t4.stopImmediatePropagation();
}
function Xs(t4) {
  return (!t4.ctrlKey || t4.type === "wheel") && !t4.button;
}
function js() {
  var t4 = this;
  return t4 instanceof SVGElement ? (t4 = t4.ownerSVGElement || t4, t4.hasAttribute("viewBox") ? (t4 = t4.viewBox.baseVal, [[t4.x, t4.y], [t4.x + t4.width, t4.y + t4.height]]) : [[0, 0], [t4.width.baseVal.value, t4.height.baseVal.value]]) : [[0, 0], [t4.clientWidth, t4.clientHeight]];
}
function In() {
  return this.__zoom || _e;
}
function $s(t4) {
  return -t4.deltaY * (t4.deltaMode === 1 ? 0.05 : t4.deltaMode ? 1 : 2e-3) * (t4.ctrlKey ? 10 : 1);
}
function Zs() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Ks(t4, e, n) {
  var r = t4.invertX(e[0][0]) - n[0][0], i = t4.invertX(e[1][0]) - n[1][0], a = t4.invertY(e[0][1]) - n[0][1], o = t4.invertY(e[1][1]) - n[1][1];
  return t4.translate(
    i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
    o > a ? (a + o) / 2 : Math.min(0, a) || Math.max(0, o)
  );
}
function Js() {
  var t4 = Xs, e = js, n = Ks, r = $s, i = Zs, a = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, l = Oa, h = nn("start", "zoom", "end"), u, f, c, d = 500, v = 150, g = 0, p = 10;
  function x(y) {
    y.property("__zoom", In).on("wheel.zoom", k, { passive: false }).on("mousedown.zoom", M).on("dblclick.zoom", P).filter(i).on("touchstart.zoom", I).on("touchmove.zoom", N).on("touchend.zoom touchcancel.zoom", z).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  x.transform = function(y, F, E, S) {
    var B = y.selection ? y.selection() : y;
    B.property("__zoom", In), y !== B ? _(y, F, E, S) : B.interrupt().each(function() {
      A(this, arguments).event(S).start().zoom(null, typeof F == "function" ? F.apply(this, arguments) : F).end();
    });
  }, x.scaleBy = function(y, F, E, S) {
    x.scaleTo(y, function() {
      var B = this.__zoom.k, T = typeof F == "function" ? F.apply(this, arguments) : F;
      return B * T;
    }, E, S);
  }, x.scaleTo = function(y, F, E, S) {
    x.transform(y, function() {
      var B = e.apply(this, arguments), T = this.__zoom, R = E == null ? m(B) : typeof E == "function" ? E.apply(this, arguments) : E, O = T.invert(R), D = typeof F == "function" ? F.apply(this, arguments) : F;
      return n(b(w(T, D), R, O), B, o);
    }, E, S);
  }, x.translateBy = function(y, F, E, S) {
    x.transform(y, function() {
      return n(this.__zoom.translate(
        typeof F == "function" ? F.apply(this, arguments) : F,
        typeof E == "function" ? E.apply(this, arguments) : E
      ), e.apply(this, arguments), o);
    }, null, S);
  }, x.translateTo = function(y, F, E, S, B) {
    x.transform(y, function() {
      var T = e.apply(this, arguments), R = this.__zoom, O = S == null ? m(T) : typeof S == "function" ? S.apply(this, arguments) : S;
      return n(_e.translate(O[0], O[1]).scale(R.k).translate(
        typeof F == "function" ? -F.apply(this, arguments) : -F,
        typeof E == "function" ? -E.apply(this, arguments) : -E
      ), T, o);
    }, S, B);
  };
  function w(y, F) {
    return F = Math.max(a[0], Math.min(a[1], F)), F === y.k ? y : new ue(F, y.x, y.y);
  }
  function b(y, F, E) {
    var S = F[0] - E[0] * y.k, B = F[1] - E[1] * y.k;
    return S === y.x && B === y.y ? y : new ue(y.k, S, B);
  }
  function m(y) {
    return [(+y[0][0] + +y[1][0]) / 2, (+y[0][1] + +y[1][1]) / 2];
  }
  function _(y, F, E, S) {
    y.on("start.zoom", function() {
      A(this, arguments).event(S).start();
    }).on("interrupt.zoom end.zoom", function() {
      A(this, arguments).event(S).end();
    }).tween("zoom", function() {
      var B = this, T = arguments, R = A(B, T).event(S), O = e.apply(B, T), D = E == null ? m(O) : typeof E == "function" ? E.apply(B, T) : E, L = Math.max(O[1][0] - O[0][0], O[1][1] - O[0][1]), U = B.__zoom, Q = typeof F == "function" ? F.apply(B, T) : F, G = l(U.invert(D).concat(L / U.k), Q.invert(D).concat(L / Q.k));
      return function(V) {
        if (V === 1)
          V = Q;
        else {
          var W = G(V), Y = L / W[2];
          V = new ue(Y, D[0] - W[0] * Y, D[1] - W[1] * Y);
        }
        R.zoom(null, V);
      };
    });
  }
  function A(y, F, E) {
    return !E && y.__zooming || new C(y, F);
  }
  function C(y, F) {
    this.that = y, this.args = F, this.active = 0, this.sourceEvent = null, this.extent = e.apply(y, F), this.taps = 0;
  }
  C.prototype = {
    event: function(y) {
      return y && (this.sourceEvent = y), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(y, F) {
      return this.mouse && y !== "mouse" && (this.mouse[1] = F.invert(this.mouse[0])), this.touch0 && y !== "touch" && (this.touch0[1] = F.invert(this.touch0[0])), this.touch1 && y !== "touch" && (this.touch1[1] = F.invert(this.touch1[0])), this.that.__zoom = F, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(y) {
      var F = j(this.that).datum();
      h.call(
        y,
        this.that,
        new qs(y, {
          sourceEvent: this.sourceEvent,
          target: x,
          type: y,
          transform: this.that.__zoom,
          dispatch: h
        }),
        F
      );
    }
  };
  function k(y, ...F) {
    if (!t4.apply(this, arguments))
      return;
    var E = A(this, F).event(y), S = this.__zoom, B = Math.max(a[0], Math.min(a[1], S.k * Math.pow(2, r.apply(this, arguments)))), T = Ae(y);
    if (E.wheel)
      (E.mouse[0][0] !== T[0] || E.mouse[0][1] !== T[1]) && (E.mouse[1] = S.invert(E.mouse[0] = T)), clearTimeout(E.wheel);
    else {
      if (S.k === B)
        return;
      E.mouse = [T, S.invert(T)], it(this), E.start();
    }
    Me(y), E.wheel = setTimeout(R, v), E.zoom("mouse", n(b(w(S, B), E.mouse[0], E.mouse[1]), E.extent, o));
    function R() {
      E.wheel = null, E.end();
    }
  }
  function M(y, ...F) {
    if (c || !t4.apply(this, arguments))
      return;
    var E = y.currentTarget, S = A(this, F, true).event(y), B = j(y.view).on("mousemove.zoom", D, true).on("mouseup.zoom", L, true), T = Ae(y, E), R = y.clientX, O = y.clientY;
    ua(y.view), St(y), S.mouse = [T, this.__zoom.invert(T)], it(this), S.start();
    function D(U) {
      if (Me(U), !S.moved) {
        var Q = U.clientX - R, G = U.clientY - O;
        S.moved = Q * Q + G * G > g;
      }
      S.event(U).zoom("mouse", n(b(S.that.__zoom, S.mouse[0] = Ae(U, E), S.mouse[1]), S.extent, o));
    }
    function L(U) {
      B.on("mousemove.zoom mouseup.zoom", null), ha(U.view, S.moved), Me(U), S.event(U).end();
    }
  }
  function P(y, ...F) {
    if (t4.apply(this, arguments)) {
      var E = this.__zoom, S = Ae(y.changedTouches ? y.changedTouches[0] : y, this), B = E.invert(S), T = E.k * (y.shiftKey ? 0.5 : 2), R = n(b(w(E, T), S, B), e.apply(this, F), o);
      Me(y), s > 0 ? j(this).transition().duration(s).call(_, R, S, y) : j(this).call(x.transform, R, S, y);
    }
  }
  function I(y, ...F) {
    if (t4.apply(this, arguments)) {
      var E = y.touches, S = E.length, B = A(this, F, y.changedTouches.length === S).event(y), T, R, O, D;
      for (St(y), R = 0; R < S; ++R)
        O = E[R], D = Ae(O, this), D = [D, this.__zoom.invert(D), O.identifier], B.touch0 ? !B.touch1 && B.touch0[2] !== D[2] && (B.touch1 = D, B.taps = 0) : (B.touch0 = D, T = true, B.taps = 1 + !!u);
      u && (u = clearTimeout(u)), T && (B.taps < 2 && (f = D[0], u = setTimeout(function() {
        u = null;
      }, d)), it(this), B.start());
    }
  }
  function N(y, ...F) {
    if (this.__zooming) {
      var E = A(this, F).event(y), S = y.changedTouches, B = S.length, T, R, O, D;
      for (Me(y), T = 0; T < B; ++T)
        R = S[T], O = Ae(R, this), E.touch0 && E.touch0[2] === R.identifier ? E.touch0[0] = O : E.touch1 && E.touch1[2] === R.identifier && (E.touch1[0] = O);
      if (R = E.that.__zoom, E.touch1) {
        var L = E.touch0[0], U = E.touch0[1], Q = E.touch1[0], G = E.touch1[1], V = (V = Q[0] - L[0]) * V + (V = Q[1] - L[1]) * V, W = (W = G[0] - U[0]) * W + (W = G[1] - U[1]) * W;
        R = w(R, Math.sqrt(V / W)), O = [(L[0] + Q[0]) / 2, (L[1] + Q[1]) / 2], D = [(U[0] + G[0]) / 2, (U[1] + G[1]) / 2];
      } else if (E.touch0)
        O = E.touch0[0], D = E.touch0[1];
      else
        return;
      E.zoom("touch", n(b(R, O, D), E.extent, o));
    }
  }
  function z(y, ...F) {
    if (this.__zooming) {
      var E = A(this, F).event(y), S = y.changedTouches, B = S.length, T, R;
      for (St(y), c && clearTimeout(c), c = setTimeout(function() {
        c = null;
      }, d), T = 0; T < B; ++T)
        R = S[T], E.touch0 && E.touch0[2] === R.identifier ? delete E.touch0 : E.touch1 && E.touch1[2] === R.identifier && delete E.touch1;
      if (E.touch1 && !E.touch0 && (E.touch0 = E.touch1, delete E.touch1), E.touch0)
        E.touch0[1] = this.__zoom.invert(E.touch0[0]);
      else if (E.end(), E.taps === 2 && (R = Ae(R, this), Math.hypot(f[0] - R[0], f[1] - R[1]) < p)) {
        var O = j(this).on("dblclick.zoom");
        O && O.apply(this, arguments);
      }
    }
  }
  return x.wheelDelta = function(y) {
    return arguments.length ? (r = typeof y == "function" ? y : Ze(+y), x) : r;
  }, x.filter = function(y) {
    return arguments.length ? (t4 = typeof y == "function" ? y : Ze(!!y), x) : t4;
  }, x.touchable = function(y) {
    return arguments.length ? (i = typeof y == "function" ? y : Ze(!!y), x) : i;
  }, x.extent = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Ze([[+y[0][0], +y[0][1]], [+y[1][0], +y[1][1]]]), x) : e;
  }, x.scaleExtent = function(y) {
    return arguments.length ? (a[0] = +y[0], a[1] = +y[1], x) : [a[0], a[1]];
  }, x.translateExtent = function(y) {
    return arguments.length ? (o[0][0] = +y[0][0], o[1][0] = +y[1][0], o[0][1] = +y[0][1], o[1][1] = +y[1][1], x) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, x.constrain = function(y) {
    return arguments.length ? (n = y, x) : n;
  }, x.duration = function(y) {
    return arguments.length ? (s = +y, x) : s;
  }, x.interpolate = function(y) {
    return arguments.length ? (l = y, x) : l;
  }, x.on = function() {
    var y = h.on.apply(h, arguments);
    return y === h ? x : y;
  }, x.clickDistance = function(y) {
    return arguments.length ? (g = (y = +y) * y, x) : Math.sqrt(g);
  }, x.tapDistance = function(y) {
    return arguments.length ? (p = +y, x) : p;
  }, x;
}
var eo = 1e-6;
var de = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var t4 = 0, e = arguments.length; e--; )
    t4 += arguments[e] * arguments[e];
  return Math.sqrt(t4);
});
function to() {
  var t4 = new de(9);
  return de != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0), t4[0] = 1, t4[4] = 1, t4[8] = 1, t4;
}
function no(t4, e) {
  var n = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], l = e[6], h = e[7], u = e[8], f = e[9], c = e[10], d = e[11], v = e[12], g = e[13], p = e[14], x = e[15], w = n * s - r * o, b = n * l - i * o, m = n * h - a * o, _ = r * l - i * s, A = r * h - a * s, C = i * h - a * l, k = u * g - f * v, M = u * p - c * v, P = u * x - d * v, I = f * p - c * g, N = f * x - d * g, z = c * x - d * p, y = w * z - b * N + m * I + _ * P - A * M + C * k;
  return y ? (y = 1 / y, t4[0] = (s * z - l * N + h * I) * y, t4[1] = (l * P - o * z - h * M) * y, t4[2] = (o * N - s * P + h * k) * y, t4[3] = (i * N - r * z - a * I) * y, t4[4] = (n * z - i * P + a * M) * y, t4[5] = (r * P - n * N - a * k) * y, t4[6] = (g * C - p * A + x * _) * y, t4[7] = (p * m - v * C - x * b) * y, t4[8] = (v * A - g * m + x * w) * y, t4) : null;
}
function Re() {
  var t4 = new de(16);
  return de != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0), t4[0] = 1, t4[5] = 1, t4[10] = 1, t4[15] = 1, t4;
}
function Tt(t4) {
  return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
}
function Nt(t4, e, n) {
  var r = e[0], i = e[1], a = e[2], o = e[3], s = e[4], l = e[5], h = e[6], u = e[7], f = e[8], c = e[9], d = e[10], v = e[11], g = e[12], p = e[13], x = e[14], w = e[15], b = n[0], m = n[1], _ = n[2], A = n[3];
  return t4[0] = b * r + m * s + _ * f + A * g, t4[1] = b * i + m * l + _ * c + A * p, t4[2] = b * a + m * h + _ * d + A * x, t4[3] = b * o + m * u + _ * v + A * w, b = n[4], m = n[5], _ = n[6], A = n[7], t4[4] = b * r + m * s + _ * f + A * g, t4[5] = b * i + m * l + _ * c + A * p, t4[6] = b * a + m * h + _ * d + A * x, t4[7] = b * o + m * u + _ * v + A * w, b = n[8], m = n[9], _ = n[10], A = n[11], t4[8] = b * r + m * s + _ * f + A * g, t4[9] = b * i + m * l + _ * c + A * p, t4[10] = b * a + m * h + _ * d + A * x, t4[11] = b * o + m * u + _ * v + A * w, b = n[12], m = n[13], _ = n[14], A = n[15], t4[12] = b * r + m * s + _ * f + A * g, t4[13] = b * i + m * l + _ * c + A * p, t4[14] = b * a + m * h + _ * d + A * x, t4[15] = b * o + m * u + _ * v + A * w, t4;
}
function Bn(t4, e, n) {
  var r = n[0], i = n[1], a = n[2], o, s, l, h, u, f, c, d, v, g, p, x;
  return e === t4 ? (t4[12] = e[0] * r + e[4] * i + e[8] * a + e[12], t4[13] = e[1] * r + e[5] * i + e[9] * a + e[13], t4[14] = e[2] * r + e[6] * i + e[10] * a + e[14], t4[15] = e[3] * r + e[7] * i + e[11] * a + e[15]) : (o = e[0], s = e[1], l = e[2], h = e[3], u = e[4], f = e[5], c = e[6], d = e[7], v = e[8], g = e[9], p = e[10], x = e[11], t4[0] = o, t4[1] = s, t4[2] = l, t4[3] = h, t4[4] = u, t4[5] = f, t4[6] = c, t4[7] = d, t4[8] = v, t4[9] = g, t4[10] = p, t4[11] = x, t4[12] = o * r + u * i + v * a + e[12], t4[13] = s * r + f * i + g * a + e[13], t4[14] = l * r + c * i + p * a + e[14], t4[15] = h * r + d * i + x * a + e[15]), t4;
}
function Fn(t4, e, n, r) {
  var i = r[0], a = r[1], o = r[2], s = Math.hypot(i, a, o), l, h, u, f, c, d, v, g, p, x, w, b, m, _, A, C, k, M, P, I, N, z, y, F;
  return s < eo ? null : (s = 1 / s, i *= s, a *= s, o *= s, l = Math.sin(n), h = Math.cos(n), u = 1 - h, f = e[0], c = e[1], d = e[2], v = e[3], g = e[4], p = e[5], x = e[6], w = e[7], b = e[8], m = e[9], _ = e[10], A = e[11], C = i * i * u + h, k = a * i * u + o * l, M = o * i * u - a * l, P = i * a * u - o * l, I = a * a * u + h, N = o * a * u + i * l, z = i * o * u + a * l, y = a * o * u - i * l, F = o * o * u + h, t4[0] = f * C + g * k + b * M, t4[1] = c * C + p * k + m * M, t4[2] = d * C + x * k + _ * M, t4[3] = v * C + w * k + A * M, t4[4] = f * P + g * I + b * N, t4[5] = c * P + p * I + m * N, t4[6] = d * P + x * I + _ * N, t4[7] = v * P + w * I + A * N, t4[8] = f * z + g * y + b * F, t4[9] = c * z + p * y + m * F, t4[10] = d * z + x * y + _ * F, t4[11] = v * z + w * y + A * F, e !== t4 && (t4[12] = e[12], t4[13] = e[13], t4[14] = e[14], t4[15] = e[15]), t4);
}
function ro(t4, e, n, r, i) {
  var a = 1 / Math.tan(e / 2), o;
  return t4[0] = a / n, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = a, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[15] = 0, i != null && i !== 1 / 0 ? (o = 1 / (r - i), t4[10] = (i + r) * o, t4[14] = 2 * i * r * o) : (t4[10] = -1, t4[14] = -2 * r), t4;
}
var io = ro;
function ao(t4, e, n, r, i, a, o) {
  var s = 1 / (e - n), l = 1 / (r - i), h = 1 / (a - o);
  return t4[0] = -2 * s, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = -2 * l, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 2 * h, t4[11] = 0, t4[12] = (e + n) * s, t4[13] = (i + r) * l, t4[14] = (o + a) * h, t4[15] = 1, t4;
}
var so = ao;
function at() {
  var t4 = new de(3);
  return de != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0), t4;
}
(function() {
  var t4 = at();
  return function(e, n, r, i, a, o) {
    var s, l;
    for (n || (n = 3), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, s = r; s < l; s += n)
      t4[0] = e[s], t4[1] = e[s + 1], t4[2] = e[s + 2], a(t4, t4, o), e[s] = t4[0], e[s + 1] = t4[1], e[s + 2] = t4[2];
    return e;
  };
})();
function mr() {
  var t4 = new de(4);
  return de != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 0), t4;
}
function oo(t4, e, n) {
  var r = e[0], i = e[1], a = e[2], o = e[3];
  return t4[0] = n[0] * r + n[4] * i + n[8] * a + n[12] * o, t4[1] = n[1] * r + n[5] * i + n[9] * a + n[13] * o, t4[2] = n[2] * r + n[6] * i + n[10] * a + n[14] * o, t4[3] = n[3] * r + n[7] * i + n[11] * a + n[15] * o, t4;
}
(function() {
  var t4 = mr();
  return function(e, n, r, i, a, o) {
    var s, l;
    for (n || (n = 4), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, s = r; s < l; s += n)
      t4[0] = e[s], t4[1] = e[s + 1], t4[2] = e[s + 2], t4[3] = e[s + 3], a(t4, t4, o), e[s] = t4[0], e[s + 1] = t4[1], e[s + 2] = t4[2], e[s + 3] = t4[3];
    return e;
  };
})();
function lo(t4, e) {
  let n = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], r = null;
  for (let i = 0; i < n.length; ++i) {
    try {
      r = t4.getContext(n[i], e);
    } catch {
    }
    if (r)
      break;
  }
  return r;
}
function Z(t4, e, n) {
  let r;
  return r = t4.createShader(n), t4.shaderSource(r, e), t4.compileShader(r), t4.getShaderParameter(r, t4.COMPILE_STATUS) ? r : (console.log("ERROR with script: ", e), console.log(t4.getShaderInfoLog(r)), null);
}
function Ee(t4, e, n, r, i) {
  let a = i.createProgram();
  if (i.attachShader(a, t4), i.attachShader(a, e), i.linkProgram(a), !i.getProgramParameter(a, i.LINK_STATUS)) {
    alert("Shader Compilation Error." + i.getProgramInfoLog(a));
    return;
  }
  if (this.ID = a, this.uniforms = new Object(), this.attributes = new Object(), n)
    for (let o = 0; o < n.length; o++)
      this.uniforms[n[o]] = i.getUniformLocation(this.ID, n[o]);
  if (this.attributes.enable = function(o) {
    i.enableVertexAttribArray(this[o]);
  }, this.attributes.disable = function(o) {
    i.disableVertexAttribArray(this[o]);
  }, r)
    for (let o = 0; o < r.length; o++)
      this.attributes[r[o]] = i.getAttribLocation(this.ID, r[o]);
  this.use = function(o) {
    o.useProgram(this.ID);
  };
}
function pr(t4, e = true, n = true) {
  let r = [
    -1,
    1,
    0,
    -1,
    -1,
    0,
    1,
    1,
    0,
    1,
    -1,
    0
  ], i = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1
  ], a = [
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0
  ], o = {};
  return n && (o.texCoordObject = t4.createBuffer(), t4.bindBuffer(t4.ARRAY_BUFFER, o.texCoordObject), t4.bufferData(t4.ARRAY_BUFFER, new Float32Array(a), t4.STATIC_DRAW)), e && (o.normalObject = t4.createBuffer(), t4.bindBuffer(t4.ARRAY_BUFFER, o.normalObject), t4.bufferData(t4.ARRAY_BUFFER, new Float32Array(i), t4.STATIC_DRAW)), o.vertexObject = t4.createBuffer(), t4.bindBuffer(t4.ARRAY_BUFFER, o.vertexObject), t4.bufferData(t4.ARRAY_BUFFER, new Float32Array(r), t4.STATIC_DRAW), o.numIndices = 4, o;
}
function Mn(t4) {
  return t4 * Math.PI / 180;
}
var uo = (t4) => {
  let e = t4.split(/\s/);
  return e.length < 2 ? null : [+e[0], +e[1]];
};
var ho = (t4) => {
  let e = t4.split(/\s/);
  return e.length < 3 ? null : [+e[0], +e[1], +e[2]];
};
var fo = (t4) => isNaN(t4) ? 0 : +t4;
var co = /#([ve]) \"(.+)\" ([sn]|v2|v3)/;
var go = {
  s: String,
  n: fo,
  v2: uo,
  v3: ho
};
var vo = (t4) => {
  for (; t4.lineIndex + 1 < t4.lines.length && t4.lines[t4.lineIndex].length == 0; )
    t4.lineIndex++;
  let n = t4.lines[t4.lineIndex].split(/\s/), r = 0;
  if (n.length == 0 || n[0].toLowerCase() != "#vertices" || isNaN(n[1]) || !Number.isInteger(+n[1]))
    throw `Malformed xnet data (Reading Vertices Header)[line: ${t4.lineIndex}]
	> ${t4.lines[t4.lineIndex]}`;
  return r = +n[1], t4.lineIndex++, r;
};
var mo = (t4) => {
  let e = [];
  for (; t4.lineIndex < t4.lines.length; ) {
    let r = t4.lines[t4.lineIndex], i = r.length;
    if (i == 0) {
      t4.lineIndex++;
      continue;
    }
    if (r[0] == "#")
      break;
    var n = r;
    r[0] == '"' && r[i - 1] == '"' && (n = r.slice(1, -1)), e.push(n), t4.lineIndex++;
  }
  return e;
};
var po = (t4) => {
  for (; t4.lineIndex + 1 < t4.lines.length && t4.lines[t4.lineIndex].length == 0; )
    t4.lineIndex++;
  let n = t4.lines[t4.lineIndex].split(/\s/), r = false, i = false;
  if (n.length == 0 || n[0].toLowerCase() != "#edges")
    throw `Malformed xnet data (Reading Edges Header)[line: ${t4.lineIndex}]
	> ${t4.lines[t4.lineIndex]}`;
  return n.forEach((a) => {
    a.toLowerCase() == "weighted" && (r = true), a.toLowerCase() == "nonweighted" && (r = false), a.toLowerCase() == "directed" && (i = true), a.toLowerCase() == "undirected" && (i = false);
  }), t4.lineIndex++, { weighted: r, directed: i };
};
var Ao = (t4) => {
  let e = [], n = [];
  for (; t4.lineIndex < t4.lines.length; ) {
    let r = t4.lines[t4.lineIndex];
    if (r.length == 0) {
      t4.lineIndex++;
      continue;
    }
    if (r[0] == "#")
      break;
    let a = r.split(/\s/), o = 1;
    if (a.length < 2)
      throw `Malformed xnet data (Reading Edges)[line: ${t4.lineIndex}]
	> ${t4.lines[t4.lineIndex]}`;
    a.length > 2 && (o = +a[2]), e.push([+a[0], +a[1]]), n.push(o), t4.lineIndex++;
  }
  return { edges: e, weights: n };
};
var _o = (t4) => {
  for (; t4.lineIndex + 1 < t4.lines.length && t4.lines[t4.lineIndex].length == 0; )
    t4.lineIndex++;
  let e = co.exec(t4.lines[t4.lineIndex]);
  if (e.length != 4)
    throw `Malformed xnet data [line: ${t4.lineIndex}]
	> ${t4.lines[t4.lineIndex]}`;
  let n = e[1], r = e[2], i = e[3];
  return t4.lineIndex++, { type: n, key: r, format: i };
};
var yo = (t4, e) => {
  let n = [], r = go[e.format];
  for (; t4.lineIndex < t4.lines.length; ) {
    let i = t4.lines[t4.lineIndex], a = i.length;
    if (a == 0) {
      t4.lineIndex++;
      continue;
    }
    if (i[0] == "#")
      break;
    let o = i;
    o[0] == '"' && o[a - 1] == '"' && (o = o.slice(1, -1)), n.push(r(o)), t4.lineIndex++;
  }
  return n;
};
var Ar = (t4) => {
  let e = { lineIndex: 0, lines: t4.split(`
`) }, n = vo(e), r = mo(e), i = { nodesCount: n, verticesProperties: {}, edgesProperties: {} };
  if (r.length > 0) {
    if (r.length < n)
      throw `Malformed xnet data [line: ${e.lineIndex}]
	> ${e.lines[e.lineIndex]}`;
    i.labels = r;
  }
  let a = po(e);
  i.directed = a.directed, i.weighted = a.weighted;
  let o = Ao(e);
  i.edges = o.edges, i.weighted && (i.weights = o.weights);
  do {
    for (; e.lineIndex < e.lines.length && e.lines[e.lineIndex].length == 0; )
      e.lineIndex++;
    if (!(e.lineIndex < e.lines.length))
      break;
    let s = _o(e), l = yo(e, s);
    s.type == "e" ? i.edgesProperties[s.key] = l : s.type == "v" && (i.verticesProperties[s.key] = l);
  } while (e.lineIndex < e.lines.length);
  return i;
};
async function xo(t4) {
  let e = await fetch(t4).then((n) => n.text());
  return Ar(e);
}
var Fl = Object.freeze(Object.defineProperty({
  __proto__: null,
  loadXNET: Ar,
  loadXNETFile: xo
}, Symbol.toStringTag, { value: "Module" }));
function qt(t4, e, n, r) {
  if (r <= n)
    return n;
  const i = Math.floor(n + (r - n) / 2), a = e - t4[i].value, o = e - t4[i + 1].value;
  return a < 0 ? qt(t4, e, n, i - 1) : o < 0 ? i : qt(t4, e, i + 1, r);
}
var bo = (t4, e, n) => {
  const r = (t4 - e) / (n - e);
  return [1 - r, r];
};
function wo(t4) {
  return t4.value !== void 0 && t4.mapped !== void 0;
}
function Eo(t4) {
  return t4.length > 0 && wo(t4[0]);
}
function Rn(t4, e, n, r) {
  return [
    t4 * e[0] + n * r[0],
    t4 * e[1] + n * r[1],
    t4 * e[2] + n * r[2]
  ];
}
function Sn(t4) {
  return t4 || bo;
}
function ko(t4, e, n) {
  return !Array.isArray(t4) || t4.length < 1 ? Bo : Eo(t4) ? Co(t4, e, Sn(n), Rn) : Io(t4, e, Sn(n), Rn);
}
function Co(t4, e, n, r) {
  const i = t4.sort((a, o) => a.value < o.value ? -1 : 1);
  return function(a) {
    const o = e(a), s = qt(i, o, 0, i.length - 1);
    if (s == 0 && o < i[0].value)
      return i[s].mapped;
    if (s == i.length - 1)
      return i[s].mapped;
    const [l, h] = n(o, i[s].value, i[s + 1].value);
    return r(l, i[s].mapped, h, i[s + 1].mapped);
  };
}
function Io(t4, e, n, r) {
  return function(i) {
    const a = e(i), o = (t4.length - 1) * a;
    if (o <= 0)
      return t4[0];
    if (o >= t4.length - 1)
      return t4[t4.length - 1];
    const s = Math.floor(o), [l, h] = n(o, s, s + 1);
    return r(l, t4[s], h, t4[s + 1]);
  };
}
function Bo(t4) {
  return [0, 0, 0];
}
function Fo(t4, e) {
  let [n, r] = t4;
  const [i, a] = e;
  return Math.abs(n - r) < Number.EPSILON && (r = n + 1), function(o) {
    return i + (a - i) * ((o - n) / (r - n));
  };
}
var Mo = [
  [1462e-6, 466e-6, 0.013866],
  [2267e-6, 127e-5, 0.01857],
  [3299e-6, 2249e-6, 0.024239],
  [4547e-6, 3392e-6, 0.030909],
  [6006e-6, 4692e-6, 0.038558],
  [7676e-6, 6136e-6, 0.046836],
  [9561e-6, 7713e-6, 0.055143],
  [0.011663, 9417e-6, 0.06346],
  [0.013995, 0.011225, 0.071862],
  [0.016561, 0.013136, 0.080282],
  [0.019373, 0.015133, 0.088767],
  [0.022447, 0.017199, 0.097327],
  [0.025793, 0.019331, 0.10593],
  [0.029432, 0.021503, 0.114621],
  [0.033385, 0.023702, 0.123397],
  [0.037668, 0.025921, 0.132232],
  [0.042253, 0.028139, 0.141141],
  [0.046915, 0.030324, 0.150164],
  [0.051644, 0.032474, 0.159254],
  [0.056449, 0.034569, 0.168414],
  [0.06134, 0.03659, 0.177642],
  [0.066331, 0.038504, 0.186962],
  [0.071429, 0.040294, 0.196354],
  [0.076637, 0.041905, 0.205799],
  [0.081962, 0.043328, 0.215289],
  [0.087411, 0.044556, 0.224813],
  [0.09299, 0.045583, 0.234358],
  [0.098702, 0.046402, 0.243904],
  [0.104551, 0.047008, 0.25343],
  [0.110536, 0.047399, 0.262912],
  [0.116656, 0.047574, 0.272321],
  [0.122908, 0.047536, 0.281624],
  [0.129285, 0.047293, 0.290788],
  [0.135778, 0.046856, 0.299776],
  [0.142378, 0.046242, 0.308553],
  [0.149073, 0.045468, 0.317085],
  [0.15585, 0.044559, 0.325338],
  [0.162689, 0.043554, 0.333277],
  [0.169575, 0.042489, 0.340874],
  [0.176493, 0.041402, 0.348111],
  [0.183429, 0.040329, 0.354971],
  [0.190367, 0.039309, 0.361447],
  [0.197297, 0.0384, 0.367535],
  [0.204209, 0.037632, 0.373238],
  [0.211095, 0.03703, 0.378563],
  [0.217949, 0.036615, 0.383522],
  [0.224763, 0.036405, 0.388129],
  [0.231538, 0.036405, 0.3924],
  [0.238273, 0.036621, 0.396353],
  [0.244967, 0.037055, 0.400007],
  [0.25162, 0.037705, 0.403378],
  [0.258234, 0.038571, 0.406485],
  [0.26481, 0.039647, 0.409345],
  [0.271347, 0.040922, 0.411976],
  [0.27785, 0.042353, 0.414392],
  [0.284321, 0.043933, 0.416608],
  [0.290763, 0.045644, 0.418637],
  [0.297178, 0.04747, 0.420491],
  [0.303568, 0.049396, 0.422182],
  [0.309935, 0.051407, 0.423721],
  [0.316282, 0.05349, 0.425116],
  [0.32261, 0.055634, 0.426377],
  [0.328921, 0.057827, 0.427511],
  [0.335217, 0.06006, 0.428524],
  [0.3415, 0.062325, 0.429425],
  [0.347771, 0.064616, 0.430217],
  [0.354032, 0.066925, 0.430906],
  [0.360284, 0.069247, 0.431497],
  [0.366529, 0.071579, 0.431994],
  [0.372768, 0.073915, 0.4324],
  [0.379001, 0.076253, 0.432719],
  [0.385228, 0.078591, 0.432955],
  [0.391453, 0.080927, 0.433109],
  [0.397674, 0.083257, 0.433183],
  [0.403894, 0.08558, 0.433179],
  [0.410113, 0.087896, 0.433098],
  [0.416331, 0.090203, 0.432943],
  [0.422549, 0.092501, 0.432714],
  [0.428768, 0.09479, 0.432412],
  [0.434987, 0.097069, 0.432039],
  [0.441207, 0.099338, 0.431594],
  [0.447428, 0.101597, 0.43108],
  [0.453651, 0.103848, 0.430498],
  [0.459875, 0.106089, 0.429846],
  [0.4661, 0.108322, 0.429125],
  [0.472328, 0.110547, 0.428334],
  [0.478558, 0.112764, 0.427475],
  [0.484789, 0.114974, 0.426548],
  [0.491022, 0.117179, 0.425552],
  [0.497257, 0.119379, 0.424488],
  [0.503493, 0.121575, 0.423356],
  [0.50973, 0.123769, 0.422156],
  [0.515967, 0.12596, 0.420887],
  [0.522206, 0.12815, 0.419549],
  [0.528444, 0.130341, 0.418142],
  [0.534683, 0.132534, 0.416667],
  [0.54092, 0.134729, 0.415123],
  [0.547157, 0.136929, 0.413511],
  [0.553392, 0.139134, 0.411829],
  [0.559624, 0.141346, 0.410078],
  [0.565854, 0.143567, 0.408258],
  [0.572081, 0.145797, 0.406369],
  [0.578304, 0.148039, 0.404411],
  [0.584521, 0.150294, 0.402385],
  [0.590734, 0.152563, 0.40029],
  [0.59694, 0.154848, 0.398125],
  [0.603139, 0.157151, 0.395891],
  [0.60933, 0.159474, 0.393589],
  [0.615513, 0.161817, 0.391219],
  [0.621685, 0.164184, 0.388781],
  [0.627847, 0.166575, 0.386276],
  [0.633998, 0.168992, 0.383704],
  [0.640135, 0.171438, 0.381065],
  [0.64626, 0.173914, 0.378359],
  [0.652369, 0.176421, 0.375586],
  [0.658463, 0.178962, 0.372748],
  [0.66454, 0.181539, 0.369846],
  [0.670599, 0.184153, 0.366879],
  [0.676638, 0.186807, 0.363849],
  [0.682656, 0.189501, 0.360757],
  [0.688653, 0.192239, 0.357603],
  [0.694627, 0.195021, 0.354388],
  [0.700576, 0.197851, 0.351113],
  [0.7065, 0.200728, 0.347777],
  [0.712396, 0.203656, 0.344383],
  [0.718264, 0.206636, 0.340931],
  [0.724103, 0.20967, 0.337424],
  [0.729909, 0.212759, 0.333861],
  [0.735683, 0.215906, 0.330245],
  [0.741423, 0.219112, 0.326576],
  [0.747127, 0.222378, 0.322856],
  [0.752794, 0.225706, 0.319085],
  [0.758422, 0.229097, 0.315266],
  [0.76401, 0.232554, 0.311399],
  [0.769556, 0.236077, 0.307485],
  [0.775059, 0.239667, 0.303526],
  [0.780517, 0.243327, 0.299523],
  [0.785929, 0.247056, 0.295477],
  [0.791293, 0.250856, 0.29139],
  [0.796607, 0.254728, 0.287264],
  [0.801871, 0.258674, 0.283099],
  [0.807082, 0.262692, 0.278898],
  [0.812239, 0.266786, 0.274661],
  [0.817341, 0.270954, 0.27039],
  [0.822386, 0.275197, 0.266085],
  [0.827372, 0.279517, 0.26175],
  [0.832299, 0.283913, 0.257383],
  [0.837165, 0.288385, 0.252988],
  [0.841969, 0.292933, 0.248564],
  [0.846709, 0.297559, 0.244113],
  [0.851384, 0.30226, 0.239636],
  [0.855992, 0.307038, 0.235133],
  [0.860533, 0.311892, 0.230606],
  [0.865006, 0.316822, 0.226055],
  [0.869409, 0.321827, 0.221482],
  [0.873741, 0.326906, 0.216886],
  [0.878001, 0.33206, 0.212268],
  [0.882188, 0.337287, 0.207628],
  [0.886302, 0.342586, 0.202968],
  [0.890341, 0.347957, 0.198286],
  [0.894305, 0.353399, 0.193584],
  [0.898192, 0.358911, 0.18886],
  [0.902003, 0.364492, 0.184116],
  [0.905735, 0.37014, 0.17935],
  [0.90939, 0.375856, 0.174563],
  [0.912966, 0.381636, 0.169755],
  [0.916462, 0.387481, 0.164924],
  [0.919879, 0.393389, 0.16007],
  [0.923215, 0.399359, 0.155193],
  [0.92647, 0.405389, 0.150292],
  [0.929644, 0.411479, 0.145367],
  [0.932737, 0.417627, 0.140417],
  [0.935747, 0.423831, 0.13544],
  [0.938675, 0.430091, 0.130438],
  [0.941521, 0.436405, 0.125409],
  [0.944285, 0.442772, 0.120354],
  [0.946965, 0.449191, 0.115272],
  [0.949562, 0.45566, 0.110164],
  [0.952075, 0.462178, 0.105031],
  [0.954506, 0.468744, 0.099874],
  [0.956852, 0.475356, 0.094695],
  [0.959114, 0.482014, 0.089499],
  [0.961293, 0.488716, 0.084289],
  [0.963387, 0.495462, 0.079073],
  [0.965397, 0.502249, 0.073859],
  [0.967322, 0.509078, 0.068659],
  [0.969163, 0.515946, 0.063488],
  [0.970919, 0.522853, 0.058367],
  [0.97259, 0.529798, 0.053324],
  [0.974176, 0.53678, 0.048392],
  [0.975677, 0.543798, 0.043618],
  [0.977092, 0.55085, 0.03905],
  [0.978422, 0.557937, 0.034931],
  [0.979666, 0.565057, 0.031409],
  [0.980824, 0.572209, 0.028508],
  [0.981895, 0.579392, 0.02625],
  [0.982881, 0.586606, 0.024661],
  [0.983779, 0.593849, 0.02377],
  [0.984591, 0.601122, 0.023606],
  [0.985315, 0.608422, 0.024202],
  [0.985952, 0.61575, 0.025592],
  [0.986502, 0.623105, 0.027814],
  [0.986964, 0.630485, 0.030908],
  [0.987337, 0.63789, 0.034916],
  [0.987622, 0.64532, 0.039886],
  [0.987819, 0.652773, 0.045581],
  [0.987926, 0.66025, 0.05175],
  [0.987945, 0.667748, 0.058329],
  [0.987874, 0.675267, 0.065257],
  [0.987714, 0.682807, 0.072489],
  [0.987464, 0.690366, 0.07999],
  [0.987124, 0.697944, 0.087731],
  [0.986694, 0.70554, 0.095694],
  [0.986175, 0.713153, 0.103863],
  [0.985566, 0.720782, 0.112229],
  [0.984865, 0.728427, 0.120785],
  [0.984075, 0.736087, 0.129527],
  [0.983196, 0.743758, 0.138453],
  [0.982228, 0.751442, 0.147565],
  [0.981173, 0.759135, 0.156863],
  [0.980032, 0.766837, 0.166353],
  [0.978806, 0.774545, 0.176037],
  [0.977497, 0.782258, 0.185923],
  [0.976108, 0.789974, 0.196018],
  [0.974638, 0.797692, 0.206332],
  [0.973088, 0.805409, 0.216877],
  [0.971468, 0.813122, 0.227658],
  [0.969783, 0.820825, 0.238686],
  [0.968041, 0.828515, 0.249972],
  [0.966243, 0.836191, 0.261534],
  [0.964394, 0.843848, 0.273391],
  [0.962517, 0.851476, 0.285546],
  [0.960626, 0.859069, 0.29801],
  [0.95872, 0.866624, 0.31082],
  [0.956834, 0.874129, 0.323974],
  [0.954997, 0.881569, 0.337475],
  [0.953215, 0.888942, 0.351369],
  [0.951546, 0.896226, 0.365627],
  [0.950018, 0.903409, 0.380271],
  [0.948683, 0.910473, 0.395289],
  [0.947594, 0.917399, 0.410665],
  [0.946809, 0.924168, 0.426373],
  [0.946392, 0.930761, 0.442367],
  [0.946403, 0.937159, 0.458592],
  [0.946903, 0.943348, 0.47497],
  [0.947937, 0.949318, 0.491426],
  [0.949545, 0.955063, 0.50786],
  [0.95174, 0.960587, 0.524203],
  [0.954529, 0.965896, 0.540361],
  [0.957896, 0.971003, 0.556275],
  [0.961812, 0.975924, 0.571925],
  [0.966249, 0.980678, 0.587206],
  [0.971162, 0.985282, 0.602154],
  [0.976511, 0.989753, 0.61676],
  [0.982257, 0.994109, 0.631017],
  [0.988362, 0.998364, 0.644924]
];
var Ro = class {
  constructor(e, n, r, i) {
    for (const [a, o] of Object.entries(e))
      a == "color" || a == "size" || a == "position" || a == "outlineColor" || a == "outlineWidth" || (this[a] = o);
    this._network = i, this.ID = n, this.index = r;
  }
  set color(e) {
    let n = this.index;
    this._network.colors[n * 4 + 0] = e[0], this._network.colors[n * 4 + 1] = e[1], this._network.colors[n * 4 + 2] = e[2], e.length > 3 && (this._network.colors[n * 4 + 3] = e[3]);
  }
  get color() {
    let e = this.index;
    return [this._network.colors[e * 4 + 0], this._network.colors[e * 4 + 1], this._network.colors[e * 4 + 2], this._network.colors[e * 4 + 3]];
  }
  set opacity(e) {
    let n = this.index;
    this._network.colors[n * 4 + 3] = e;
  }
  get opacity() {
    let e = this.index;
    return this._network.colors[e * 4 + 3];
  }
  set size(e) {
    this._network.sizes[this.index] = e;
  }
  get size() {
    return this._network.sizes[this.index];
  }
  set outlineColor(e) {
    let n = this.index;
    this._network.outlineColors[n * 4 + 0] = e[0], this._network.outlineColors[n * 4 + 1] = e[1], this._network.outlineColors[n * 4 + 2] = e[2], e.length > 3 && (this._network.outlineColors[n * 4 + 3] = e[3]);
  }
  get outlineColor() {
    let e = this.index;
    return [this._network.outlineColors[e * 4 + 0], this._network.outlineColors[e * 4 + 1], this._network.outlineColors[e * 4 + 2], this._network.outlineColors[e * 4 + 3]];
  }
  set outlineWidth(e) {
    this._network.outlineWidths[this.index] = e;
  }
  get outlineWidth() {
    return this._network.outlineWidths[this.index];
  }
  get network() {
    return this._network;
  }
  set position(e) {
    let n = this.index;
    this._network.positions[n * 3 + 0] = e[0], this._network.positions[n * 3 + 1] = e[1], this._network.positions[n * 3 + 2] = e[2];
  }
  get position() {
    let e = this.index;
    return [this._network.positions[e * 3 + 0], this._network.positions[e * 3 + 1], this._network.positions[e * 3 + 2]];
  }
};
var So = class {
  constructor(e, n, r) {
    this.ID2index = new Object(), this.index2Node = [];
    for (const [o, s] of Object.entries(e))
      if (!this.ID2index.hasOwnProperty(o)) {
        let l = this.index2Node.length;
        this.ID2index[o] = l, s.index = l, s.ID = o, this.index2Node.push(s), s.neighbors = [], s.edges = [];
      }
    this.indexedEdges = new Int32Array(n.length * 2);
    for (let o = 0; o < n.length; o++) {
      const s = n[o];
      let l = this.ID2index[s.source], h = this.ID2index[s.target];
      this.indexedEdges[o * 2] = l, this.indexedEdges[o * 2 + 1] = h;
    }
    this.positions = new Float32Array(3 * this.index2Node.length), this.colors = new Float32Array(4 * this.index2Node.length), this.sizes = new Float32Array(this.index2Node.length), this.outlineColors = new Float32Array(4 * this.index2Node.length);
    for (let o = 0; o < this.index2Node.length; o++)
      this.colors[o * 4 + 3] = 1, this.outlineColors[o * 4 + 3] = 1;
    this.outlineWidths = new Float32Array(this.index2Node.length), this.edgePositions = null, this.edgeColors = null, this.edgeSizes = null, this.nodes = {};
    let i = Fo([0, this.index2Node.length], [0, 1]), a = ko(Mo, i);
    for (let o = 0; o < this.index2Node.length; o++) {
      let s = this.index2Node[o];
      if (s.hasOwnProperty("position") ? (this.positions[o * 3] = s.position[0], this.positions[o * 3 + 1] = s.position[1], this.positions[o * 3 + 2] = s.position[2]) : (this.positions[o * 3 + 0] = (Math.random() - 0.5) * 2 * 200, this.positions[o * 3 + 1] = (Math.random() - 0.5) * 2 * 200, this.positions[o * 3 + 2] = (Math.random() - 0.5) * 2 * 200), s.hasOwnProperty("color"))
        o == 0 && console.log("NODE COLOR:", s.color), this.colors[o * 4 + 0] = s.color[0], this.colors[o * 4 + 1] = s.color[1], this.colors[o * 4 + 2] = s.color[2], s.color.length > 3 ? this.colors[o * 4 + 3] = s.color[3] : this.colors[o * 4 + 3] = 1;
      else {
        let h = a(o);
        this.colors[o * 4 + 0] = h[0], this.colors[o * 4 + 1] = h[1], this.colors[o * 4 + 2] = h[2], h.length > 3 ? this.colors[o * 4 + 3] = h[3] : this.colors[o * 4 + 3] = 1;
      }
      s.hasOwnProperty("size") ? this.sizes[o] = s.size : this.sizes[o] = 1, s.hasOwnProperty("outlineColor") ? (this.outlineColors[o * 4 + 0] = s.outlineColor[0], this.outlineColors[o * 4 + 1] = s.outlineColor[1], this.outlineColors[o * 4 + 2] = s.outlineColor[2], s.outlineColor.length > 3 ? this.outlineColors[o * 4 + 3] = s.outlineColor[3] : this.outlineColors[o * 4 + 3] = 1) : (this.outlineColors[o * 4 + 0] = 1, this.outlineColors[o * 4 + 1] = 1, this.outlineColors[o * 4 + 2] = 1, this.outlineColors[o * 4 + 3] = 1), s.hasOwnProperty("outlineWidth") ? this.outlineWidths[o] = s.outlineWidth : this.outlineWidths[o] = 0;
      let l = new Ro(s, s.ID, o, this);
      this.index2Node[o] = l, this.nodes[s.ID] = l;
    }
    for (let o = 0; o < n.length; o++) {
      const s = n[o];
      let l = this.ID2index[s.source], h = this.ID2index[s.target], u = this.index2Node[l], f = this.index2Node[h];
      u.neighbors.push(f), f.neighbors.push(u), u.edges.push(o), f.edges.push(o);
    }
  }
  get nodeCount() {
    return this.index2Node.length;
  }
  updateEdgePositions() {
    this.edgePositions == null && (this.edgePositions = new Float32Array(3 * this.indexedEdges.length));
    const e = this.indexedEdges.length, n = this.positions, r = this.edgePositions, i = this.indexedEdges;
    for (let a = 0; a < e / 2; a++) {
      const o = i[a * 2] * 3, s = i[a * 2 + 1] * 3, l = a * 6, h = l + 3;
      r[l] = n[o], r[l + 1] = n[o + 1], r[l + 2] = n[o + 2], r[h] = n[s], r[h + 1] = n[s + 1], r[h + 2] = n[s + 2];
    }
  }
  updateEdgeColors(e = true) {
    this.edgeColors == null && (this.edgeColors = new Float32Array(4 * this.indexedEdges.length));
    const n = this.indexedEdges.length, r = this.edgeColors, i = this.colors, a = this.indexedEdges;
    for (let o = 0; o < n / 2; o++) {
      const s = a[o * 2] * 4, l = a[o * 2 + 1] * 4, h = o * 8, u = h + 4;
      r[h] = i[s], r[h + 1] = i[s + 1], r[h + 2] = i[s + 2], r[u] = i[l], r[u + 1] = i[l + 1], r[u + 2] = i[l + 2], e && (r[h + 3] = i[s + 3], r[u + 3] = i[l + 3]);
    }
  }
  updateEdgeSizes() {
    this.edgeSizes == null && (this.edgeSizes = new Float32Array(this.indexedEdges.length));
    const e = this.indexedEdges.length, n = this.edgeSizes, r = this.sizes, i = this.indexedEdges;
    for (let a = 0; a < e / 2; a++) {
      const o = i[a * 2], s = i[a * 2 + 1];
      n[a * 2] = r[o], n[a * 2 + 1] = r[s];
    }
  }
  updateEdgeOpacity(e) {
    this.edgeColors == null && (this.edgeColors = new Float32Array(4 * this.indexedEdges.length));
    const n = this.indexedEdges.length, r = this.edgeColors, i = this.colors, a = this.indexedEdges;
    for (let o = 0; o < n / 2; o++) {
      const s = a[o * 2] * 4, l = a[o * 2 + 1] * 4;
      r[o * 8 + 3] = i[s + 3], r[o * 8 + 7] = i[l + 3];
    }
  }
};
var To = class {
  constructor(e, { FPS: n = 120, throttle: r = true, maxQueueLength: i = 10 }) {
    this.helios = e, this.needsRender = false, this.needsUpdateNodesGeometry = false, this.needsUpdateEdgesGeometry = false, this._FPS = n, this._throttle = r, this._maxQueueLength = i, this._started = false, this._paused = true, this._lastFPS = 0, this._averageFPS = 0, this._tasks = {}, this._executionCount = 0, this._lastTimestamp = null, this._currentTimestamp = null, this._lastExecutionTimestamp = null, this._lastRequestFrameID = 0, this._timeout = null, this._times = [], this._lastRepeatInterval = 0, this._shouldCleanup = false;
  }
  FPS(e) {
    return e === void 0 ? this.FPS : (this.FPS = e, this);
  }
  schedule({
    name: e = "default",
    callback: n = null,
    delay: r = 0,
    repeat: i = false,
    maxRepeatCount: a = 1 / 0,
    maxRepeatTime: o = 1 / 0,
    repeatInterval: s = 0,
    synchronized: l = true,
    immediateUpdates: h = false,
    updateNodesGeometry: u = false,
    updateEdgesGeometry: f = false,
    afterRedraw: c = false,
    redraw: d = true,
    replace: v = true
  }) {
    let g = {
      name: e,
      callback: n,
      delay: r,
      repeat: i,
      maxRepeatCount: a,
      maxRepeatTime: o,
      repeatInterval: s,
      synchronized: l,
      immediateUpdates: h,
      updateNodesGeometry: u,
      updateEdgesGeometry: f,
      afterRedraw: c,
      redraw: d,
      replace: v,
      executionCount: 0,
      lastTimestamp: window.performance.now(),
      lastExecutionTime: 0,
      shouldBeRemoved: false,
      cancel: function() {
        this.shouldBeRemoved = true, this.synchronized || clearTimeout(this._timeout);
      }
    };
    return e in this._tasks || (this._tasks[e] = []), v && this._clearTask(e), l || this.runAsyncTask(g, g.delay), this._addTaskToQueue(g, e), this._paused && this._started && this._updateTimeout(), this;
  }
  runAsyncTask(e, n = 0) {
    this._executionCount += 1, e.timeout = setTimeout(() => {
      var _a2;
      if (e.shouldBeRemoved)
        return;
      let r = window.performance.now(), i = r - e.lastTimestamp;
      if ((_a2 = e.callback) == null ? void 0 : _a2.call(e, i, e), e.executionCount += 1, e.immediateUpdates ? this._updateHelios(e.needsRender, e.needsUpdateNodesGeometry, e.needsUpdateEdgesGeometry) : (e.redraw && (this.needsRender = true), e.updateNodesGeometry && (this.needsUpdateNodesGeometry = true), e.updateEdgesGeometry && (this.needsUpdateEdgesGeometry = true)), e.repeat) {
        let a = window.performance.now();
        e.lastExecutionTime = a - r, e.lastTimestamp = r;
        let o = e.repeatInterval - (a - r);
        o < 0 && (o = 0), e.executionCount >= e.maxRepeatCount ? e.shouldBeRemoved = true : this.runAsyncTask(e, o);
      } else
        e.shouldBeRemoved = true;
      this._started && this._paused && this._updateTimeout();
    }, n);
  }
  _executeTask(e, n, r) {
    var _a2;
    if ((_a2 = e.callback) == null ? void 0 : _a2.call(e, n, e), e === void 0)
      return false;
    if (e.executionCount += 1, e.repeat && e.executionCount < e.maxRepeatCount) {
      let i = window.performance.now();
      e.lastExecutionTime = i - r, e.lastTimestamp = r;
    } else
      e.shouldBeRemoved = true;
    return true;
  }
  runSyncTasks() {
    var _a2, _b;
    if (this._shouldCleanup)
      return;
    this._executionCount += 1;
    let e = [], n = window.performance.now();
    for (let r of Object.keys(this._tasks).sort()) {
      let i = this._tasks[r];
      for (let a = 0; a < i.length; a++) {
        if ((i[a].synchronized || !i[a].immediateUpdates) && (i[a].redraw && (this.needsRender = true), i[a].updateNodesGeometry && (this.needsUpdateNodesGeometry = true), i[a].updateEdgesGeometry && (this.needsUpdateEdgesGeometry = true)), !((_a2 = i[a]) == null ? void 0 : _a2.shouldBeRemoved)) {
          let o = window.performance.now(), s = o - i[a].lastTimestamp + i[a].lastExecutionTime;
          s < 0 && (s = 0);
          let l = false;
          if (i[a].executionCount == 0 ? s >= i[a].delay && (l = true) : s >= i[a].repeatInterval && (l = true), l) {
            if (i[a].afterRedraw)
              e.push({
                task: i[a],
                elapsedTime: s,
                currentTimestamp: o
              });
            else if (!this._executeTask(i[a], s, o))
              break;
          }
        }
        ((_b = i[a]) == null ? void 0 : _b.shouldBeRemoved) && (i.splice(a, 1), a--);
      }
      i.length == 0 && delete this._tasks[r];
    }
    this._updateHelios(this.needsRender, this.needsUpdateNodesGeometry, this.needsUpdateEdgesGeometry, true, e), this._lastTimestamp = n;
  }
  _updateHelios(e, n, r, i, a) {
    e === void 0 && (e = this.needsRender), n === void 0 && (n = this.needsUpdateNodesGeometry), r === void 0 && (r = this.needsUpdateEdgesGeometry), n && (this.helios.updateNodesGeometry(), this.needsUpdateNodesGeometry = false), r && (this.helios.updateEdgesGeometry(), this.needsUpdateEdgesGeometry = false), cancelAnimationFrame(this.lastRequestFrameID), this.lastRequestFrameID = requestAnimationFrame(() => {
      if (this._shouldCleanup)
        return;
      const o = window.performance.now();
      for (; this._times.length > 0 && this._times[0] <= o - 1e3; )
        this._times.shift();
      this._times.push(o), this._averageFPS = this._times.length, e && (this.helios.redraw(), this.needsRender = false), ((a == null ? void 0 : a.length) || 0) > 0 && a.forEach((s) => {
        s.task._timeout = setTimeout(() => {
          this._executeTask(s.task, s.elapsedTime, s.currentTimestamp);
        }, 0);
      }), i && (this._lastExecutionTimestamp = window.performance.now(), this._updateTimeout());
    });
  }
  _addTaskToQueue(e, n) {
    let r = this._tasks[n];
    r.push(e), r.length > this._maxQueueLength && (r[0].timeout && (r[0].shouldBeRemoved = true, clearTimeout(e.taskQueue[0])), r.shift(), console.warn(`One task was discarded because of too many tasks in the ${n} queue. (maxQueueLength = ${this._maxQueueLength})`));
  }
  _clearTask(e) {
    if (e in this._tasks) {
      let n = this._tasks[e];
      for (let r = 0; r < n.length; r++) {
        let i = n[r];
        i.timeout && (i.shouldBeRemoved = true, clearTimeout(i.timeout));
      }
      n.length = 0;
    }
  }
  unschedule(e) {
    return e in this._tasks && (this._clearTask(e), delete this._tasks[e]), this._updateTimeout(), this;
  }
  hasTask(e) {
    return e in this._tasks;
  }
  start() {
    return this._started = true, this._updateTimeout(), this;
  }
  stop() {
    return this._shouldCleanup = true, clearTimeout(this._timeout), this.paused = false, this.started = false, this._lastTimestamp = null, this._lastExecutionTime = 0, this;
  }
  _updateTimeout() {
    if (clearTimeout(this._timeout), this._started)
      if (Object.keys(this._tasks).length === 0)
        this.paused = true;
      else {
        this.paused = false;
        let e = 0, n = window.performance.now();
        this._lastTimestamp != null && this._throttle && (e = 1e3 / this._FPS - (n - this._lastTimestamp), e < 0 && (e = 0)), this._lastFPS = 1e3 / (n - this._lastTimestamp), this._timeout = setTimeout(() => {
          this.runSyncTasks();
        }, e);
      }
  }
};
function Ke(t4) {
  throw new Error('Could not dynamically require "' + t4 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Xt = {};
var No = {
  get exports() {
    return Xt;
  },
  set exports(t4) {
    Xt = t4;
  }
};
(function(t4, e) {
  (function(n) {
    t4.exports = n();
  })(function() {
    return function() {
      function n(r, i, a) {
        function o(h, u) {
          if (!i[h]) {
            if (!r[h]) {
              var f = typeof Ke == "function" && Ke;
              if (!u && f)
                return f(h, true);
              if (s)
                return s(h, true);
              var c = new Error("Cannot find module '" + h + "'");
              throw c.code = "MODULE_NOT_FOUND", c;
            }
            var d = i[h] = { exports: {} };
            r[h][0].call(d.exports, function(v) {
              var g = r[h][1][v];
              return o(g || v);
            }, d, d.exports, n, r, i, a);
          }
          return i[h].exports;
        }
        for (var s = typeof Ke == "function" && Ke, l = 0; l < a.length; l++)
          o(a[l]);
        return o;
      }
      return n;
    }()({ 1: [function(n, r, i) {
      var a = n("multimath"), o = n("./mm_unsharp_mask"), s = n("./mm_resize");
      function l(h) {
        var u = h || [], f = {
          js: u.indexOf("js") >= 0,
          wasm: u.indexOf("wasm") >= 0
        };
        a.call(this, f), this.features = {
          js: f.js,
          wasm: f.wasm && this.has_wasm()
        }, this.use(o), this.use(s);
      }
      l.prototype = Object.create(a.prototype), l.prototype.constructor = l, l.prototype.resizeAndUnsharp = function(u, f) {
        var c = this.resize(u, f);
        return u.unsharpAmount && this.unsharp_mask(c, u.toWidth, u.toHeight, u.unsharpAmount, u.unsharpRadius, u.unsharpThreshold), c;
      }, r.exports = l;
    }, { "./mm_resize": 4, "./mm_unsharp_mask": 9, multimath: 19 }], 2: [function(n, r, i) {
      function a(f) {
        return f < 0 ? 0 : f > 255 ? 255 : f;
      }
      function o(f) {
        return f >= 0 ? f : 0;
      }
      function s(f, c, d, v, g, p) {
        var x, w, b, m, _, A, C, k, M, P, I, N = 0, z = 0;
        for (M = 0; M < v; M++) {
          for (_ = 0, P = 0; P < g; P++) {
            for (A = p[_++], C = p[_++], k = N + A * 4 | 0, x = w = b = m = 0; C > 0; C--)
              I = p[_++], m = m + I * f[k + 3] | 0, b = b + I * f[k + 2] | 0, w = w + I * f[k + 1] | 0, x = x + I * f[k] | 0, k = k + 4 | 0;
            c[z + 3] = o(m >> 7), c[z + 2] = o(b >> 7), c[z + 1] = o(w >> 7), c[z] = o(x >> 7), z = z + v * 4 | 0;
          }
          z = (M + 1) * 4 | 0, N = (M + 1) * d * 4 | 0;
        }
      }
      function l(f, c, d, v, g, p) {
        var x, w, b, m, _, A, C, k, M, P, I, N = 0, z = 0;
        for (M = 0; M < v; M++) {
          for (_ = 0, P = 0; P < g; P++) {
            for (A = p[_++], C = p[_++], k = N + A * 4 | 0, x = w = b = m = 0; C > 0; C--)
              I = p[_++], m = m + I * f[k + 3] | 0, b = b + I * f[k + 2] | 0, w = w + I * f[k + 1] | 0, x = x + I * f[k] | 0, k = k + 4 | 0;
            x >>= 7, w >>= 7, b >>= 7, m >>= 7, c[z + 3] = a(m + (1 << 13) >> 14), c[z + 2] = a(b + (1 << 13) >> 14), c[z + 1] = a(w + (1 << 13) >> 14), c[z] = a(x + (1 << 13) >> 14), z = z + v * 4 | 0;
          }
          z = (M + 1) * 4 | 0, N = (M + 1) * d * 4 | 0;
        }
      }
      function h(f, c, d, v, g, p) {
        var x, w, b, m, _, A, C, k, M, P, I, N, z = 0, y = 0;
        for (P = 0; P < v; P++) {
          for (A = 0, I = 0; I < g; I++) {
            for (C = p[A++], k = p[A++], M = z + C * 4 | 0, x = w = b = m = 0; k > 0; k--)
              N = p[A++], _ = f[M + 3], m = m + N * _ | 0, b = b + N * f[M + 2] * _ | 0, w = w + N * f[M + 1] * _ | 0, x = x + N * f[M] * _ | 0, M = M + 4 | 0;
            b = b / 255 | 0, w = w / 255 | 0, x = x / 255 | 0, c[y + 3] = o(m >> 7), c[y + 2] = o(b >> 7), c[y + 1] = o(w >> 7), c[y] = o(x >> 7), y = y + v * 4 | 0;
          }
          y = (P + 1) * 4 | 0, z = (P + 1) * d * 4 | 0;
        }
      }
      function u(f, c, d, v, g, p) {
        var x, w, b, m, _, A, C, k, M, P, I, N = 0, z = 0;
        for (M = 0; M < v; M++) {
          for (_ = 0, P = 0; P < g; P++) {
            for (A = p[_++], C = p[_++], k = N + A * 4 | 0, x = w = b = m = 0; C > 0; C--)
              I = p[_++], m = m + I * f[k + 3] | 0, b = b + I * f[k + 2] | 0, w = w + I * f[k + 1] | 0, x = x + I * f[k] | 0, k = k + 4 | 0;
            x >>= 7, w >>= 7, b >>= 7, m >>= 7, m = a(m + (1 << 13) >> 14), m > 0 && (x = x * 255 / m | 0, w = w * 255 / m | 0, b = b * 255 / m | 0), c[z + 3] = m, c[z + 2] = a(b + (1 << 13) >> 14), c[z + 1] = a(w + (1 << 13) >> 14), c[z] = a(x + (1 << 13) >> 14), z = z + v * 4 | 0;
          }
          z = (M + 1) * 4 | 0, N = (M + 1) * d * 4 | 0;
        }
      }
      r.exports = {
        convolveHor: s,
        convolveVert: l,
        convolveHorWithPre: h,
        convolveVertWithPre: u
      };
    }, {}], 3: [function(n, r, i) {
      r.exports = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEYA2AGf39/f39/AGAAAGAIf39/f39/f38AAg8BA2VudgZtZW1vcnkCAAADBwYBAAAAAAIGBgF/AEEACweUAQgRX193YXNtX2NhbGxfY3RvcnMAAAtjb252b2x2ZUhvcgABDGNvbnZvbHZlVmVydAACEmNvbnZvbHZlSG9yV2l0aFByZQADE2NvbnZvbHZlVmVydFdpdGhQcmUABApjb252b2x2ZUhWAAUMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAKyA4GAwABC4wDARB/AkAgA0UNACAERQ0AIANBAnQhFQNAQQAhE0EAIQsDQCALQQJqIQcCfyALQQF0IAVqIgYuAQIiC0UEQEEAIQhBACEGQQAhCUEAIQogBwwBCyASIAYuAQBqIQhBACEJQQAhCiALIRRBACEOIAchBkEAIQ8DQCAFIAZBAXRqLgEAIhAgACAIQQJ0aigCACIRQRh2bCAPaiEPIBFB/wFxIBBsIAlqIQkgEUEQdkH/AXEgEGwgDmohDiARQQh2Qf8BcSAQbCAKaiEKIAhBAWohCCAGQQFqIQYgFEEBayIUDQALIAlBB3UhCCAKQQd1IQYgDkEHdSEJIA9BB3UhCiAHIAtqCyELIAEgDEEBdCIHaiAIQQAgCEEAShs7AQAgASAHQQJyaiAGQQAgBkEAShs7AQAgASAHQQRyaiAJQQAgCUEAShs7AQAgASAHQQZyaiAKQQAgCkEAShs7AQAgDCAVaiEMIBNBAWoiEyAERw0ACyANQQFqIg0gAmwhEiANQQJ0IQwgAyANRw0ACwsL2gMBD38CQCADRQ0AIARFDQAgAkECdCEUA0AgCyEMQQAhE0EAIQIDQCACQQJqIQYCfyACQQF0IAVqIgcuAQIiAkUEQEEAIQhBACEHQQAhCkEAIQkgBgwBCyAHLgEAQQJ0IBJqIQhBACEJIAIhCkEAIQ0gBiEHQQAhDkEAIQ8DQCAFIAdBAXRqLgEAIhAgACAIQQF0IhFqLwEAbCAJaiEJIAAgEUEGcmovAQAgEGwgDmohDiAAIBFBBHJqLwEAIBBsIA9qIQ8gACARQQJyai8BACAQbCANaiENIAhBBGohCCAHQQFqIQcgCkEBayIKDQALIAlBB3UhCCANQQd1IQcgDkEHdSEKIA9BB3UhCSACIAZqCyECIAEgDEECdGogB0GAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQQh0QYD+A3EgCUGAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQRB0QYCA/AdxIApBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG3I2AgAgAyAMaiEMIBNBAWoiEyAERw0ACyAUIAtBAWoiC2whEiADIAtHDQALCwuSAwEQfwJAIANFDQAgBEUNACADQQJ0IRUDQEEAIRNBACEGA0AgBkECaiEIAn8gBkEBdCAFaiIGLgECIgdFBEBBACEJQQAhDEEAIQ1BACEOIAgMAQsgEiAGLgEAaiEJQQAhDkEAIQ1BACEMIAchFEEAIQ8gCCEGA0AgBSAGQQF0ai4BACAAIAlBAnRqKAIAIhBBGHZsIhEgD2ohDyARIBBBEHZB/wFxbCAMaiEMIBEgEEEIdkH/AXFsIA1qIQ0gESAQQf8BcWwgDmohDiAJQQFqIQkgBkEBaiEGIBRBAWsiFA0ACyAPQQd1IQkgByAIagshBiABIApBAXQiCGogDkH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEECcmogDUH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEEcmogDEH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEGcmogCUEAIAlBAEobOwEAIAogFWohCiATQQFqIhMgBEcNAAsgC0EBaiILIAJsIRIgC0ECdCEKIAMgC0cNAAsLC4IEAQ9/AkAgA0UNACAERQ0AIAJBAnQhFANAIAshDEEAIRJBACEHA0AgB0ECaiEKAn8gB0EBdCAFaiICLgECIhNFBEBBACEIQQAhCUEAIQYgCiEHQQAMAQsgAi4BAEECdCARaiEJQQAhByATIQJBACENIAohBkEAIQ5BACEPA0AgBSAGQQF0ai4BACIIIAAgCUEBdCIQai8BAGwgB2ohByAAIBBBBnJqLwEAIAhsIA5qIQ4gACAQQQRyai8BACAIbCAPaiEPIAAgEEECcmovAQAgCGwgDWohDSAJQQRqIQkgBkEBaiEGIAJBAWsiAg0ACyAHQQd1IQggDUEHdSEJIA9BB3UhBiAKIBNqIQcgDkEHdQtBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKGyIKQf8BcQRAIAlB/wFsIAJtIQkgCEH/AWwgAm0hCCAGQf8BbCACbSEGCyABIAxBAnRqIAlBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EIdEGA/gNxIAZBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EQdEGAgPwHcSAKQRh0ciAIQYBAa0EOdSICQf8BIAJB/wFIGyICQQAgAkEAShtycjYCACADIAxqIQwgEkEBaiISIARHDQALIBQgC0EBaiILbCERIAMgC0cNAAsLC0AAIAcEQEEAIAIgAyAEIAUgABADIAJBACAEIAUgBiABEAQPC0EAIAIgAyAEIAUgABABIAJBACAEIAUgBiABEAIL";
    }, {}], 4: [function(n, r, i) {
      r.exports = {
        name: "resize",
        fn: n("./resize"),
        wasm_fn: n("./resize_wasm"),
        wasm_src: n("./convolve_wasm_base64")
      };
    }, { "./convolve_wasm_base64": 3, "./resize": 5, "./resize_wasm": 8 }], 5: [function(n, r, i) {
      var a = n("./resize_filter_gen"), o = n("./convolve"), s = o.convolveHor, l = o.convolveVert, h = o.convolveHorWithPre, u = o.convolveVertWithPre;
      function f(d, v, g) {
        for (var p = 3, x = v * g * 4 | 0; p < x; ) {
          if (d[p] !== 255)
            return true;
          p = p + 4 | 0;
        }
        return false;
      }
      function c(d, v, g) {
        for (var p = 3, x = v * g * 4 | 0; p < x; )
          d[p] = 255, p = p + 4 | 0;
      }
      r.exports = function(v) {
        var g = v.src, p = v.width, x = v.height, w = v.toWidth, b = v.toHeight, m = v.scaleX || v.toWidth / v.width, _ = v.scaleY || v.toHeight / v.height, A = v.offsetX || 0, C = v.offsetY || 0, k = v.dest || new Uint8Array(w * b * 4), M = typeof v.filter > "u" ? "mks2013" : v.filter, P = a(M, p, w, m, A), I = a(M, x, b, _, C), N = new Uint16Array(w * x * 4);
        return f(g, p, x) ? (h(g, N, p, x, w, P), u(N, k, x, w, b, I)) : (s(g, N, p, x, w, P), l(N, k, x, w, b, I), c(k, w, b)), k;
      };
    }, { "./convolve": 2, "./resize_filter_gen": 6 }], 6: [function(n, r, i) {
      var a = n("./resize_filter_info"), o = 14;
      function s(l) {
        return Math.round(l * ((1 << o) - 1));
      }
      r.exports = function(h, u, f, c, d) {
        var v = a.filter[h].fn, g = 1 / c, p = Math.min(1, c), x = a.filter[h].win / p, w, b, m, _, A, C, k, M, P, I, N, z, y, F, E, S, B, T = Math.floor((x + 1) * 2), R = new Int16Array((T + 2) * f), O = 0, D = !R.subarray || !R.set;
        for (w = 0; w < f; w++) {
          for (b = (w + 0.5) * g + d, m = Math.max(0, Math.floor(b - x)), _ = Math.min(u - 1, Math.ceil(b + x)), A = _ - m + 1, C = new Float32Array(A), k = new Int16Array(A), M = 0, P = m, I = 0; P <= _; P++, I++)
            N = v((P + 0.5 - b) * p), M += N, C[I] = N;
          for (z = 0, I = 0; I < C.length; I++)
            y = C[I] / M, z += y, k[I] = s(y);
          for (k[f >> 1] += s(1 - z), F = 0; F < k.length && k[F] === 0; )
            F++;
          if (F < k.length) {
            for (E = k.length - 1; E > 0 && k[E] === 0; )
              E--;
            if (S = m + F, B = E - F + 1, R[O++] = S, R[O++] = B, !D)
              R.set(k.subarray(F, E + 1), O), O += B;
            else
              for (I = F; I <= E; I++)
                R[O++] = k[I];
          } else
            R[O++] = 0, R[O++] = 0;
        }
        return R;
      };
    }, { "./resize_filter_info": 7 }], 7: [function(n, r, i) {
      var a = {
        // Nearest neibor
        box: {
          win: 0.5,
          fn: function(s) {
            return s < 0 && (s = -s), s < 0.5 ? 1 : 0;
          }
        },
        // // Hamming
        hamming: {
          win: 1,
          fn: function(s) {
            if (s < 0 && (s = -s), s >= 1)
              return 0;
            if (s < 11920929e-14)
              return 1;
            var l = s * Math.PI;
            return Math.sin(l) / l * (0.54 + 0.46 * Math.cos(l / 1));
          }
        },
        // Lanczos, win = 2
        lanczos2: {
          win: 2,
          fn: function(s) {
            if (s < 0 && (s = -s), s >= 2)
              return 0;
            if (s < 11920929e-14)
              return 1;
            var l = s * Math.PI;
            return Math.sin(l) / l * Math.sin(l / 2) / (l / 2);
          }
        },
        // Lanczos, win = 3
        lanczos3: {
          win: 3,
          fn: function(s) {
            if (s < 0 && (s = -s), s >= 3)
              return 0;
            if (s < 11920929e-14)
              return 1;
            var l = s * Math.PI;
            return Math.sin(l) / l * Math.sin(l / 3) / (l / 3);
          }
        },
        // Magic Kernel Sharp 2013, win = 2.5
        // http://johncostella.com/magic/
        mks2013: {
          win: 2.5,
          fn: function(s) {
            return s < 0 && (s = -s), s >= 2.5 ? 0 : s >= 1.5 ? -0.125 * (s - 2.5) * (s - 2.5) : s >= 0.5 ? 0.25 * (4 * s * s - 11 * s + 7) : 1.0625 - 1.75 * s * s;
          }
        }
      };
      r.exports = {
        filter: a,
        // Legacy mapping
        f2q: {
          box: 0,
          hamming: 1,
          lanczos2: 2,
          lanczos3: 3
        },
        q2f: ["box", "hamming", "lanczos2", "lanczos3"]
      };
    }, {}], 8: [function(n, r, i) {
      var a = n("./resize_filter_gen");
      function o(f, c, d) {
        for (var v = 3, g = c * d * 4 | 0; v < g; ) {
          if (f[v] !== 255)
            return true;
          v = v + 4 | 0;
        }
        return false;
      }
      function s(f, c, d) {
        for (var v = 3, g = c * d * 4 | 0; v < g; )
          f[v] = 255, v = v + 4 | 0;
      }
      function l(f) {
        return new Uint8Array(f.buffer, 0, f.byteLength);
      }
      var h = true;
      try {
        h = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
      } catch {
      }
      function u(f, c, d) {
        if (h) {
          c.set(l(f), d);
          return;
        }
        for (var v = d, g = 0; g < f.length; g++) {
          var p = f[g];
          c[v++] = p & 255, c[v++] = p >> 8 & 255;
        }
      }
      r.exports = function(c) {
        var d = c.src, v = c.width, g = c.height, p = c.toWidth, x = c.toHeight, w = c.scaleX || c.toWidth / c.width, b = c.scaleY || c.toHeight / c.height, m = c.offsetX || 0, _ = c.offsetY || 0, A = c.dest || new Uint8Array(p * x * 4), C = typeof c.filter > "u" ? "mks2013" : c.filter, k = a(C, v, p, w, m), M = a(C, g, x, b, _), P = 0, I = Math.max(d.byteLength, A.byteLength), N = this.__align(P + I), z = g * p * 4 * 2, y = this.__align(N + z), F = this.__align(y + k.byteLength), E = F + M.byteLength, S = this.__instance("resize", E), B = new Uint8Array(this.__memory.buffer), T = new Uint32Array(this.__memory.buffer), R = new Uint32Array(d.buffer);
        T.set(R), u(k, B, y), u(M, B, F);
        var O = S.exports.convolveHV || S.exports._convolveHV;
        o(d, v, g) ? O(y, F, N, v, g, p, x, 1) : (O(y, F, N, v, g, p, x, 0), s(A, p, x));
        var D = new Uint32Array(A.buffer);
        return D.set(new Uint32Array(this.__memory.buffer, 0, x * p)), A;
      };
    }, { "./resize_filter_gen": 6 }], 9: [function(n, r, i) {
      r.exports = {
        name: "unsharp_mask",
        fn: n("./unsharp_mask"),
        wasm_fn: n("./unsharp_mask_wasm"),
        wasm_src: n("./unsharp_mask_wasm_base64")
      };
    }, { "./unsharp_mask": 10, "./unsharp_mask_wasm": 11, "./unsharp_mask_wasm_base64": 12 }], 10: [function(n, r, i) {
      var a = n("glur/mono16");
      function o(s, l, h) {
        for (var u = l * h, f = new Uint16Array(u), c, d, v, g, p = 0; p < u; p++)
          c = s[4 * p], d = s[4 * p + 1], v = s[4 * p + 2], g = c >= d && c >= v ? c : d >= v && d >= c ? d : v, f[p] = g << 8;
        return f;
      }
      r.exports = function(l, h, u, f, c, d) {
        var v, g, p, x, w;
        if (!(f === 0 || c < 0.5)) {
          c > 2 && (c = 2);
          var b = o(l, h, u), m = new Uint16Array(b);
          a(m, h, u, c);
          for (var _ = f / 100 * 4096 + 0.5 | 0, A = d << 8, C = h * u, k = 0; k < C; k++)
            v = b[k], x = v - m[k], Math.abs(x) >= A && (g = v + (_ * x + 2048 >> 12), g = g > 65280 ? 65280 : g, g = g < 0 ? 0 : g, v = v !== 0 ? v : 1, p = (g << 12) / v | 0, w = k * 4, l[w] = l[w] * p + 2048 >> 12, l[w + 1] = l[w + 1] * p + 2048 >> 12, l[w + 2] = l[w + 2] * p + 2048 >> 12);
        }
      };
    }, { "glur/mono16": 18 }], 11: [function(n, r, i) {
      r.exports = function(o, s, l, h, u, f) {
        if (!(h === 0 || u < 0.5)) {
          u > 2 && (u = 2);
          var c = s * l, d = c * 4, v = c * 2, g = c * 2, p = Math.max(s, l) * 4, x = 8 * 4, w = 0, b = d, m = b + v, _ = m + g, A = _ + g, C = A + p, k = this.__instance("unsharp_mask", d + v + g * 2 + p + x, {
            exp: Math.exp
          }), M = new Uint32Array(o.buffer), P = new Uint32Array(this.__memory.buffer);
          P.set(M);
          var I = k.exports.hsv_v16 || k.exports._hsv_v16;
          I(w, b, s, l), I = k.exports.blurMono16 || k.exports._blurMono16, I(b, m, _, A, C, s, l, u), I = k.exports.unsharp || k.exports._unsharp, I(w, w, b, m, s, l, h, f), M.set(new Uint32Array(this.__memory.buffer, 0, c));
        }
      };
    }, {}], 12: [function(n, r, i) {
      r.exports = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAE0B2AAAGAEf39/fwBgBn9/f39/fwBgCH9/f39/f39/AGAIf39/f39/f30AYAJ9fwBgAXwBfAIZAgNlbnYDZXhwAAYDZW52Bm1lbW9yeQIAAAMHBgAFAgQBAwYGAX8AQQALB4oBCBFfX3dhc21fY2FsbF9jdG9ycwABFl9fYnVpbGRfZ2F1c3NpYW5fY29lZnMAAg5fX2dhdXNzMTZfbGluZQADCmJsdXJNb25vMTYABAdoc3ZfdjE2AAUHdW5zaGFycAAGDF9fZHNvX2hhbmRsZQMAGF9fd2FzbV9hcHBseV9kYXRhX3JlbG9jcwABCsUMBgMAAQvWAQEHfCABRNuGukOCGvs/IAC7oyICRAAAAAAAAADAohAAIgW2jDgCFCABIAKaEAAiAyADoCIGtjgCECABRAAAAAAAAPA/IAOhIgQgBKIgAyACIAKgokQAAAAAAADwP6AgBaGjIgS2OAIAIAEgBSAEmqIiB7Y4AgwgASADIAJEAAAAAAAA8D+gIASioiIItjgCCCABIAMgAkQAAAAAAADwv6AgBKKiIgK2OAIEIAEgByAIoCAFRAAAAAAAAPA/IAahoCIDo7Y4AhwgASAEIAKgIAOjtjgCGAuGBQMGfwl8An0gAyoCDCEVIAMqAgghFiADKgIUuyERIAMqAhC7IRACQCAEQQFrIghBAEgiCQRAIAIhByAAIQYMAQsgAiAALwEAuCIPIAMqAhi7oiIMIBGiIg0gDCAQoiAPIAMqAgS7IhOiIhQgAyoCALsiEiAPoqCgoCIOtjgCACACQQRqIQcgAEECaiEGIAhFDQAgCEEBIAhBAUgbIgpBf3MhCwJ/IAQgCmtBAXFFBEAgDiENIAgMAQsgAiANIA4gEKIgFCASIAAvAQK4Ig+ioKCgIg22OAIEIAJBCGohByAAQQRqIQYgDiEMIARBAmsLIQIgC0EAIARrRg0AA0AgByAMIBGiIA0gEKIgDyAToiASIAYvAQC4Ig6ioKCgIgy2OAIAIAcgDSARoiAMIBCiIA4gE6IgEiAGLwECuCIPoqCgoCINtjgCBCAHQQhqIQcgBkEEaiEGIAJBAkohACACQQJrIQIgAA0ACwsCQCAJDQAgASAFIAhsQQF0aiIAAn8gBkECay8BACICuCINIBW7IhKiIA0gFrsiE6KgIA0gAyoCHLuiIgwgEKKgIAwgEaKgIg8gB0EEayIHKgIAu6AiDkQAAAAAAADwQWMgDkQAAAAAAAAAAGZxBEAgDqsMAQtBAAs7AQAgCEUNACAGQQRrIQZBACAFa0EBdCEBA0ACfyANIBKiIAJB//8DcbgiDSAToqAgDyIOIBCioCAMIBGioCIPIAdBBGsiByoCALugIgxEAAAAAAAA8EFjIAxEAAAAAAAAAABmcQRAIAyrDAELQQALIQMgBi8BACECIAAgAWoiACADOwEAIAZBAmshBiAIQQFKIQMgDiEMIAhBAWshCCADDQALCwvRAgIBfwd8AkAgB0MAAAAAWw0AIARE24a6Q4Ia+z8gB0MAAAA/l7ujIglEAAAAAAAAAMCiEAAiDLaMOAIUIAQgCZoQACIKIAqgIg22OAIQIAREAAAAAAAA8D8gCqEiCyALoiAKIAkgCaCiRAAAAAAAAPA/oCAMoaMiC7Y4AgAgBCAMIAuaoiIOtjgCDCAEIAogCUQAAAAAAADwP6AgC6KiIg+2OAIIIAQgCiAJRAAAAAAAAPC/oCALoqIiCbY4AgQgBCAOIA+gIAxEAAAAAAAA8D8gDaGgIgqjtjgCHCAEIAsgCaAgCqO2OAIYIAYEQANAIAAgBSAIbEEBdGogAiAIQQF0aiADIAQgBSAGEAMgCEEBaiIIIAZHDQALCyAFRQ0AQQAhCANAIAIgBiAIbEEBdGogASAIQQF0aiADIAQgBiAFEAMgCEEBaiIIIAVHDQALCwtxAQN/IAIgA2wiBQRAA0AgASAAKAIAIgRBEHZB/wFxIgIgAiAEQQh2Qf8BcSIDIAMgBEH/AXEiBEkbIAIgA0sbIgYgBiAEIAIgBEsbIAMgBEsbQQh0OwEAIAFBAmohASAAQQRqIQAgBUEBayIFDQALCwuZAgIDfwF8IAQgBWwhBAJ/IAazQwAAgEWUQwAAyEKVu0QAAAAAAADgP6AiC5lEAAAAAAAA4EFjBEAgC6oMAQtBgICAgHgLIQUgBARAIAdBCHQhCUEAIQYDQCAJIAIgBkEBdCIHai8BACIBIAMgB2ovAQBrIgcgB0EfdSIIaiAIc00EQCAAIAZBAnQiCGoiCiAFIAdsQYAQakEMdSABaiIHQYD+AyAHQYD+A0gbIgdBACAHQQBKG0EMdCABQQEgARtuIgEgCi0AAGxBgBBqQQx2OgAAIAAgCEEBcmoiByABIActAABsQYAQakEMdjoAACAAIAhBAnJqIgcgASAHLQAAbEGAEGpBDHY6AAALIAZBAWoiBiAERw0ACwsL";
    }, {}], 13: [function(n, r, i) {
      var a = 100;
      function o(s, l) {
        this.create = s, this.available = [], this.acquired = {}, this.lastId = 1, this.timeoutId = 0, this.idle = l || 2e3;
      }
      o.prototype.acquire = function() {
        var s = this, l;
        return this.available.length !== 0 ? l = this.available.pop() : (l = this.create(), l.id = this.lastId++, l.release = function() {
          return s.release(l);
        }), this.acquired[l.id] = l, l;
      }, o.prototype.release = function(s) {
        var l = this;
        delete this.acquired[s.id], s.lastUsed = Date.now(), this.available.push(s), this.timeoutId === 0 && (this.timeoutId = setTimeout(function() {
          return l.gc();
        }, a));
      }, o.prototype.gc = function() {
        var s = this, l = Date.now();
        this.available = this.available.filter(function(h) {
          return l - h.lastUsed > s.idle ? (h.destroy(), false) : true;
        }), this.available.length !== 0 ? this.timeoutId = setTimeout(function() {
          return s.gc();
        }, a) : this.timeoutId = 0;
      }, r.exports = o;
    }, {}], 14: [function(n, r, i) {
      var a = 2;
      r.exports = function(s, l, h, u, f, c) {
        var d = h / s, v = u / l, g = (2 * c + a + 1) / f;
        if (g > 0.5)
          return [[h, u]];
        var p = Math.ceil(Math.log(Math.min(d, v)) / Math.log(g));
        if (p <= 1)
          return [[h, u]];
        for (var x = [], w = 0; w < p; w++) {
          var b = Math.round(Math.pow(Math.pow(s, p - w - 1) * Math.pow(h, w + 1), 1 / p)), m = Math.round(Math.pow(Math.pow(l, p - w - 1) * Math.pow(u, w + 1), 1 / p));
          x.push([b, m]);
        }
        return x;
      };
    }, {}], 15: [function(n, r, i) {
      var a = 1e-5;
      function o(l) {
        var h = Math.round(l);
        return Math.abs(l - h) < a ? h : Math.floor(l);
      }
      function s(l) {
        var h = Math.round(l);
        return Math.abs(l - h) < a ? h : Math.ceil(l);
      }
      r.exports = function(h) {
        var u = h.toWidth / h.width, f = h.toHeight / h.height, c = o(h.srcTileSize * u) - 2 * h.destTileBorder, d = o(h.srcTileSize * f) - 2 * h.destTileBorder;
        if (c < 1 || d < 1)
          throw new Error("Internal error in pica: target tile width/height is too small.");
        var v, g, p, x, w, b, m = [], _;
        for (x = 0; x < h.toHeight; x += d)
          for (p = 0; p < h.toWidth; p += c)
            v = p - h.destTileBorder, v < 0 && (v = 0), w = p + c + h.destTileBorder - v, v + w >= h.toWidth && (w = h.toWidth - v), g = x - h.destTileBorder, g < 0 && (g = 0), b = x + d + h.destTileBorder - g, g + b >= h.toHeight && (b = h.toHeight - g), _ = {
              toX: v,
              toY: g,
              toWidth: w,
              toHeight: b,
              toInnerX: p,
              toInnerY: x,
              toInnerWidth: c,
              toInnerHeight: d,
              offsetX: v / u - o(v / u),
              offsetY: g / f - o(g / f),
              scaleX: u,
              scaleY: f,
              x: o(v / u),
              y: o(g / f),
              width: s(w / u),
              height: s(b / f)
            }, m.push(_);
        return m;
      };
    }, {}], 16: [function(n, r, i) {
      function a(o) {
        return Object.prototype.toString.call(o);
      }
      r.exports.isCanvas = function(s) {
        var l = a(s);
        return l === "[object HTMLCanvasElement]" || l === "[object OffscreenCanvas]" || l === "[object Canvas]";
      }, r.exports.isImage = function(s) {
        return a(s) === "[object HTMLImageElement]";
      }, r.exports.isImageBitmap = function(s) {
        return a(s) === "[object ImageBitmap]";
      }, r.exports.limiter = function(s) {
        var l = 0, h = [];
        function u() {
          l < s && h.length && (l++, h.shift()());
        }
        return function(c) {
          return new Promise(function(d, v) {
            h.push(function() {
              c().then(function(g) {
                d(g), l--, u();
              }, function(g) {
                v(g), l--, u();
              });
            }), u();
          });
        };
      }, r.exports.cib_quality_name = function(s) {
        switch (s) {
          case 0:
            return "pixelated";
          case 1:
            return "low";
          case 2:
            return "medium";
        }
        return "high";
      }, r.exports.cib_support = function(s) {
        return Promise.resolve().then(function() {
          if (typeof createImageBitmap > "u")
            return false;
          var l = s(100, 100);
          return createImageBitmap(l, 0, 0, 100, 100, {
            resizeWidth: 10,
            resizeHeight: 10,
            resizeQuality: "high"
          }).then(function(h) {
            var u = h.width === 10;
            return h.close(), l = null, u;
          });
        }).catch(function() {
          return false;
        });
      }, r.exports.worker_offscreen_canvas_support = function() {
        return new Promise(function(s, l) {
          if (typeof OffscreenCanvas > "u") {
            s(false);
            return;
          }
          function h(c) {
            if (typeof createImageBitmap > "u") {
              c.postMessage(false);
              return;
            }
            Promise.resolve().then(function() {
              var d = new OffscreenCanvas(10, 10), v = d.getContext("2d");
              return v.rect(0, 0, 1, 1), createImageBitmap(d, 0, 0, 1, 1);
            }).then(function() {
              return c.postMessage(true);
            }, function() {
              return c.postMessage(false);
            });
          }
          var u = btoa("(".concat(h.toString(), ")(self);")), f = new Worker("data:text/javascript;base64,".concat(u));
          f.onmessage = function(c) {
            return s(c.data);
          }, f.onerror = l;
        }).then(function(s) {
          return s;
        }, function() {
          return false;
        });
      }, r.exports.can_use_canvas = function(s) {
        var l = false;
        try {
          var h = s(2, 1), u = h.getContext("2d"), f = u.createImageData(2, 1);
          f.data[0] = 12, f.data[1] = 23, f.data[2] = 34, f.data[3] = 255, f.data[4] = 45, f.data[5] = 56, f.data[6] = 67, f.data[7] = 255, u.putImageData(f, 0, 0), f = null, f = u.getImageData(0, 0, 2, 1), f.data[0] === 12 && f.data[1] === 23 && f.data[2] === 34 && f.data[3] === 255 && f.data[4] === 45 && f.data[5] === 56 && f.data[6] === 67 && f.data[7] === 255 && (l = true);
        } catch {
        }
        return l;
      }, r.exports.cib_can_use_region = function() {
        return new Promise(function(s) {
          if (typeof Image > "u" || typeof createImageBitmap > "u") {
            s(false);
            return;
          }
          var l = new Image();
          l.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z", l.onload = function() {
            createImageBitmap(l, 0, 0, l.width, l.height).then(function(h) {
              h.width === l.width && h.height === l.height ? s(true) : s(false);
            }, function() {
              return s(false);
            });
          }, l.onerror = function() {
            return s(false);
          };
        });
      };
    }, {}], 17: [function(n, r, i) {
      r.exports = function() {
        var a = n("./mathlib"), o;
        onmessage = function(l) {
          var h = l.data.opts;
          if (!h.src && h.srcBitmap) {
            var u = new OffscreenCanvas(h.width, h.height), f = u.getContext("2d");
            f.drawImage(h.srcBitmap, 0, 0), h.src = f.getImageData(0, 0, h.width, h.height).data, u.width = u.height = 0, u = null, h.srcBitmap.close(), h.srcBitmap = null;
          }
          o || (o = new a(l.data.features));
          var c = o.resizeAndUnsharp(h);
          postMessage({
            data: c
          }, [c.buffer]);
        };
      };
    }, { "./mathlib": 1 }], 18: [function(n, r, i) {
      var a, o, s, l, h, u, f, c;
      function d(p) {
        p < 0.5 && (p = 0.5);
        var x = Math.exp(0.726 * 0.726) / p, w = Math.exp(-x), b = Math.exp(-2 * x), m = (1 - w) * (1 - w) / (1 + 2 * x * w - b);
        return a = m, o = m * (x - 1) * w, s = m * (x + 1) * w, l = -m * b, h = 2 * w, u = -b, f = (a + o) / (1 - h - u), c = (s + l) / (1 - h - u), new Float32Array([a, o, s, l, h, u, f, c]);
      }
      function v(p, x, w, b, m, _) {
        var A, C, k, M, P, I, N, z, y, F, E, S, B, T;
        for (y = 0; y < _; y++) {
          for (I = y * m, N = y, z = 0, A = p[I], P = A * b[6], M = P, E = b[0], S = b[1], B = b[4], T = b[5], F = 0; F < m; F++)
            C = p[I], k = C * E + A * S + M * B + P * T, P = M, M = k, A = C, w[z] = M, z++, I++;
          for (I--, z--, N += _ * (m - 1), A = p[I], P = A * b[7], M = P, C = A, E = b[2], S = b[3], F = m - 1; F >= 0; F--)
            k = C * E + A * S + M * B + P * T, P = M, M = k, A = C, C = p[I], x[N] = w[z] + M, I--, z--, N -= _;
        }
      }
      function g(p, x, w, b) {
        if (b) {
          var m = new Uint16Array(p.length), _ = new Float32Array(Math.max(x, w)), A = d(b);
          v(p, m, _, A, x, w), v(m, p, _, A, w, x);
        }
      }
      r.exports = g;
    }, {}], 19: [function(n, r, i) {
      var a = n("object-assign"), o = n("./lib/base64decode"), s = n("./lib/wa_detect"), l = {
        js: true,
        wasm: true
      };
      function h(u) {
        if (!(this instanceof h))
          return new h(u);
        var f = a({}, l, u || {});
        if (this.options = f, this.__cache = {}, this.__init_promise = null, this.__modules = f.modules || {}, this.__memory = null, this.__wasm = {}, this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1, !this.options.js && !this.options.wasm)
          throw new Error('mathlib: at least "js" or "wasm" should be enabled');
      }
      h.prototype.has_wasm = s, h.prototype.use = function(u) {
        return this.__modules[u.name] = u, this.options.wasm && this.has_wasm() && u.wasm_fn ? this[u.name] = u.wasm_fn : this[u.name] = u.fn, this;
      }, h.prototype.init = function() {
        if (this.__init_promise)
          return this.__init_promise;
        if (!this.options.js && this.options.wasm && !this.has_wasm())
          return Promise.reject(new Error(`mathlib: only "wasm" was enabled, but it's not supported`));
        var u = this;
        return this.__init_promise = Promise.all(Object.keys(u.__modules).map(function(f) {
          var c = u.__modules[f];
          return !u.options.wasm || !u.has_wasm() || !c.wasm_fn || u.__wasm[f] ? null : WebAssembly.compile(u.__base64decode(c.wasm_src)).then(function(d) {
            u.__wasm[f] = d;
          });
        })).then(function() {
          return u;
        }), this.__init_promise;
      }, h.prototype.__base64decode = o, h.prototype.__reallocate = function(f) {
        if (!this.__memory)
          return this.__memory = new WebAssembly.Memory({
            initial: Math.ceil(f / (64 * 1024))
          }), this.__memory;
        var c = this.__memory.buffer.byteLength;
        return c < f && this.__memory.grow(Math.ceil((f - c) / (64 * 1024))), this.__memory;
      }, h.prototype.__instance = function(f, c, d) {
        if (c && this.__reallocate(c), !this.__wasm[f]) {
          var v = this.__modules[f];
          this.__wasm[f] = new WebAssembly.Module(this.__base64decode(v.wasm_src));
        }
        if (!this.__cache[f]) {
          var g = {
            memoryBase: 0,
            memory: this.__memory,
            tableBase: 0,
            table: new WebAssembly.Table({ initial: 0, element: "anyfunc" })
          };
          this.__cache[f] = new WebAssembly.Instance(this.__wasm[f], {
            env: a(g, d || {})
          });
        }
        return this.__cache[f];
      }, h.prototype.__align = function(f, c) {
        c = c || 8;
        var d = f % c;
        return f + (d ? c - d : 0);
      }, r.exports = h;
    }, { "./lib/base64decode": 20, "./lib/wa_detect": 21, "object-assign": 22 }], 20: [function(n, r, i) {
      var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      r.exports = function(s) {
        for (var l = s.replace(/[\r\n=]/g, ""), h = l.length, u = new Uint8Array(h * 3 >> 2), f = 0, c = 0, d = 0; d < h; d++)
          d % 4 === 0 && d && (u[c++] = f >> 16 & 255, u[c++] = f >> 8 & 255, u[c++] = f & 255), f = f << 6 | a.indexOf(l.charAt(d));
        var v = h % 4 * 6;
        return v === 0 ? (u[c++] = f >> 16 & 255, u[c++] = f >> 8 & 255, u[c++] = f & 255) : v === 18 ? (u[c++] = f >> 10 & 255, u[c++] = f >> 2 & 255) : v === 12 && (u[c++] = f >> 4 & 255), u;
      };
    }, {}], 21: [function(n, r, i) {
      var a;
      r.exports = function() {
        if (typeof a < "u" || (a = false, typeof WebAssembly > "u"))
          return a;
        try {
          var s = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]), l = new WebAssembly.Module(s), h = new WebAssembly.Instance(l, {});
          return h.exports.test(4) !== 0 && (a = true), a;
        } catch {
        }
        return a;
      };
    }, {}], 22: [function(n, r, i) {
      var a = Object.getOwnPropertySymbols, o = Object.prototype.hasOwnProperty, s = Object.prototype.propertyIsEnumerable;
      function l(u) {
        if (u == null)
          throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(u);
      }
      function h() {
        try {
          if (!Object.assign)
            return false;
          var u = new String("abc");
          if (u[5] = "de", Object.getOwnPropertyNames(u)[0] === "5")
            return false;
          for (var f = {}, c = 0; c < 10; c++)
            f["_" + String.fromCharCode(c)] = c;
          var d = Object.getOwnPropertyNames(f).map(function(g) {
            return f[g];
          });
          if (d.join("") !== "0123456789")
            return false;
          var v = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(g) {
            v[g] = g;
          }), Object.keys(Object.assign({}, v)).join("") === "abcdefghijklmnopqrst";
        } catch {
          return false;
        }
      }
      r.exports = h() ? Object.assign : function(u, f) {
        for (var c, d = l(u), v, g = 1; g < arguments.length; g++) {
          c = Object(arguments[g]);
          for (var p in c)
            o.call(c, p) && (d[p] = c[p]);
          if (a) {
            v = a(c);
            for (var x = 0; x < v.length; x++)
              s.call(c, v[x]) && (d[v[x]] = c[v[x]]);
          }
        }
        return d;
      };
    }, {}], 23: [function(n, r, i) {
      var a = arguments[3], o = arguments[4], s = arguments[5], l = JSON.stringify;
      r.exports = function(h, u) {
        for (var f, c = Object.keys(s), d = 0, v = c.length; d < v; d++) {
          var g = c[d], p = s[g].exports;
          if (p === h || p && p.default === h) {
            f = g;
            break;
          }
        }
        if (!f) {
          f = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
          for (var x = {}, d = 0, v = c.length; d < v; d++) {
            var g = c[d];
            x[g] = g;
          }
          o[f] = [
            "function(require,module,exports){" + h + "(self); }",
            x
          ];
        }
        var w = Math.floor(Math.pow(16, 8) * Math.random()).toString(16), b = {};
        b[f] = f, o[w] = [
          "function(require,module,exports){var f = require(" + l(f) + ");(f.default ? f.default : f)(self);}",
          b
        ];
        var m = {};
        _(w);
        function _(I) {
          m[I] = true;
          for (var N in o[I][1]) {
            var z = o[I][1][N];
            m[z] || _(z);
          }
        }
        var A = "(" + a + ")({" + Object.keys(m).map(function(I) {
          return l(I) + ":[" + o[I][0] + "," + l(o[I][1]) + "]";
        }).join(",") + "},{},[" + l(w) + "])", C = window.URL || window.webkitURL || window.mozURL || window.msURL, k = new Blob([A], { type: "text/javascript" });
        if (u && u.bare)
          return k;
        var M = C.createObjectURL(k), P = new Worker(M);
        return P.objectURL = M, P;
      };
    }, {}], "/index.js": [function(n, r, i) {
      function a(E, S) {
        return u(E) || h(E, S) || s(E, S) || o();
      }
      function o() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      function s(E, S) {
        if (E) {
          if (typeof E == "string")
            return l(E, S);
          var B = Object.prototype.toString.call(E).slice(8, -1);
          if (B === "Object" && E.constructor && (B = E.constructor.name), B === "Map" || B === "Set")
            return Array.from(E);
          if (B === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B))
            return l(E, S);
        }
      }
      function l(E, S) {
        (S == null || S > E.length) && (S = E.length);
        for (var B = 0, T = new Array(S); B < S; B++)
          T[B] = E[B];
        return T;
      }
      function h(E, S) {
        var B = E == null ? null : typeof Symbol < "u" && E[Symbol.iterator] || E["@@iterator"];
        if (B != null) {
          var T = [], R = true, O = false, D, L;
          try {
            for (B = B.call(E); !(R = (D = B.next()).done) && (T.push(D.value), !(S && T.length === S)); R = true)
              ;
          } catch (U) {
            O = true, L = U;
          } finally {
            try {
              !R && B.return != null && B.return();
            } finally {
              if (O)
                throw L;
            }
          }
          return T;
        }
      }
      function u(E) {
        if (Array.isArray(E))
          return E;
      }
      var f = n("object-assign"), c = n("webworkify"), d = n("./lib/mathlib"), v = n("./lib/pool"), g = n("./lib/utils"), p = n("./lib/worker"), x = n("./lib/stepper"), w = n("./lib/tiler"), b = n("./lib/mm_resize/resize_filter_info"), m = {}, _ = false;
      try {
        typeof navigator < "u" && navigator.userAgent && (_ = navigator.userAgent.indexOf("Safari") >= 0);
      } catch {
      }
      var A = 1;
      typeof navigator < "u" && (A = Math.min(navigator.hardwareConcurrency || 1, 4));
      var C = {
        tile: 1024,
        concurrency: A,
        features: ["js", "wasm", "ww"],
        idle: 2e3,
        createCanvas: function(S, B) {
          var T = document.createElement("canvas");
          return T.width = S, T.height = B, T;
        }
      }, k = {
        filter: "mks2013",
        unsharpAmount: 0,
        unsharpRadius: 0,
        unsharpThreshold: 0
      }, M = false, P = false, I = false, N = false, z = false;
      function y() {
        return {
          value: c(p),
          destroy: function() {
            if (this.value.terminate(), typeof window < "u") {
              var S = window.URL || window.webkitURL || window.mozURL || window.msURL;
              S && S.revokeObjectURL && this.value.objectURL && S.revokeObjectURL(this.value.objectURL);
            }
          }
        };
      }
      function F(E) {
        if (!(this instanceof F))
          return new F(E);
        this.options = f({}, C, E || {});
        var S = "lk_".concat(this.options.concurrency);
        this.__limit = m[S] || g.limiter(this.options.concurrency), m[S] || (m[S] = this.__limit), this.features = {
          js: false,
          // pure JS implementation, can be disabled for testing
          wasm: false,
          // webassembly implementation for heavy functions
          cib: false,
          // resize via createImageBitmap (only FF at this moment)
          ww: false
          // webworkers
        }, this.__workersPool = null, this.__requested_features = [], this.__mathlib = null;
      }
      F.prototype.init = function() {
        var E = this;
        if (this.__initPromise)
          return this.__initPromise;
        if (typeof ImageData < "u" && typeof Uint8ClampedArray < "u")
          try {
            new ImageData(new Uint8ClampedArray(400), 10, 10), M = true;
          } catch {
          }
        typeof ImageBitmap < "u" && (ImageBitmap.prototype && ImageBitmap.prototype.close ? P = true : this.debug("ImageBitmap does not support .close(), disabled"));
        var S = this.options.features.slice();
        if (S.indexOf("all") >= 0 && (S = ["cib", "wasm", "js", "ww"]), this.__requested_features = S, this.__mathlib = new d(S), S.indexOf("ww") >= 0 && typeof window < "u" && "Worker" in window)
          try {
            var B = n("webworkify")(function() {
            });
            B.terminate(), this.features.ww = true;
            var T = "wp_".concat(JSON.stringify(this.options));
            m[T] ? this.__workersPool = m[T] : (this.__workersPool = new v(y, this.options.idle), m[T] = this.__workersPool);
          } catch {
          }
        var R = this.__mathlib.init().then(function(U) {
          f(E.features, U.features);
        }), O;
        P ? O = g.cib_support(this.options.createCanvas).then(function(U) {
          if (E.features.cib && S.indexOf("cib") < 0) {
            E.debug("createImageBitmap() resize supported, but disabled by config");
            return;
          }
          S.indexOf("cib") >= 0 && (E.features.cib = U);
        }) : O = Promise.resolve(false), I = g.can_use_canvas(this.options.createCanvas);
        var D;
        P && M && S.indexOf("ww") !== -1 ? D = g.worker_offscreen_canvas_support() : D = Promise.resolve(false), D = D.then(function(U) {
          N = U;
        });
        var L = g.cib_can_use_region().then(function(U) {
          z = U;
        });
        return this.__initPromise = Promise.all([R, O, D, L]).then(function() {
          return E;
        }), this.__initPromise;
      }, F.prototype.__invokeResize = function(E, S) {
        var B = this;
        return S.__mathCache = S.__mathCache || {}, Promise.resolve().then(function() {
          return B.features.ww ? new Promise(function(T, R) {
            var O = B.__workersPool.acquire();
            S.cancelToken && S.cancelToken.catch(function(L) {
              return R(L);
            }), O.value.onmessage = function(L) {
              O.release(), L.data.err ? R(L.data.err) : T(L.data);
            };
            var D = [];
            E.src && D.push(E.src.buffer), E.srcBitmap && D.push(E.srcBitmap), O.value.postMessage({
              opts: E,
              features: B.__requested_features,
              preload: {
                wasm_nodule: B.__mathlib.__
              }
            }, D);
          }) : {
            data: B.__mathlib.resizeAndUnsharp(E, S.__mathCache)
          };
        });
      }, F.prototype.__extractTileData = function(E, S, B, T, R) {
        if (this.features.ww && N && // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,
        // can use canvas because canvas doesn't have orientation;
        // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671
        (g.isCanvas(S) || z))
          return this.debug("Create tile for OffscreenCanvas"), createImageBitmap(T.srcImageBitmap || S, E.x, E.y, E.width, E.height).then(function(L) {
            return R.srcBitmap = L, R;
          });
        if (g.isCanvas(S))
          return T.srcCtx || (T.srcCtx = S.getContext("2d")), this.debug("Get tile pixel data"), R.src = T.srcCtx.getImageData(E.x, E.y, E.width, E.height).data, R;
        this.debug("Draw tile imageBitmap/image to temporary canvas");
        var O = this.options.createCanvas(E.width, E.height), D = O.getContext("2d");
        return D.globalCompositeOperation = "copy", D.drawImage(T.srcImageBitmap || S, E.x, E.y, E.width, E.height, 0, 0, E.width, E.height), this.debug("Get tile pixel data"), R.src = D.getImageData(0, 0, E.width, E.height).data, O.width = O.height = 0, R;
      }, F.prototype.__landTileData = function(E, S, B) {
        var T;
        if (this.debug("Convert raw rgba tile result to ImageData"), S.bitmap)
          return B.toCtx.drawImage(S.bitmap, E.toX, E.toY), null;
        if (M)
          T = new ImageData(new Uint8ClampedArray(S.data), E.toWidth, E.toHeight);
        else if (T = B.toCtx.createImageData(E.toWidth, E.toHeight), T.data.set)
          T.data.set(S.data);
        else
          for (var R = T.data.length - 1; R >= 0; R--)
            T.data[R] = S.data[R];
        return this.debug("Draw tile"), _ ? B.toCtx.putImageData(T, E.toX, E.toY, E.toInnerX - E.toX, E.toInnerY - E.toY, E.toInnerWidth + 1e-5, E.toInnerHeight + 1e-5) : B.toCtx.putImageData(T, E.toX, E.toY, E.toInnerX - E.toX, E.toInnerY - E.toY, E.toInnerWidth, E.toInnerHeight), null;
      }, F.prototype.__tileAndResize = function(E, S, B) {
        var T = this, R = {
          srcCtx: null,
          srcImageBitmap: null,
          isImageBitmapReused: false,
          toCtx: null
        }, O = function(L) {
          return T.__limit(function() {
            if (B.canceled)
              return B.cancelToken;
            var U = {
              width: L.width,
              height: L.height,
              toWidth: L.toWidth,
              toHeight: L.toHeight,
              scaleX: L.scaleX,
              scaleY: L.scaleY,
              offsetX: L.offsetX,
              offsetY: L.offsetY,
              filter: B.filter,
              unsharpAmount: B.unsharpAmount,
              unsharpRadius: B.unsharpRadius,
              unsharpThreshold: B.unsharpThreshold
            };
            return T.debug("Invoke resize math"), Promise.resolve(U).then(function(Q) {
              return T.__extractTileData(L, E, B, R, Q);
            }).then(function(Q) {
              return T.debug("Invoke resize math"), T.__invokeResize(Q, B);
            }).then(function(Q) {
              return B.canceled ? B.cancelToken : (R.srcImageData = null, T.__landTileData(L, Q, R));
            });
          });
        };
        return Promise.resolve().then(function() {
          if (R.toCtx = S.getContext("2d"), g.isCanvas(E))
            return null;
          if (g.isImageBitmap(E))
            return R.srcImageBitmap = E, R.isImageBitmapReused = true, null;
          if (g.isImage(E))
            return P ? (T.debug("Decode image via createImageBitmap"), createImageBitmap(E).then(function(D) {
              R.srcImageBitmap = D;
            }).catch(function(D) {
              return null;
            })) : null;
          throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
        }).then(function() {
          if (B.canceled)
            return B.cancelToken;
          T.debug("Calculate tiles");
          var D = w({
            width: B.width,
            height: B.height,
            srcTileSize: T.options.tile,
            toWidth: B.toWidth,
            toHeight: B.toHeight,
            destTileBorder: B.__destTileBorder
          }), L = D.map(function(Q) {
            return O(Q);
          });
          function U(Q) {
            Q.srcImageBitmap && (Q.isImageBitmapReused || Q.srcImageBitmap.close(), Q.srcImageBitmap = null);
          }
          return T.debug("Process tiles"), Promise.all(L).then(function() {
            return T.debug("Finished!"), U(R), S;
          }, function(Q) {
            throw U(R), Q;
          });
        });
      }, F.prototype.__processStages = function(E, S, B, T) {
        var R = this;
        if (T.canceled)
          return T.cancelToken;
        var O = E.shift(), D = a(O, 2), L = D[0], U = D[1], Q = E.length === 0, G;
        Q || b.q2f.indexOf(T.filter) < 0 ? G = T.filter : T.filter === "box" ? G = "box" : G = "hamming", T = f({}, T, {
          toWidth: L,
          toHeight: U,
          filter: G
        });
        var V;
        return Q || (V = this.options.createCanvas(L, U)), this.__tileAndResize(S, Q ? B : V, T).then(function() {
          return Q ? B : (T.width = L, T.height = U, R.__processStages(E, V, B, T));
        }).then(function(W) {
          return V && (V.width = V.height = 0), W;
        });
      }, F.prototype.__resizeViaCreateImageBitmap = function(E, S, B) {
        var T = this, R = S.getContext("2d");
        return this.debug("Resize via createImageBitmap()"), createImageBitmap(E, {
          resizeWidth: B.toWidth,
          resizeHeight: B.toHeight,
          resizeQuality: g.cib_quality_name(b.f2q[B.filter])
        }).then(function(O) {
          if (B.canceled)
            return B.cancelToken;
          if (!B.unsharpAmount)
            return R.drawImage(O, 0, 0), O.close(), R = null, T.debug("Finished!"), S;
          T.debug("Unsharp result");
          var D = T.options.createCanvas(B.toWidth, B.toHeight), L = D.getContext("2d");
          L.drawImage(O, 0, 0), O.close();
          var U = L.getImageData(0, 0, B.toWidth, B.toHeight);
          return T.__mathlib.unsharp_mask(U.data, B.toWidth, B.toHeight, B.unsharpAmount, B.unsharpRadius, B.unsharpThreshold), R.putImageData(U, 0, 0), D.width = D.height = 0, U = L = D = R = null, T.debug("Finished!"), S;
        });
      }, F.prototype.resize = function(E, S, B) {
        var T = this;
        this.debug("Start resize...");
        var R = f({}, k);
        if (isNaN(B) ? B && (R = f(R, B)) : R = f(R, {
          quality: B
        }), R.toWidth = S.width, R.toHeight = S.height, R.width = E.naturalWidth || E.width, R.height = E.naturalHeight || E.height, Object.prototype.hasOwnProperty.call(R, "quality")) {
          if (R.quality < 0 || R.quality > 3)
            throw new Error("Pica: .quality should be [0..3], got ".concat(R.quality));
          R.filter = b.q2f[R.quality];
        }
        if (S.width === 0 || S.height === 0)
          return Promise.reject(new Error("Invalid output size: ".concat(S.width, "x").concat(S.height)));
        R.unsharpRadius > 2 && (R.unsharpRadius = 2), R.canceled = false, R.cancelToken && (R.cancelToken = R.cancelToken.then(function(D) {
          throw R.canceled = true, D;
        }, function(D) {
          throw R.canceled = true, D;
        }));
        var O = 3;
        return R.__destTileBorder = Math.ceil(Math.max(O, 2.5 * R.unsharpRadius | 0)), this.init().then(function() {
          if (R.canceled)
            return R.cancelToken;
          if (T.features.cib) {
            if (b.q2f.indexOf(R.filter) >= 0)
              return T.__resizeViaCreateImageBitmap(E, S, R);
            T.debug("cib is enabled, but not supports provided filter, fallback to manual math");
          }
          if (!I) {
            var D = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
            throw D.code = "ERR_GET_IMAGE_DATA", D;
          }
          var L = x(R.width, R.height, R.toWidth, R.toHeight, T.options.tile, R.__destTileBorder);
          return T.__processStages(L, E, S, R);
        });
      }, F.prototype.resizeBuffer = function(E) {
        var S = this, B = f({}, k, E);
        if (Object.prototype.hasOwnProperty.call(B, "quality")) {
          if (B.quality < 0 || B.quality > 3)
            throw new Error("Pica: .quality should be [0..3], got ".concat(B.quality));
          B.filter = b.q2f[B.quality];
        }
        return this.init().then(function() {
          return S.__mathlib.resizeAndUnsharp(B);
        });
      }, F.prototype.toBlob = function(E, S, B) {
        return S = S || "image/png", new Promise(function(T) {
          if (E.toBlob) {
            E.toBlob(function(U) {
              return T(U);
            }, S, B);
            return;
          }
          if (E.convertToBlob) {
            T(E.convertToBlob({
              type: S,
              quality: B
            }));
            return;
          }
          for (var R = atob(E.toDataURL(S, B).split(",")[1]), O = R.length, D = new Uint8Array(O), L = 0; L < O; L++)
            D[L] = R.charCodeAt(L);
          T(new Blob([D], {
            type: S
          }));
        });
      }, F.prototype.debug = function() {
      }, r.exports = F;
    }, { "./lib/mathlib": 1, "./lib/mm_resize/resize_filter_info": 7, "./lib/pool": 13, "./lib/stepper": 14, "./lib/tiler": 15, "./lib/utils": 16, "./lib/worker": 17, "object-assign": 22, webworkify: 23 }] }, {}, [])("/index.js");
  });
})(No);
var Po = function() {
  var t4 = function(e) {
  };
  (function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports) : typeof define == "function" && define.amd ? define(["exports"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {});
  })(this, function(e) {
    var n = { value: () => {
    } };
    function r() {
      for (var l, h = 0, u = arguments.length, f = {}; h < u; ++h) {
        if (!(l = arguments[h] + "") || l in f || /[\s.]/.test(l))
          throw new Error("illegal type: " + l);
        f[l] = [];
      }
      return new i(f);
    }
    function i(l) {
      this._ = l;
    }
    function a(l, h) {
      return l.trim().split(/^|\s+/).map(function(u) {
        var f = "", c = u.indexOf(".");
        if (c >= 0 && (f = u.slice(c + 1), u = u.slice(0, c)), u && !h.hasOwnProperty(u))
          throw new Error("unknown type: " + u);
        return { type: u, name: f };
      });
    }
    function o(l, h) {
      for (var u, f = 0, c = l.length; f < c; ++f)
        if ((u = l[f]).name === h)
          return u.value;
    }
    function s(l, h, u) {
      for (var f = 0, c = l.length; f < c; ++f)
        if (l[f].name === h) {
          l[f] = n, l = l.slice(0, f).concat(l.slice(f + 1));
          break;
        }
      return u != null && l.push({ name: h, value: u }), l;
    }
    i.prototype = r.prototype = { constructor: i, on: function(l, h) {
      var u, f = this._, c = a(l + "", f), d = -1, v = c.length;
      if (!(arguments.length < 2)) {
        if (h != null && typeof h != "function")
          throw new Error("invalid callback: " + h);
        for (; ++d < v; )
          if (u = (l = c[d]).type)
            f[u] = s(f[u], l.name, h);
          else if (h == null)
            for (u in f)
              f[u] = s(f[u], l.name, null);
        return this;
      }
      for (; ++d < v; )
        if ((u = (l = c[d]).type) && (u = o(f[u], l.name)))
          return u;
    }, copy: function() {
      var l = {}, h = this._;
      for (var u in h)
        l[u] = h[u].slice();
      return new i(l);
    }, call: function(l, h) {
      if ((u = arguments.length - 2) > 0)
        for (var u, f, c = new Array(u), d = 0; d < u; ++d)
          c[d] = arguments[d + 2];
      if (!this._.hasOwnProperty(l))
        throw new Error("unknown type: " + l);
      for (d = 0, u = (f = this._[l]).length; d < u; ++d)
        f[d].value.apply(h, c);
    }, apply: function(l, h, u) {
      if (!this._.hasOwnProperty(l))
        throw new Error("unknown type: " + l);
      for (var f = this._[l], c = 0, d = f.length; c < d; ++c)
        f[c].value.apply(h, u);
    } }, e.dispatch = r, Object.defineProperty(e, "__esModule", { value: true });
  }), function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports) : typeof define == "function" && define.amd ? define(["exports"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {});
  }(this, function(e) {
    function n(u, f, c, d) {
      if (isNaN(f) || isNaN(c))
        return u;
      var v, g, p, x, w, b, m, _, A, C = u._root, k = { data: d }, M = u._x0, P = u._y0, I = u._x1, N = u._y1;
      if (!C)
        return u._root = k, u;
      for (; C.length; )
        if ((b = f >= (g = (M + I) / 2)) ? M = g : I = g, (m = c >= (p = (P + N) / 2)) ? P = p : N = p, v = C, !(C = C[_ = m << 1 | b]))
          return v[_] = k, u;
      if (x = +u._x.call(null, C.data), w = +u._y.call(null, C.data), f === x && c === w)
        return k.next = C, v ? v[_] = k : u._root = k, u;
      do
        v = v ? v[_] = new Array(4) : u._root = new Array(4), (b = f >= (g = (M + I) / 2)) ? M = g : I = g, (m = c >= (p = (P + N) / 2)) ? P = p : N = p;
      while ((_ = m << 1 | b) == (A = (w >= p) << 1 | x >= g));
      return v[A] = C, v[_] = k, u;
    }
    function r(u, f, c, d, v) {
      this.node = u, this.x0 = f, this.y0 = c, this.x1 = d, this.y1 = v;
    }
    function i(u) {
      return u[0];
    }
    function a(u) {
      return u[1];
    }
    function o(u, f, c) {
      var d = new s(f ?? i, c ?? a, NaN, NaN, NaN, NaN);
      return u == null ? d : d.addAll(u);
    }
    function s(u, f, c, d, v, g) {
      this._x = u, this._y = f, this._x0 = c, this._y0 = d, this._x1 = v, this._y1 = g, this._root = void 0;
    }
    function l(u) {
      for (var f = { data: u.data }, c = f; u = u.next; )
        c = c.next = { data: u.data };
      return f;
    }
    var h = o.prototype = s.prototype;
    h.copy = function() {
      var u, f, c = new s(this._x, this._y, this._x0, this._y0, this._x1, this._y1), d = this._root;
      if (!d)
        return c;
      if (!d.length)
        return c._root = l(d), c;
      for (u = [{ source: d, target: c._root = new Array(4) }]; d = u.pop(); )
        for (var v = 0; v < 4; ++v)
          (f = d.source[v]) && (f.length ? u.push({ source: f, target: d.target[v] = new Array(4) }) : d.target[v] = l(f));
      return c;
    }, h.add = function(u) {
      const f = +this._x.call(null, u), c = +this._y.call(null, u);
      return n(this.cover(f, c), f, c, u);
    }, h.addAll = function(u) {
      var f, c, d, v, g = u.length, p = new Array(g), x = new Array(g), w = 1 / 0, b = 1 / 0, m = -1 / 0, _ = -1 / 0;
      for (c = 0; c < g; ++c)
        isNaN(d = +this._x.call(null, f = u[c])) || isNaN(v = +this._y.call(null, f)) || (p[c] = d, x[c] = v, d < w && (w = d), d > m && (m = d), v < b && (b = v), v > _ && (_ = v));
      if (w > m || b > _)
        return this;
      for (this.cover(w, b).cover(m, _), c = 0; c < g; ++c)
        n(this, p[c], x[c], u[c]);
      return this;
    }, h.cover = function(u, f) {
      if (isNaN(u = +u) || isNaN(f = +f))
        return this;
      var c = this._x0, d = this._y0, v = this._x1, g = this._y1;
      if (isNaN(c))
        v = (c = Math.floor(u)) + 1, g = (d = Math.floor(f)) + 1;
      else {
        for (var p, x, w = v - c || 1, b = this._root; c > u || u >= v || d > f || f >= g; )
          switch (x = (f < d) << 1 | u < c, (p = new Array(4))[x] = b, b = p, w *= 2, x) {
            case 0:
              v = c + w, g = d + w;
              break;
            case 1:
              c = v - w, g = d + w;
              break;
            case 2:
              v = c + w, d = g - w;
              break;
            case 3:
              c = v - w, d = g - w;
          }
        this._root && this._root.length && (this._root = b);
      }
      return this._x0 = c, this._y0 = d, this._x1 = v, this._y1 = g, this;
    }, h.data = function() {
      var u = [];
      return this.visit(function(f) {
        if (!f.length)
          do
            u.push(f.data);
          while (f = f.next);
      }), u;
    }, h.extent = function(u) {
      return arguments.length ? this.cover(+u[0][0], +u[0][1]).cover(+u[1][0], +u[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
    }, h.find = function(u, f, c) {
      var d, v, g, p, x, w, b, m = this._x0, _ = this._y0, A = this._x1, C = this._y1, k = [], M = this._root;
      for (M && k.push(new r(M, m, _, A, C)), c == null ? c = 1 / 0 : (m = u - c, _ = f - c, A = u + c, C = f + c, c *= c); w = k.pop(); )
        if (!(!(M = w.node) || (v = w.x0) > A || (g = w.y0) > C || (p = w.x1) < m || (x = w.y1) < _))
          if (M.length) {
            var P = (v + p) / 2, I = (g + x) / 2;
            k.push(new r(M[3], P, I, p, x), new r(M[2], v, I, P, x), new r(M[1], P, g, p, I), new r(M[0], v, g, P, I)), (b = (f >= I) << 1 | u >= P) && (w = k[k.length - 1], k[k.length - 1] = k[k.length - 1 - b], k[k.length - 1 - b] = w);
          } else {
            var N = u - +this._x.call(null, M.data), z = f - +this._y.call(null, M.data), y = N * N + z * z;
            if (y < c) {
              var F = Math.sqrt(c = y);
              m = u - F, _ = f - F, A = u + F, C = f + F, d = M.data;
            }
          }
      return d;
    }, h.remove = function(u) {
      if (isNaN(g = +this._x.call(null, u)) || isNaN(p = +this._y.call(null, u)))
        return this;
      var f, c, d, v, g, p, x, w, b, m, _, A, C = this._root, k = this._x0, M = this._y0, P = this._x1, I = this._y1;
      if (!C)
        return this;
      if (C.length)
        for (; ; ) {
          if ((b = g >= (x = (k + P) / 2)) ? k = x : P = x, (m = p >= (w = (M + I) / 2)) ? M = w : I = w, f = C, !(C = C[_ = m << 1 | b]))
            return this;
          if (!C.length)
            break;
          (f[_ + 1 & 3] || f[_ + 2 & 3] || f[_ + 3 & 3]) && (c = f, A = _);
        }
      for (; C.data !== u; )
        if (d = C, !(C = C.next))
          return this;
      return (v = C.next) && delete C.next, d ? (v ? d.next = v : delete d.next, this) : f ? (v ? f[_] = v : delete f[_], (C = f[0] || f[1] || f[2] || f[3]) && C === (f[3] || f[2] || f[1] || f[0]) && !C.length && (c ? c[A] = C : this._root = C), this) : (this._root = v, this);
    }, h.removeAll = function(u) {
      for (var f = 0, c = u.length; f < c; ++f)
        this.remove(u[f]);
      return this;
    }, h.root = function() {
      return this._root;
    }, h.size = function() {
      var u = 0;
      return this.visit(function(f) {
        if (!f.length)
          do
            ++u;
          while (f = f.next);
      }), u;
    }, h.visit = function(u) {
      var f, c, d, v, g, p, x = [], w = this._root;
      for (w && x.push(new r(w, this._x0, this._y0, this._x1, this._y1)); f = x.pop(); )
        if (!u(w = f.node, d = f.x0, v = f.y0, g = f.x1, p = f.y1) && w.length) {
          var b = (d + g) / 2, m = (v + p) / 2;
          (c = w[3]) && x.push(new r(c, b, m, g, p)), (c = w[2]) && x.push(new r(c, d, m, b, p)), (c = w[1]) && x.push(new r(c, b, v, g, m)), (c = w[0]) && x.push(new r(c, d, v, b, m));
        }
      return this;
    }, h.visitAfter = function(u) {
      var f, c = [], d = [];
      for (this._root && c.push(new r(this._root, this._x0, this._y0, this._x1, this._y1)); f = c.pop(); ) {
        var v = f.node;
        if (v.length) {
          var g, p = f.x0, x = f.y0, w = f.x1, b = f.y1, m = (p + w) / 2, _ = (x + b) / 2;
          (g = v[0]) && c.push(new r(g, p, x, m, _)), (g = v[1]) && c.push(new r(g, m, x, w, _)), (g = v[2]) && c.push(new r(g, p, _, m, b)), (g = v[3]) && c.push(new r(g, m, _, w, b));
        }
        d.push(f);
      }
      for (; f = d.pop(); )
        u(f.node, f.x0, f.y0, f.x1, f.y1);
      return this;
    }, h.x = function(u) {
      return arguments.length ? (this._x = u, this) : this._x;
    }, h.y = function(u) {
      return arguments.length ? (this._y = u, this) : this._y;
    }, e.quadtree = o, Object.defineProperty(e, "__esModule", { value: true });
  }), function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports) : typeof define == "function" && define.amd ? define(["exports"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {});
  }(this, function(e) {
    var n, r, i = 0, a = 0, o = 0, s = 0, l = 0, h = 0, u = typeof performance == "object" && performance.now ? performance : Date, f = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(m) {
      setTimeout(m, 17);
    };
    function c() {
      return l || (f(d), l = u.now() + h);
    }
    function d() {
      l = 0;
    }
    function v() {
      this._call = this._time = this._next = null;
    }
    function g(m, _, A) {
      var C = new v();
      return C.restart(m, _, A), C;
    }
    function p() {
      c(), ++i;
      for (var m, _ = n; _; )
        (m = l - _._time) >= 0 && _._call.call(void 0, m), _ = _._next;
      --i;
    }
    function x() {
      l = (s = u.now()) + h, i = a = 0;
      try {
        p();
      } finally {
        i = 0, function() {
          for (var m, _, A = n, C = 1 / 0; A; )
            A._call ? (C > A._time && (C = A._time), m = A, A = A._next) : (_ = A._next, A._next = null, A = m ? m._next = _ : n = _);
          r = m, b(C);
        }(), l = 0;
      }
    }
    function w() {
      var m = u.now(), _ = m - s;
      _ > 1e3 && (h -= _, s = m);
    }
    function b(m) {
      i || (a && (a = clearTimeout(a)), m - l > 24 ? (m < 1 / 0 && (a = setTimeout(x, m - u.now() - h)), o && (o = clearInterval(o))) : (o || (s = u.now(), o = setInterval(w, 1e3)), i = 1, f(x)));
    }
    v.prototype = g.prototype = { constructor: v, restart: function(m, _, A) {
      if (typeof m != "function")
        throw new TypeError("callback is not a function");
      A = (A == null ? c() : +A) + (_ == null ? 0 : +_), this._next || r === this || (r ? r._next = this : n = this, r = this), this._call = m, this._time = A, b();
    }, stop: function() {
      this._call && (this._call = null, this._time = 1 / 0, b());
    } }, e.interval = function(m, _, A) {
      var C = new v(), k = _;
      return _ == null ? (C.restart(m, _, A), C) : (C._restart = C.restart, C.restart = function(M, P, I) {
        P = +P, I = I == null ? c() : +I, C._restart(function N(z) {
          z += k, C._restart(N, k += P, I), M(z);
        }, P, I);
      }, C.restart(m, _, A), C);
    }, e.now = c, e.timeout = function(m, _, A) {
      var C = new v();
      return _ = _ == null ? 0 : +_, C.restart((k) => {
        C.stop(), m(k + _);
      }, _, A), C;
    }, e.timer = g, e.timerFlush = p, Object.defineProperty(e, "__esModule", { value: true });
  }), function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports, t4(), t4(), t4()) : typeof define == "function" && define.amd ? define(["exports", "d3-quadtree", "d3-dispatch", "d3-timer"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {}, e.d3, e.d3, e.d3);
  }(this, function(e, n, r, i) {
    function a(g) {
      return function() {
        return g;
      };
    }
    function o(g) {
      return 1e-6 * (g() - 0.5);
    }
    function s(g) {
      return g.x + g.vx;
    }
    function l(g) {
      return g.y + g.vy;
    }
    function h(g) {
      return g.index;
    }
    function u(g, p) {
      var x = g.get(p);
      if (!x)
        throw new Error("node not found: " + p);
      return x;
    }
    const f = 4294967296;
    function c(g) {
      return g.x;
    }
    function d(g) {
      return g.y;
    }
    var v = Math.PI * (3 - Math.sqrt(5));
    e.forceCenter = function(g, p) {
      var x, w = 1;
      function b() {
        var m, _, A = x.length, C = 0, k = 0;
        for (m = 0; m < A; ++m)
          C += (_ = x[m]).x, k += _.y;
        for (C = (C / A - g) * w, k = (k / A - p) * w, m = 0; m < A; ++m)
          (_ = x[m]).x -= C, _.y -= k;
      }
      return g == null && (g = 0), p == null && (p = 0), b.initialize = function(m) {
        x = m;
      }, b.x = function(m) {
        return arguments.length ? (g = +m, b) : g;
      }, b.y = function(m) {
        return arguments.length ? (p = +m, b) : p;
      }, b.strength = function(m) {
        return arguments.length ? (w = +m, b) : w;
      }, b;
    }, e.forceCollide = function(g) {
      var p, x, w, b = 1, m = 1;
      function _() {
        for (var k, M, P, I, N, z, y, F = p.length, E = 0; E < m; ++E)
          for (M = n.quadtree(p, s, l).visitAfter(A), k = 0; k < F; ++k)
            P = p[k], z = x[P.index], y = z * z, I = P.x + P.vx, N = P.y + P.vy, M.visit(S);
        function S(B, T, R, O, D) {
          var L = B.data, U = B.r, Q = z + U;
          if (!L)
            return T > I + Q || O < I - Q || R > N + Q || D < N - Q;
          if (L.index > P.index) {
            var G = I - L.x - L.vx, V = N - L.y - L.vy, W = G * G + V * V;
            W < Q * Q && (G === 0 && (W += (G = o(w)) * G), V === 0 && (W += (V = o(w)) * V), W = (Q - (W = Math.sqrt(W))) / W * b, P.vx += (G *= W) * (Q = (U *= U) / (y + U)), P.vy += (V *= W) * Q, L.vx -= G * (Q = 1 - Q), L.vy -= V * Q);
          }
        }
      }
      function A(k) {
        if (k.data)
          return k.r = x[k.data.index];
        for (var M = k.r = 0; M < 4; ++M)
          k[M] && k[M].r > k.r && (k.r = k[M].r);
      }
      function C() {
        if (p) {
          var k, M, P = p.length;
          for (x = new Array(P), k = 0; k < P; ++k)
            M = p[k], x[M.index] = +g(M, k, p);
        }
      }
      return typeof g != "function" && (g = a(g == null ? 1 : +g)), _.initialize = function(k, M) {
        p = k, w = M, C();
      }, _.iterations = function(k) {
        return arguments.length ? (m = +k, _) : m;
      }, _.strength = function(k) {
        return arguments.length ? (b = +k, _) : b;
      }, _.radius = function(k) {
        return arguments.length ? (g = typeof k == "function" ? k : a(+k), C(), _) : g;
      }, _;
    }, e.forceLink = function(g) {
      var p, x, w, b, m, _, A = h, C = function(y) {
        return 1 / Math.min(b[y.source.index], b[y.target.index]);
      }, k = a(30), M = 1;
      function P(y) {
        for (var F = 0, E = g.length; F < M; ++F)
          for (var S, B, T, R, O, D, L, U = 0; U < E; ++U)
            B = (S = g[U]).source, R = (T = S.target).x + T.vx - B.x - B.vx || o(_), O = T.y + T.vy - B.y - B.vy || o(_), R *= D = ((D = Math.sqrt(R * R + O * O)) - x[U]) / D * y * p[U], O *= D, T.vx -= R * (L = m[U]), T.vy -= O * L, B.vx += R * (L = 1 - L), B.vy += O * L;
      }
      function I() {
        if (w) {
          var y, F, E = w.length, S = g.length, B = new Map(w.map((T, R) => [A(T, R, w), T]));
          for (y = 0, b = new Array(E); y < S; ++y)
            (F = g[y]).index = y, typeof F.source != "object" && (F.source = u(B, F.source)), typeof F.target != "object" && (F.target = u(B, F.target)), b[F.source.index] = (b[F.source.index] || 0) + 1, b[F.target.index] = (b[F.target.index] || 0) + 1;
          for (y = 0, m = new Array(S); y < S; ++y)
            F = g[y], m[y] = b[F.source.index] / (b[F.source.index] + b[F.target.index]);
          p = new Array(S), N(), x = new Array(S), z();
        }
      }
      function N() {
        if (w)
          for (var y = 0, F = g.length; y < F; ++y)
            p[y] = +C(g[y], y, g);
      }
      function z() {
        if (w)
          for (var y = 0, F = g.length; y < F; ++y)
            x[y] = +k(g[y], y, g);
      }
      return g == null && (g = []), P.initialize = function(y, F) {
        w = y, _ = F, I();
      }, P.links = function(y) {
        return arguments.length ? (g = y, I(), P) : g;
      }, P.id = function(y) {
        return arguments.length ? (A = y, P) : A;
      }, P.iterations = function(y) {
        return arguments.length ? (M = +y, P) : M;
      }, P.strength = function(y) {
        return arguments.length ? (C = typeof y == "function" ? y : a(+y), N(), P) : C;
      }, P.distance = function(y) {
        return arguments.length ? (k = typeof y == "function" ? y : a(+y), z(), P) : k;
      }, P;
    }, e.forceManyBody = function() {
      var g, p, x, w, b, m = a(-30), _ = 1, A = 1 / 0, C = 0.81;
      function k(N) {
        var z, y = g.length, F = n.quadtree(g, c, d).visitAfter(P);
        for (w = N, z = 0; z < y; ++z)
          p = g[z], F.visit(I);
      }
      function M() {
        if (g) {
          var N, z, y = g.length;
          for (b = new Array(y), N = 0; N < y; ++N)
            z = g[N], b[z.index] = +m(z, N, g);
        }
      }
      function P(N) {
        var z, y, F, E, S, B = 0, T = 0;
        if (N.length) {
          for (F = E = S = 0; S < 4; ++S)
            (z = N[S]) && (y = Math.abs(z.value)) && (B += z.value, T += y, F += y * z.x, E += y * z.y);
          N.x = F / T, N.y = E / T;
        } else {
          (z = N).x = z.data.x, z.y = z.data.y;
          do
            B += b[z.data.index];
          while (z = z.next);
        }
        N.value = B;
      }
      function I(N, z, y, F) {
        if (!N.value)
          return true;
        var E = N.x - p.x, S = N.y - p.y, B = F - z, T = E * E + S * S;
        if (B * B / C < T)
          return T < A && (E === 0 && (T += (E = o(x)) * E), S === 0 && (T += (S = o(x)) * S), T < _ && (T = Math.sqrt(_ * T)), p.vx += E * N.value * w / T, p.vy += S * N.value * w / T), true;
        if (!(N.length || T >= A)) {
          (N.data !== p || N.next) && (E === 0 && (T += (E = o(x)) * E), S === 0 && (T += (S = o(x)) * S), T < _ && (T = Math.sqrt(_ * T)));
          do
            N.data !== p && (B = b[N.data.index] * w / T, p.vx += E * B, p.vy += S * B);
          while (N = N.next);
        }
      }
      return k.initialize = function(N, z) {
        g = N, x = z, M();
      }, k.strength = function(N) {
        return arguments.length ? (m = typeof N == "function" ? N : a(+N), M(), k) : m;
      }, k.distanceMin = function(N) {
        return arguments.length ? (_ = N * N, k) : Math.sqrt(_);
      }, k.distanceMax = function(N) {
        return arguments.length ? (A = N * N, k) : Math.sqrt(A);
      }, k.theta = function(N) {
        return arguments.length ? (C = N * N, k) : Math.sqrt(C);
      }, k;
    }, e.forceRadial = function(g, p, x) {
      var w, b, m, _ = a(0.1);
      function A(k) {
        for (var M = 0, P = w.length; M < P; ++M) {
          var I = w[M], N = I.x - p || 1e-6, z = I.y - x || 1e-6, y = Math.sqrt(N * N + z * z), F = (m[M] - y) * b[M] * k / y;
          I.vx += N * F, I.vy += z * F;
        }
      }
      function C() {
        if (w) {
          var k, M = w.length;
          for (b = new Array(M), m = new Array(M), k = 0; k < M; ++k)
            m[k] = +g(w[k], k, w), b[k] = isNaN(m[k]) ? 0 : +_(w[k], k, w);
        }
      }
      return typeof g != "function" && (g = a(+g)), p == null && (p = 0), x == null && (x = 0), A.initialize = function(k) {
        w = k, C();
      }, A.strength = function(k) {
        return arguments.length ? (_ = typeof k == "function" ? k : a(+k), C(), A) : _;
      }, A.radius = function(k) {
        return arguments.length ? (g = typeof k == "function" ? k : a(+k), C(), A) : g;
      }, A.x = function(k) {
        return arguments.length ? (p = +k, A) : p;
      }, A.y = function(k) {
        return arguments.length ? (x = +k, A) : x;
      }, A;
    }, e.forceSimulation = function(g) {
      var p, x = 1, w = 1e-3, b = 1 - Math.pow(w, 1 / 300), m = 0, _ = 0.6, A = /* @__PURE__ */ new Map(), C = i.timer(P), k = r.dispatch("tick", "end"), M = function() {
        let y = 1;
        return () => (y = (1664525 * y + 1013904223) % f) / f;
      }();
      function P() {
        I(), k.call("tick", p), x < w && (C.stop(), k.call("end", p));
      }
      function I(y) {
        var F, E, S = g.length;
        y === void 0 && (y = 1);
        for (var B = 0; B < y; ++B)
          for (x += (m - x) * b, A.forEach(function(T) {
            T(x);
          }), F = 0; F < S; ++F)
            (E = g[F]).fx == null ? E.x += E.vx *= _ : (E.x = E.fx, E.vx = 0), E.fy == null ? E.y += E.vy *= _ : (E.y = E.fy, E.vy = 0);
        return p;
      }
      function N() {
        for (var y, F = 0, E = g.length; F < E; ++F) {
          if ((y = g[F]).index = F, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
            var S = 10 * Math.sqrt(0.5 + F), B = F * v;
            y.x = S * Math.cos(B), y.y = S * Math.sin(B);
          }
          (isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0);
        }
      }
      function z(y) {
        return y.initialize && y.initialize(g, M), y;
      }
      return g == null && (g = []), N(), p = { tick: I, restart: function() {
        return C.restart(P), p;
      }, stop: function() {
        return C.stop(), p;
      }, nodes: function(y) {
        return arguments.length ? (g = y, N(), A.forEach(z), p) : g;
      }, alpha: function(y) {
        return arguments.length ? (x = +y, p) : x;
      }, alphaMin: function(y) {
        return arguments.length ? (w = +y, p) : w;
      }, alphaDecay: function(y) {
        return arguments.length ? (b = +y, p) : +b;
      }, alphaTarget: function(y) {
        return arguments.length ? (m = +y, p) : m;
      }, velocityDecay: function(y) {
        return arguments.length ? (_ = 1 - y, p) : 1 - _;
      }, randomSource: function(y) {
        return arguments.length ? (M = y, A.forEach(z), p) : M;
      }, force: function(y, F) {
        return arguments.length > 1 ? (F == null ? A.delete(y) : A.set(y, z(F)), p) : A.get(y);
      }, find: function(y, F, E) {
        var S, B, T, R, O, D = 0, L = g.length;
        for (E == null ? E = 1 / 0 : E *= E, D = 0; D < L; ++D)
          (T = (S = y - (R = g[D]).x) * S + (B = F - R.y) * B) < E && (O = R, E = T);
        return O;
      }, on: function(y, F) {
        return arguments.length > 1 ? (k.on(y, F), p) : k.on(y);
      } };
    }, e.forceX = function(g) {
      var p, x, w, b = a(0.1);
      function m(A) {
        for (var C, k = 0, M = p.length; k < M; ++k)
          (C = p[k]).vx += (w[k] - C.x) * x[k] * A;
      }
      function _() {
        if (p) {
          var A, C = p.length;
          for (x = new Array(C), w = new Array(C), A = 0; A < C; ++A)
            x[A] = isNaN(w[A] = +g(p[A], A, p)) ? 0 : +b(p[A], A, p);
        }
      }
      return typeof g != "function" && (g = a(g == null ? 0 : +g)), m.initialize = function(A) {
        p = A, _();
      }, m.strength = function(A) {
        return arguments.length ? (b = typeof A == "function" ? A : a(+A), _(), m) : b;
      }, m.x = function(A) {
        return arguments.length ? (g = typeof A == "function" ? A : a(+A), _(), m) : g;
      }, m;
    }, e.forceY = function(g) {
      var p, x, w, b = a(0.1);
      function m(A) {
        for (var C, k = 0, M = p.length; k < M; ++k)
          (C = p[k]).vy += (w[k] - C.y) * x[k] * A;
      }
      function _() {
        if (p) {
          var A, C = p.length;
          for (x = new Array(C), w = new Array(C), A = 0; A < C; ++A)
            x[A] = isNaN(w[A] = +g(p[A], A, p)) ? 0 : +b(p[A], A, p);
        }
      }
      return typeof g != "function" && (g = a(g == null ? 0 : +g)), m.initialize = function(A) {
        p = A, _();
      }, m.strength = function(A) {
        return arguments.length ? (b = typeof A == "function" ? A : a(+A), _(), m) : b;
      }, m.y = function(A) {
        return arguments.length ? (g = typeof A == "function" ? A : a(+A), _(), m) : g;
      }, m;
    }, Object.defineProperty(e, "__esModule", { value: true });
  }), function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports) : typeof define == "function" && define.amd ? define(["exports"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {});
  }(this, function(e) {
    function n(h, u, f) {
      if (isNaN(u))
        return h;
      var c, d, v, g, p, x, w = h._root, b = { data: f }, m = h._x0, _ = h._x1;
      if (!w)
        return h._root = b, h;
      for (; w.length; )
        if ((g = u >= (d = (m + _) / 2)) ? m = d : _ = d, c = w, !(w = w[p = +g]))
          return c[p] = b, h;
      if (u === (v = +h._x.call(null, w.data)))
        return b.next = w, c ? c[p] = b : h._root = b, h;
      do
        c = c ? c[p] = new Array(2) : h._root = new Array(2), (g = u >= (d = (m + _) / 2)) ? m = d : _ = d;
      while ((p = +g) == (x = +(v >= d)));
      return c[x] = w, c[p] = b, h;
    }
    function r(h, u, f) {
      this.node = h, this.x0 = u, this.x1 = f;
    }
    function i(h) {
      return h[0];
    }
    function a(h, u) {
      var f = new o(u ?? i, NaN, NaN);
      return h == null ? f : f.addAll(h);
    }
    function o(h, u, f) {
      this._x = h, this._x0 = u, this._x1 = f, this._root = void 0;
    }
    function s(h) {
      for (var u = { data: h.data }, f = u; h = h.next; )
        f = f.next = { data: h.data };
      return u;
    }
    var l = a.prototype = o.prototype;
    l.copy = function() {
      var h, u, f = new o(this._x, this._x0, this._x1), c = this._root;
      if (!c)
        return f;
      if (!c.length)
        return f._root = s(c), f;
      for (h = [{ source: c, target: f._root = new Array(2) }]; c = h.pop(); )
        for (var d = 0; d < 2; ++d)
          (u = c.source[d]) && (u.length ? h.push({ source: u, target: c.target[d] = new Array(2) }) : c.target[d] = s(u));
      return f;
    }, l.add = function(h) {
      var u = +this._x.call(null, h);
      return n(this.cover(u), u, h);
    }, l.addAll = function(h) {
      var u, f, c = h.length, d = new Array(c), v = 1 / 0, g = -1 / 0;
      for (u = 0; u < c; ++u)
        isNaN(f = +this._x.call(null, h[u])) || (d[u] = f, f < v && (v = f), f > g && (g = f));
      if (v > g)
        return this;
      for (this.cover(v).cover(g), u = 0; u < c; ++u)
        n(this, d[u], h[u]);
      return this;
    }, l.cover = function(h) {
      if (isNaN(h = +h))
        return this;
      var u = this._x0, f = this._x1;
      if (isNaN(u))
        f = (u = Math.floor(h)) + 1;
      else {
        for (var c, d, v = f - u || 1, g = this._root; u > h || h >= f; )
          switch (d = +(h < u), (c = new Array(2))[d] = g, g = c, v *= 2, d) {
            case 0:
              f = u + v;
              break;
            case 1:
              u = f - v;
          }
        this._root && this._root.length && (this._root = g);
      }
      return this._x0 = u, this._x1 = f, this;
    }, l.data = function() {
      var h = [];
      return this.visit(function(u) {
        if (!u.length)
          do
            h.push(u.data);
          while (u = u.next);
      }), h;
    }, l.extent = function(h) {
      return arguments.length ? this.cover(+h[0][0]).cover(+h[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
    }, l.find = function(h, u) {
      var f, c, d, v, g, p = this._x0, x = this._x1, w = [], b = this._root;
      for (b && w.push(new r(b, p, x)), u == null ? u = 1 / 0 : (p = h - u, x = h + u); v = w.pop(); )
        if (!(!(b = v.node) || (c = v.x0) > x || (d = v.x1) < p))
          if (b.length) {
            var m = (c + d) / 2;
            w.push(new r(b[1], m, d), new r(b[0], c, m)), (g = +(h >= m)) && (v = w[w.length - 1], w[w.length - 1] = w[w.length - 1 - g], w[w.length - 1 - g] = v);
          } else {
            var _ = Math.abs(h - +this._x.call(null, b.data));
            _ < u && (u = _, p = h - _, x = h + _, f = b.data);
          }
      return f;
    }, l.remove = function(h) {
      if (isNaN(v = +this._x.call(null, h)))
        return this;
      var u, f, c, d, v, g, p, x, w, b = this._root, m = this._x0, _ = this._x1;
      if (!b)
        return this;
      if (b.length)
        for (; ; ) {
          if ((p = v >= (g = (m + _) / 2)) ? m = g : _ = g, u = b, !(b = b[x = +p]))
            return this;
          if (!b.length)
            break;
          u[x + 1 & 1] && (f = u, w = x);
        }
      for (; b.data !== h; )
        if (c = b, !(b = b.next))
          return this;
      return (d = b.next) && delete b.next, c ? (d ? c.next = d : delete c.next, this) : u ? (d ? u[x] = d : delete u[x], (b = u[0] || u[1]) && b === (u[1] || u[0]) && !b.length && (f ? f[w] = b : this._root = b), this) : (this._root = d, this);
    }, l.removeAll = function(h) {
      for (var u = 0, f = h.length; u < f; ++u)
        this.remove(h[u]);
      return this;
    }, l.root = function() {
      return this._root;
    }, l.size = function() {
      var h = 0;
      return this.visit(function(u) {
        if (!u.length)
          do
            ++h;
          while (u = u.next);
      }), h;
    }, l.visit = function(h) {
      var u, f, c, d, v = [], g = this._root;
      for (g && v.push(new r(g, this._x0, this._x1)); u = v.pop(); )
        if (!h(g = u.node, c = u.x0, d = u.x1) && g.length) {
          var p = (c + d) / 2;
          (f = g[1]) && v.push(new r(f, p, d)), (f = g[0]) && v.push(new r(f, c, p));
        }
      return this;
    }, l.visitAfter = function(h) {
      var u, f = [], c = [];
      for (this._root && f.push(new r(this._root, this._x0, this._x1)); u = f.pop(); ) {
        var d = u.node;
        if (d.length) {
          var v, g = u.x0, p = u.x1, x = (g + p) / 2;
          (v = d[0]) && f.push(new r(v, g, x)), (v = d[1]) && f.push(new r(v, x, p));
        }
        c.push(u);
      }
      for (; u = c.pop(); )
        h(u.node, u.x0, u.x1);
      return this;
    }, l.x = function(h) {
      return arguments.length ? (this._x = h, this) : this._x;
    }, e.binarytree = a, Object.defineProperty(e, "__esModule", { value: true });
  }), function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports) : typeof define == "function" && define.amd ? define(["exports"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {});
  }(this, function(e) {
    function n(f, c, d, v, g) {
      if (isNaN(c) || isNaN(d) || isNaN(v))
        return f;
      var p, x, w, b, m, _, A, C, k, M, P, I, N = f._root, z = { data: g }, y = f._x0, F = f._y0, E = f._z0, S = f._x1, B = f._y1, T = f._z1;
      if (!N)
        return f._root = z, f;
      for (; N.length; )
        if ((C = c >= (x = (y + S) / 2)) ? y = x : S = x, (k = d >= (w = (F + B) / 2)) ? F = w : B = w, (M = v >= (b = (E + T) / 2)) ? E = b : T = b, p = N, !(N = N[P = M << 2 | k << 1 | C]))
          return p[P] = z, f;
      if (m = +f._x.call(null, N.data), _ = +f._y.call(null, N.data), A = +f._z.call(null, N.data), c === m && d === _ && v === A)
        return z.next = N, p ? p[P] = z : f._root = z, f;
      do
        p = p ? p[P] = new Array(8) : f._root = new Array(8), (C = c >= (x = (y + S) / 2)) ? y = x : S = x, (k = d >= (w = (F + B) / 2)) ? F = w : B = w, (M = v >= (b = (E + T) / 2)) ? E = b : T = b;
      while ((P = M << 2 | k << 1 | C) == (I = (A >= b) << 2 | (_ >= w) << 1 | m >= x));
      return p[I] = N, p[P] = z, f;
    }
    function r(f, c, d, v, g, p, x) {
      this.node = f, this.x0 = c, this.y0 = d, this.z0 = v, this.x1 = g, this.y1 = p, this.z1 = x;
    }
    function i(f) {
      return f[0];
    }
    function a(f) {
      return f[1];
    }
    function o(f) {
      return f[2];
    }
    function s(f, c, d, v) {
      var g = new l(c ?? i, d ?? a, v ?? o, NaN, NaN, NaN, NaN, NaN, NaN);
      return f == null ? g : g.addAll(f);
    }
    function l(f, c, d, v, g, p, x, w, b) {
      this._x = f, this._y = c, this._z = d, this._x0 = v, this._y0 = g, this._z0 = p, this._x1 = x, this._y1 = w, this._z1 = b, this._root = void 0;
    }
    function h(f) {
      for (var c = { data: f.data }, d = c; f = f.next; )
        d = d.next = { data: f.data };
      return c;
    }
    var u = s.prototype = l.prototype;
    u.copy = function() {
      var f, c, d = new l(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), v = this._root;
      if (!v)
        return d;
      if (!v.length)
        return d._root = h(v), d;
      for (f = [{ source: v, target: d._root = new Array(8) }]; v = f.pop(); )
        for (var g = 0; g < 8; ++g)
          (c = v.source[g]) && (c.length ? f.push({ source: c, target: v.target[g] = new Array(8) }) : v.target[g] = h(c));
      return d;
    }, u.add = function(f) {
      var c = +this._x.call(null, f), d = +this._y.call(null, f), v = +this._z.call(null, f);
      return n(this.cover(c, d, v), c, d, v, f);
    }, u.addAll = function(f) {
      var c, d, v, g, p, x = f.length, w = new Array(x), b = new Array(x), m = new Array(x), _ = 1 / 0, A = 1 / 0, C = 1 / 0, k = -1 / 0, M = -1 / 0, P = -1 / 0;
      for (d = 0; d < x; ++d)
        isNaN(v = +this._x.call(null, c = f[d])) || isNaN(g = +this._y.call(null, c)) || isNaN(p = +this._z.call(null, c)) || (w[d] = v, b[d] = g, m[d] = p, v < _ && (_ = v), v > k && (k = v), g < A && (A = g), g > M && (M = g), p < C && (C = p), p > P && (P = p));
      if (_ > k || A > M || C > P)
        return this;
      for (this.cover(_, A, C).cover(k, M, P), d = 0; d < x; ++d)
        n(this, w[d], b[d], m[d], f[d]);
      return this;
    }, u.cover = function(f, c, d) {
      if (isNaN(f = +f) || isNaN(c = +c) || isNaN(d = +d))
        return this;
      var v = this._x0, g = this._y0, p = this._z0, x = this._x1, w = this._y1, b = this._z1;
      if (isNaN(v))
        x = (v = Math.floor(f)) + 1, w = (g = Math.floor(c)) + 1, b = (p = Math.floor(d)) + 1;
      else {
        for (var m, _, A = x - v || 1, C = this._root; v > f || f >= x || g > c || c >= w || p > d || d >= b; )
          switch (_ = (d < p) << 2 | (c < g) << 1 | f < v, (m = new Array(8))[_] = C, C = m, A *= 2, _) {
            case 0:
              x = v + A, w = g + A, b = p + A;
              break;
            case 1:
              v = x - A, w = g + A, b = p + A;
              break;
            case 2:
              x = v + A, g = w - A, b = p + A;
              break;
            case 3:
              v = x - A, g = w - A, b = p + A;
              break;
            case 4:
              x = v + A, w = g + A, p = b - A;
              break;
            case 5:
              v = x - A, w = g + A, p = b - A;
              break;
            case 6:
              x = v + A, g = w - A, p = b - A;
              break;
            case 7:
              v = x - A, g = w - A, p = b - A;
          }
        this._root && this._root.length && (this._root = C);
      }
      return this._x0 = v, this._y0 = g, this._z0 = p, this._x1 = x, this._y1 = w, this._z1 = b, this;
    }, u.data = function() {
      var f = [];
      return this.visit(function(c) {
        if (!c.length)
          do
            f.push(c.data);
          while (c = c.next);
      }), f;
    }, u.extent = function(f) {
      return arguments.length ? this.cover(+f[0][0], +f[0][1], +f[0][2]).cover(+f[1][0], +f[1][1], +f[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
    }, u.find = function(f, c, d, v) {
      var g, p, x, w, b, m, _, A, C, k = this._x0, M = this._y0, P = this._z0, I = this._x1, N = this._y1, z = this._z1, y = [], F = this._root;
      for (F && y.push(new r(F, k, M, P, I, N, z)), v == null ? v = 1 / 0 : (k = f - v, M = c - v, P = d - v, I = f + v, N = c + v, z = d + v, v *= v); A = y.pop(); )
        if (!(!(F = A.node) || (p = A.x0) > I || (x = A.y0) > N || (w = A.z0) > z || (b = A.x1) < k || (m = A.y1) < M || (_ = A.z1) < P))
          if (F.length) {
            var E = (p + b) / 2, S = (x + m) / 2, B = (w + _) / 2;
            y.push(new r(F[7], E, S, B, b, m, _), new r(F[6], p, S, B, E, m, _), new r(F[5], E, x, B, b, S, _), new r(F[4], p, x, B, E, S, _), new r(F[3], E, S, w, b, m, B), new r(F[2], p, S, w, E, m, B), new r(F[1], E, x, w, b, S, B), new r(F[0], p, x, w, E, S, B)), (C = (d >= B) << 2 | (c >= S) << 1 | f >= E) && (A = y[y.length - 1], y[y.length - 1] = y[y.length - 1 - C], y[y.length - 1 - C] = A);
          } else {
            var T = f - +this._x.call(null, F.data), R = c - +this._y.call(null, F.data), O = d - +this._z.call(null, F.data), D = T * T + R * R + O * O;
            if (D < v) {
              var L = Math.sqrt(v = D);
              k = f - L, M = c - L, P = d - L, I = f + L, N = c + L, z = d + L, g = F.data;
            }
          }
      return g;
    }, u.remove = function(f) {
      if (isNaN(p = +this._x.call(null, f)) || isNaN(x = +this._y.call(null, f)) || isNaN(w = +this._z.call(null, f)))
        return this;
      var c, d, v, g, p, x, w, b, m, _, A, C, k, M, P, I = this._root, N = this._x0, z = this._y0, y = this._z0, F = this._x1, E = this._y1, S = this._z1;
      if (!I)
        return this;
      if (I.length)
        for (; ; ) {
          if ((A = p >= (b = (N + F) / 2)) ? N = b : F = b, (C = x >= (m = (z + E) / 2)) ? z = m : E = m, (k = w >= (_ = (y + S) / 2)) ? y = _ : S = _, c = I, !(I = I[M = k << 2 | C << 1 | A]))
            return this;
          if (!I.length)
            break;
          (c[M + 1 & 7] || c[M + 2 & 7] || c[M + 3 & 7] || c[M + 4 & 7] || c[M + 5 & 7] || c[M + 6 & 7] || c[M + 7 & 7]) && (d = c, P = M);
        }
      for (; I.data !== f; )
        if (v = I, !(I = I.next))
          return this;
      return (g = I.next) && delete I.next, v ? (g ? v.next = g : delete v.next, this) : c ? (g ? c[M] = g : delete c[M], (I = c[0] || c[1] || c[2] || c[3] || c[4] || c[5] || c[6] || c[7]) && I === (c[7] || c[6] || c[5] || c[4] || c[3] || c[2] || c[1] || c[0]) && !I.length && (d ? d[P] = I : this._root = I), this) : (this._root = g, this);
    }, u.removeAll = function(f) {
      for (var c = 0, d = f.length; c < d; ++c)
        this.remove(f[c]);
      return this;
    }, u.root = function() {
      return this._root;
    }, u.size = function() {
      var f = 0;
      return this.visit(function(c) {
        if (!c.length)
          do
            ++f;
          while (c = c.next);
      }), f;
    }, u.visit = function(f) {
      var c, d, v, g, p, x, w, b, m = [], _ = this._root;
      for (_ && m.push(new r(_, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); c = m.pop(); )
        if (!f(_ = c.node, v = c.x0, g = c.y0, p = c.z0, x = c.x1, w = c.y1, b = c.z1) && _.length) {
          var A = (v + x) / 2, C = (g + w) / 2, k = (p + b) / 2;
          (d = _[7]) && m.push(new r(d, A, C, k, x, w, b)), (d = _[6]) && m.push(new r(d, v, C, k, A, w, b)), (d = _[5]) && m.push(new r(d, A, g, k, x, C, b)), (d = _[4]) && m.push(new r(d, v, g, k, A, C, b)), (d = _[3]) && m.push(new r(d, A, C, p, x, w, k)), (d = _[2]) && m.push(new r(d, v, C, p, A, w, k)), (d = _[1]) && m.push(new r(d, A, g, p, x, C, k)), (d = _[0]) && m.push(new r(d, v, g, p, A, C, k));
        }
      return this;
    }, u.visitAfter = function(f) {
      var c, d = [], v = [];
      for (this._root && d.push(new r(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); c = d.pop(); ) {
        var g = c.node;
        if (g.length) {
          var p, x = c.x0, w = c.y0, b = c.z0, m = c.x1, _ = c.y1, A = c.z1, C = (x + m) / 2, k = (w + _) / 2, M = (b + A) / 2;
          (p = g[0]) && d.push(new r(p, x, w, b, C, k, M)), (p = g[1]) && d.push(new r(p, C, w, b, m, k, M)), (p = g[2]) && d.push(new r(p, x, k, b, C, _, M)), (p = g[3]) && d.push(new r(p, C, k, b, m, _, M)), (p = g[4]) && d.push(new r(p, x, w, M, C, k, A)), (p = g[5]) && d.push(new r(p, C, w, M, m, k, A)), (p = g[6]) && d.push(new r(p, x, k, M, C, _, A)), (p = g[7]) && d.push(new r(p, C, k, M, m, _, A));
        }
        v.push(c);
      }
      for (; c = v.pop(); )
        f(c.node, c.x0, c.y0, c.z0, c.x1, c.y1, c.z1);
      return this;
    }, u.x = function(f) {
      return arguments.length ? (this._x = f, this) : this._x;
    }, u.y = function(f) {
      return arguments.length ? (this._y = f, this) : this._y;
    }, u.z = function(f) {
      return arguments.length ? (this._z = f, this) : this._z;
    }, e.octree = s, Object.defineProperty(e, "__esModule", { value: true });
  }), function(e, n) {
    typeof exports == "object" && typeof module < "u" ? n(exports, t4(), t4(), t4(), t4(), t4()) : typeof define == "function" && define.amd ? define(["exports", "d3-binarytree", "d3-quadtree", "d3-octree", "d3-dispatch", "d3-timer"], n) : n((e = typeof globalThis < "u" ? globalThis : e || self).d3 = e.d3 || {}, e.d3, e.d3, e.d3, e.d3, e.d3);
  }(this, function(e, n, r, i, a, o) {
    function s(m) {
      return function() {
        return m;
      };
    }
    function l(m) {
      return 1e-6 * (m() - 0.5);
    }
    function h(m) {
      return m.x + m.vx;
    }
    function u(m) {
      return m.y + m.vy;
    }
    function f(m) {
      return m.z + m.vz;
    }
    function c(m) {
      return m.index;
    }
    function d(m, _) {
      var A = m.get(_);
      if (!A)
        throw new Error("node not found: " + _);
      return A;
    }
    const v = 4294967296;
    function g(m) {
      return m.x;
    }
    function p(m) {
      return m.y;
    }
    function x(m) {
      return m.z;
    }
    var w = Math.PI * (3 - Math.sqrt(5)), b = 20 * Math.PI / (9 + Math.sqrt(221));
    e.forceCenter = function(m, _, A) {
      var C, k = 1;
      function M() {
        var P, I, N = C.length, z = 0, y = 0, F = 0;
        for (P = 0; P < N; ++P)
          z += (I = C[P]).x || 0, y += I.y || 0, F += I.z || 0;
        for (z = (z / N - m) * k, y = (y / N - _) * k, F = (F / N - A) * k, P = 0; P < N; ++P)
          I = C[P], z && (I.x -= z), y && (I.y -= y), F && (I.z -= F);
      }
      return m == null && (m = 0), _ == null && (_ = 0), A == null && (A = 0), M.initialize = function(P) {
        C = P;
      }, M.x = function(P) {
        return arguments.length ? (m = +P, M) : m;
      }, M.y = function(P) {
        return arguments.length ? (_ = +P, M) : _;
      }, M.z = function(P) {
        return arguments.length ? (A = +P, M) : A;
      }, M.strength = function(P) {
        return arguments.length ? (k = +P, M) : k;
      }, M;
    }, e.forceCollide = function(m) {
      var _, A, C, k, M = 1, P = 1;
      function I() {
        for (var y, F, E, S, B, T, R, O, D = _.length, L = 0; L < P; ++L)
          for (F = (A === 1 ? n.binarytree(_, h) : A === 2 ? r.quadtree(_, h, u) : A === 3 ? i.octree(_, h, u, f) : null).visitAfter(N), y = 0; y < D; ++y)
            E = _[y], R = C[E.index], O = R * R, S = E.x + E.vx, A > 1 && (B = E.y + E.vy), A > 2 && (T = E.z + E.vz), F.visit(U);
        function U(Q, G, V, W, Y, re, X) {
          var K = [G, V, W, Y, re, X], Ft = K[0], xr = K[1], br = K[2], wr = K[A], Er = K[A + 1], kr = K[A + 2], J = Q.data, qe = Q.r, H = R + qe;
          if (!J)
            return Ft > S + H || wr < S - H || A > 1 && (xr > B + H || Er < B - H) || A > 2 && (br > T + H || kr < T - H);
          if (J.index > E.index) {
            var ve = S - J.x - J.vx, me = A > 1 ? B - J.y - J.vy : 0, pe = A > 2 ? T - J.z - J.vz : 0, ee = ve * ve + me * me + pe * pe;
            ee < H * H && (ve === 0 && (ee += (ve = l(k)) * ve), A > 1 && me === 0 && (ee += (me = l(k)) * me), A > 2 && pe === 0 && (ee += (pe = l(k)) * pe), ee = (H - (ee = Math.sqrt(ee))) / ee * M, E.vx += (ve *= ee) * (H = (qe *= qe) / (O + qe)), A > 1 && (E.vy += (me *= ee) * H), A > 2 && (E.vz += (pe *= ee) * H), J.vx -= ve * (H = 1 - H), A > 1 && (J.vy -= me * H), A > 2 && (J.vz -= pe * H));
          }
        }
      }
      function N(y) {
        if (y.data)
          return y.r = C[y.data.index];
        for (var F = y.r = 0; F < Math.pow(2, A); ++F)
          y[F] && y[F].r > y.r && (y.r = y[F].r);
      }
      function z() {
        if (_) {
          var y, F, E = _.length;
          for (C = new Array(E), y = 0; y < E; ++y)
            F = _[y], C[F.index] = +m(F, y, _);
        }
      }
      return typeof m != "function" && (m = s(m == null ? 1 : +m)), I.initialize = function(y, ...F) {
        _ = y, k = F.find((E) => typeof E == "function") || Math.random, A = F.find((E) => [1, 2, 3].includes(E)) || 2, z();
      }, I.iterations = function(y) {
        return arguments.length ? (P = +y, I) : P;
      }, I.strength = function(y) {
        return arguments.length ? (M = +y, I) : M;
      }, I.radius = function(y) {
        return arguments.length ? (m = typeof y == "function" ? y : s(+y), z(), I) : m;
      }, I;
    }, e.forceLink = function(m) {
      var _, A, C, k, M, P, I, N = c, z = function(R) {
        return 1 / Math.min(M[R.source.index], M[R.target.index]);
      }, y = s(30), F = 1;
      function E(R) {
        for (var O = 0, D = m.length; O < F; ++O)
          for (var L, U, Q, G, V, W = 0, Y = 0, re = 0, X = 0; W < D; ++W)
            U = (L = m[W]).source, Y = (Q = L.target).x + Q.vx - U.x - U.vx || l(I), k > 1 && (re = Q.y + Q.vy - U.y - U.vy || l(I)), k > 2 && (X = Q.z + Q.vz - U.z - U.vz || l(I)), Y *= G = ((G = Math.sqrt(Y * Y + re * re + X * X)) - A[W]) / G * R * _[W], re *= G, X *= G, Q.vx -= Y * (V = P[W]), k > 1 && (Q.vy -= re * V), k > 2 && (Q.vz -= X * V), U.vx += Y * (V = 1 - V), k > 1 && (U.vy += re * V), k > 2 && (U.vz += X * V);
      }
      function S() {
        if (C) {
          var R, O, D = C.length, L = m.length, U = new Map(C.map((Q, G) => [N(Q, G, C), Q]));
          for (R = 0, M = new Array(D); R < L; ++R)
            (O = m[R]).index = R, typeof O.source != "object" && (O.source = d(U, O.source)), typeof O.target != "object" && (O.target = d(U, O.target)), M[O.source.index] = (M[O.source.index] || 0) + 1, M[O.target.index] = (M[O.target.index] || 0) + 1;
          for (R = 0, P = new Array(L); R < L; ++R)
            O = m[R], P[R] = M[O.source.index] / (M[O.source.index] + M[O.target.index]);
          _ = new Array(L), B(), A = new Array(L), T();
        }
      }
      function B() {
        if (C)
          for (var R = 0, O = m.length; R < O; ++R)
            _[R] = +z(m[R], R, m);
      }
      function T() {
        if (C)
          for (var R = 0, O = m.length; R < O; ++R)
            A[R] = +y(m[R], R, m);
      }
      return m == null && (m = []), E.initialize = function(R, ...O) {
        C = R, I = O.find((D) => typeof D == "function") || Math.random, k = O.find((D) => [1, 2, 3].includes(D)) || 2, S();
      }, E.links = function(R) {
        return arguments.length ? (m = R, S(), E) : m;
      }, E.id = function(R) {
        return arguments.length ? (N = R, E) : N;
      }, E.iterations = function(R) {
        return arguments.length ? (F = +R, E) : F;
      }, E.strength = function(R) {
        return arguments.length ? (z = typeof R == "function" ? R : s(+R), B(), E) : z;
      }, E.distance = function(R) {
        return arguments.length ? (y = typeof R == "function" ? R : s(+R), T(), E) : y;
      }, E;
    }, e.forceManyBody = function() {
      var m, _, A, C, k, M, P = s(-30), I = 1, N = 1 / 0, z = 0.81;
      function y(B) {
        var T, R = m.length, O = (_ === 1 ? n.binarytree(m, g) : _ === 2 ? r.quadtree(m, g, p) : _ === 3 ? i.octree(m, g, p, x) : null).visitAfter(E);
        for (k = B, T = 0; T < R; ++T)
          A = m[T], O.visit(S);
      }
      function F() {
        if (m) {
          var B, T, R = m.length;
          for (M = new Array(R), B = 0; B < R; ++B)
            T = m[B], M[T.index] = +P(T, B, m);
        }
      }
      function E(B) {
        var T, R, O, D, L, U, Q = 0, G = 0, V = B.length;
        if (V) {
          for (O = D = L = U = 0; U < V; ++U)
            (T = B[U]) && (R = Math.abs(T.value)) && (Q += T.value, G += R, O += R * (T.x || 0), D += R * (T.y || 0), L += R * (T.z || 0));
          Q *= Math.sqrt(4 / V), B.x = O / G, _ > 1 && (B.y = D / G), _ > 2 && (B.z = L / G);
        } else {
          (T = B).x = T.data.x, _ > 1 && (T.y = T.data.y), _ > 2 && (T.z = T.data.z);
          do
            Q += M[T.data.index];
          while (T = T.next);
        }
        B.value = Q;
      }
      function S(B, T, R, O, D) {
        if (!B.value)
          return true;
        var L = [R, O, D][_ - 1], U = B.x - A.x, Q = _ > 1 ? B.y - A.y : 0, G = _ > 2 ? B.z - A.z : 0, V = L - T, W = U * U + Q * Q + G * G;
        if (V * V / z < W)
          return W < N && (U === 0 && (W += (U = l(C)) * U), _ > 1 && Q === 0 && (W += (Q = l(C)) * Q), _ > 2 && G === 0 && (W += (G = l(C)) * G), W < I && (W = Math.sqrt(I * W)), A.vx += U * B.value * k / W, _ > 1 && (A.vy += Q * B.value * k / W), _ > 2 && (A.vz += G * B.value * k / W)), true;
        if (!(B.length || W >= N)) {
          (B.data !== A || B.next) && (U === 0 && (W += (U = l(C)) * U), _ > 1 && Q === 0 && (W += (Q = l(C)) * Q), _ > 2 && G === 0 && (W += (G = l(C)) * G), W < I && (W = Math.sqrt(I * W)));
          do
            B.data !== A && (V = M[B.data.index] * k / W, A.vx += U * V, _ > 1 && (A.vy += Q * V), _ > 2 && (A.vz += G * V));
          while (B = B.next);
        }
      }
      return y.initialize = function(B, ...T) {
        m = B, C = T.find((R) => typeof R == "function") || Math.random, _ = T.find((R) => [1, 2, 3].includes(R)) || 2, F();
      }, y.strength = function(B) {
        return arguments.length ? (P = typeof B == "function" ? B : s(+B), F(), y) : P;
      }, y.distanceMin = function(B) {
        return arguments.length ? (I = B * B, y) : Math.sqrt(I);
      }, y.distanceMax = function(B) {
        return arguments.length ? (N = B * B, y) : Math.sqrt(N);
      }, y.theta = function(B) {
        return arguments.length ? (z = B * B, y) : Math.sqrt(z);
      }, y;
    }, e.forceRadial = function(m, _, A, C) {
      var k, M, P, I, N = s(0.1);
      function z(F) {
        for (var E = 0, S = k.length; E < S; ++E) {
          var B = k[E], T = B.x - _ || 1e-6, R = (B.y || 0) - A || 1e-6, O = (B.z || 0) - C || 1e-6, D = Math.sqrt(T * T + R * R + O * O), L = (I[E] - D) * P[E] * F / D;
          B.vx += T * L, M > 1 && (B.vy += R * L), M > 2 && (B.vz += O * L);
        }
      }
      function y() {
        if (k) {
          var F, E = k.length;
          for (P = new Array(E), I = new Array(E), F = 0; F < E; ++F)
            I[F] = +m(k[F], F, k), P[F] = isNaN(I[F]) ? 0 : +N(k[F], F, k);
        }
      }
      return typeof m != "function" && (m = s(+m)), _ == null && (_ = 0), A == null && (A = 0), C == null && (C = 0), z.initialize = function(F, ...E) {
        k = F, M = E.find((S) => [1, 2, 3].includes(S)) || 2, y();
      }, z.strength = function(F) {
        return arguments.length ? (N = typeof F == "function" ? F : s(+F), y(), z) : N;
      }, z.radius = function(F) {
        return arguments.length ? (m = typeof F == "function" ? F : s(+F), y(), z) : m;
      }, z.x = function(F) {
        return arguments.length ? (_ = +F, z) : _;
      }, z.y = function(F) {
        return arguments.length ? (A = +F, z) : A;
      }, z.z = function(F) {
        return arguments.length ? (C = +F, z) : C;
      }, z;
    }, e.forceSimulation = function(m, _) {
      _ = _ || 2;
      var A, C = Math.min(3, Math.max(1, Math.round(_))), k = 1, M = 1e-3, P = 1 - Math.pow(M, 1 / 300), I = 0, N = 0.6, z = /* @__PURE__ */ new Map(), y = o.timer(S), F = a.dispatch("tick", "end"), E = function() {
        let O = 1;
        return () => (O = (1664525 * O + 1013904223) % v) / v;
      }();
      function S() {
        B(), F.call("tick", A), k < M && (y.stop(), F.call("end", A));
      }
      function B(O) {
        var D, L, U = m.length;
        O === void 0 && (O = 1);
        for (var Q = 0; Q < O; ++Q)
          for (k += (I - k) * P, z.forEach(function(G) {
            G(k);
          }), D = 0; D < U; ++D)
            (L = m[D]).fx == null ? L.x += L.vx *= N : (L.x = L.fx, L.vx = 0), C > 1 && (L.fy == null ? L.y += L.vy *= N : (L.y = L.fy, L.vy = 0)), C > 2 && (L.fz == null ? L.z += L.vz *= N : (L.z = L.fz, L.vz = 0));
        return A;
      }
      function T() {
        for (var O, D = 0, L = m.length; D < L; ++D) {
          if ((O = m[D]).index = D, O.fx != null && (O.x = O.fx), O.fy != null && (O.y = O.fy), O.fz != null && (O.z = O.fz), isNaN(O.x) || C > 1 && isNaN(O.y) || C > 2 && isNaN(O.z)) {
            var U = 10 * (C > 2 ? Math.cbrt(0.5 + D) : C > 1 ? Math.sqrt(0.5 + D) : D), Q = D * w, G = D * b;
            C === 1 ? O.x = U : C === 2 ? (O.x = U * Math.cos(Q), O.y = U * Math.sin(Q)) : (O.x = U * Math.sin(Q) * Math.cos(G), O.y = U * Math.cos(Q), O.z = U * Math.sin(Q) * Math.sin(G));
          }
          (isNaN(O.vx) || C > 1 && isNaN(O.vy) || C > 2 && isNaN(O.vz)) && (O.vx = 0, C > 1 && (O.vy = 0), C > 2 && (O.vz = 0));
        }
      }
      function R(O) {
        return O.initialize && O.initialize(m, E, C), O;
      }
      return m == null && (m = []), T(), A = { tick: B, restart: function() {
        return y.restart(S), A;
      }, stop: function() {
        return y.stop(), A;
      }, numDimensions: function(O) {
        return arguments.length ? (C = Math.min(3, Math.max(1, Math.round(O))), z.forEach(R), A) : C;
      }, nodes: function(O) {
        return arguments.length ? (m = O, T(), z.forEach(R), A) : m;
      }, alpha: function(O) {
        return arguments.length ? (k = +O, A) : k;
      }, alphaMin: function(O) {
        return arguments.length ? (M = +O, A) : M;
      }, alphaDecay: function(O) {
        return arguments.length ? (P = +O, A) : +P;
      }, alphaTarget: function(O) {
        return arguments.length ? (I = +O, A) : I;
      }, velocityDecay: function(O) {
        return arguments.length ? (N = 1 - O, A) : 1 - N;
      }, randomSource: function(O) {
        return arguments.length ? (E = O, z.forEach(R), A) : E;
      }, force: function(O, D) {
        return arguments.length > 1 ? (D == null ? z.delete(O) : z.set(O, R(D)), A) : z.get(O);
      }, find: function() {
        var O, D, L, U, Q, G, V = Array.prototype.slice.call(arguments), W = V.shift() || 0, Y = (C > 1 ? V.shift() : null) || 0, re = (C > 2 ? V.shift() : null) || 0, X = V.shift() || 1 / 0, K = 0, Ft = m.length;
        for (X *= X, K = 0; K < Ft; ++K)
          (U = (O = W - (Q = m[K]).x) * O + (D = Y - (Q.y || 0)) * D + (L = re - (Q.z || 0)) * L) < X && (G = Q, X = U);
        return G;
      }, on: function(O, D) {
        return arguments.length > 1 ? (F.on(O, D), A) : F.on(O);
      } };
    }, e.forceX = function(m) {
      var _, A, C, k = s(0.1);
      function M(I) {
        for (var N, z = 0, y = _.length; z < y; ++z)
          (N = _[z]).vx += (C[z] - N.x) * A[z] * I;
      }
      function P() {
        if (_) {
          var I, N = _.length;
          for (A = new Array(N), C = new Array(N), I = 0; I < N; ++I)
            A[I] = isNaN(C[I] = +m(_[I], I, _)) ? 0 : +k(_[I], I, _);
        }
      }
      return typeof m != "function" && (m = s(m == null ? 0 : +m)), M.initialize = function(I) {
        _ = I, P();
      }, M.strength = function(I) {
        return arguments.length ? (k = typeof I == "function" ? I : s(+I), P(), M) : k;
      }, M.x = function(I) {
        return arguments.length ? (m = typeof I == "function" ? I : s(+I), P(), M) : m;
      }, M;
    }, e.forceY = function(m) {
      var _, A, C, k = s(0.1);
      function M(I) {
        for (var N, z = 0, y = _.length; z < y; ++z)
          (N = _[z]).vy += (C[z] - N.y) * A[z] * I;
      }
      function P() {
        if (_) {
          var I, N = _.length;
          for (A = new Array(N), C = new Array(N), I = 0; I < N; ++I)
            A[I] = isNaN(C[I] = +m(_[I], I, _)) ? 0 : +k(_[I], I, _);
        }
      }
      return typeof m != "function" && (m = s(m == null ? 0 : +m)), M.initialize = function(I) {
        _ = I, P();
      }, M.strength = function(I) {
        return arguments.length ? (k = typeof I == "function" ? I : s(+I), P(), M) : k;
      }, M.y = function(I) {
        return arguments.length ? (m = typeof I == "function" ? I : s(+I), P(), M) : m;
      }, M;
    }, e.forceZ = function(m) {
      var _, A, C, k = s(0.1);
      function M(I) {
        for (var N, z = 0, y = _.length; z < y; ++z)
          (N = _[z]).vz += (C[z] - N.z) * A[z] * I;
      }
      function P() {
        if (_) {
          var I, N = _.length;
          for (A = new Array(N), C = new Array(N), I = 0; I < N; ++I)
            A[I] = isNaN(C[I] = +m(_[I], I, _)) ? 0 : +k(_[I], I, _);
        }
      }
      return typeof m != "function" && (m = s(m == null ? 0 : +m)), M.initialize = function(I) {
        _ = I, P();
      }, M.strength = function(I) {
        return arguments.length ? (k = typeof I == "function" ? I : s(+I), P(), M) : k;
      }, M.z = function(I) {
        return arguments.length ? (m = typeof I == "function" ? I : s(+I), P(), M) : m;
      }, M;
    }, Object.defineProperty(e, "__esModule", { value: true });
  }), this._handleSetAttribute = (e, n) => {
    let r = e.split("."), i = this;
    for (let a = 0; a < r.length; a++)
      i = i == null ? void 0 : i[r[a]];
    i == null ? void 0 : i(n);
  }, self.onmessage = function(e) {
    let n = false;
    if (e.data.type == "pause")
      this.simulation.stop();
    else if (e.data.type == "resume")
      this.simulation.restart();
    else if (e.data.type == "setAttribute")
      this._handleSetAttribute(e.data.attributeName, e.data.value);
    else if (e.data.type == "start") {
      let r = e.data.positions, i = e.data.edges;
      e.data.use2D && (n = true);
      let a = [], o = [];
      for (let s = 0; s < r.length / 3; s++) {
        let l = r[s * 3 + 0] * 10, h = r[s * 3 + 1] * 10, u = r[s * 3 + 2] * 10, f = 0;
        a.push({ x: l, y: h, z: u, vz: f, ID: s });
      }
      for (let s = 0; s < i.length / 2; s++) {
        let l = i[s * 2], h = i[s * 2 + 1], u = {
          source: l,
          target: h
        };
        o.push(u);
      }
      this.repulsiveforce = d3.forceManyBody(), this.attractiveforce = d3.forceLink(o), this.centralForce = d3.forceCenter(), this.simulation = d3.forceSimulation(a).numDimensions(n ? 2 : 3).force("charge", this.repulsiveforce).force("link", this.attractiveforce).force("center", centralForce).force("gravity", this.gravityForce).velocityDecay(0.05).on("tick", async () => {
        for (let s = 0; s < a.length; s++) {
          const l = a[s];
          r[s * 3 + 0] = l.x / 10, r[s * 3 + 1] = l.y / 10, n ? r[s * 3 + 2] = 0 : r[s * 3 + 2] = l.z / 10;
        }
        self.postMessage({ type: "update", positions: r });
      }).on("end", () => {
        self.postMessage({ type: "stop" });
      });
    }
  };
};
var Oo = Po.toString();
var zo = URL.createObjectURL(new Blob([`(${Oo})()`], { type: "text/javascript" }));
var Do = class {
  constructor({
    network: e = null,
    onUpdate: n = null,
    onStop: r = null,
    onStart: i = null,
    use2D: a = false
  }) {
    this._network = e, this._onUpdate = n, this._onStop = r, this._onStart = i, this._use2D = a, this._layoutWorker = null;
  }
  start() {
    var _a2;
    return this._layoutWorker || (this._layoutWorker = new Worker(zo), this._layoutWorker.onmessage = (e) => {
      var _a3, _b;
      e.data.type == "update" ? (_a3 = this._onUpdate) == null ? void 0 : _a3.call(this, e.data) : e.data.type == "stop" ? ((_b = this._onStop) == null ? void 0 : _b.call(this, e.data), this._layoutRunning = false) : e.data.type == "getAttribute" ? this._handleReturnAttribute(e.data) : console.log("Layout received Unknown msg: ", e);
    }, this._layoutRunning = true, (_a2 = this._onStart) == null ? void 0 : _a2.call(this), this._layoutWorker.postMessage({
      type: "start",
      // network: this.network,
      // nodes:this._network.nodes,
      positions: this._network.positions,
      edges: this._network.indexedEdges,
      use2D: this._use2D
    })), this;
  }
  restart() {
    return this.stop(), this.start(), this;
  }
  stop() {
    var _a2;
    return this._layoutRunning && ((_a2 = this._onStop) == null ? void 0 : _a2.call(this)), this._layoutWorker.terminate(), this._layoutRunning = false, delete this._layoutWorker, this._layoutWorker = null, this;
  }
  resume() {
    var _a2;
    return this.start(), this._layoutRunning || ((_a2 = this._onStart) == null ? void 0 : _a2.call(this)), this._layoutWorker.postMessage({ type: "resume" }), this._layoutRunning = true, this;
  }
  pause() {
    var _a2;
    return this._layoutWorker.postMessage({ type: "pause" }), this._layoutRunning = false, (_a2 = this._onStop) == null ? void 0 : _a2.call(this), this;
  }
  onUpdate(e) {
    return this._onUpdate = e, this;
  }
  onStop(e) {
    return this._onStop = e, this;
  }
  onStart(e) {
    return this._onStart = e, this;
  }
  isRunning() {
    return this._layoutRunning;
  }
  cleanup() {
    this.stop();
  }
  async _handleGetAttribute() {
  }
  setAttribute(e, n) {
    return this._layoutWorker.postMessage({
      type: "setAttribute",
      attributeName: e,
      value: n
    }), this;
  }
  groups(e) {
    return this.setAttribute("groups", e);
  }
  alpha(e) {
    return this.setAttribute("alpha", e);
  }
  alphaDecay(e) {
    return this.setAttribute("alphaDecay", e);
  }
  alphaTarget(e) {
    return this.setAttribute("alphaTarget", e);
  }
  velocityDecay(e) {
    return this.setAttribute("velocityDecay", e);
  }
};
var Tn = (
  /*glsl*/
  `
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
 
uniform float globalSizeScale;
uniform float globalSizeBase;
uniform float globalWidthScale;
uniform float globalWidthBase;

uniform float globalOpacityScale;
uniform float globalOpacityBase;

attribute vec3 fromVertex;
attribute vec3 toVertex;
attribute vec2 vertexType;
// 0,1:  0.0, 1.0, // source, top
// 0,0:  0.0, 0.0, // source, bottom
// 1,1:  1.0, 1.0, // target, top
// 1,0:  1.0, 0.0, // target, bottom

attribute vec4 fromColor;
attribute vec4 toColor;
attribute float fromSize;
attribute float toSize;
attribute vec4 encodedIndex;

varying vec4 vColor;
varying vec3 vOffset;
varying vec4 vEncodedIndex;


//varying float vZComponent;

void main(void){
	vColor = (fromColor)*vertexType.x + (toColor)*(1.0-vertexType.x);
	vColor.w = clamp(globalOpacityBase+globalOpacityScale*vColor.w,0.0,1.0);
	float updatedFromSize = globalSizeScale*fromSize+globalSizeBase;
	float updatedToSize = globalSizeScale*toSize+globalSizeBase;

	float width = globalWidthBase+globalWidthScale*((updatedFromSize)*vertexType.x + (updatedToSize)*(1.0-vertexType.x));
	vEncodedIndex = encodedIndex;
	//vZComponent = viewVertex.z;


	vec3 vertexCenter = fromVertex.xyz*vertexType.x + toVertex.xyz*(1.0-vertexType.x);
	vec3 destinationVertexCenter = fromVertex.xyz*(1.0-vertexType.x) + toVertex.xyz*vertexType.x;
	
	vec3 displacement = (viewMatrix*vec4((destinationVertexCenter-vertexCenter),0.0)).xyz;
	vec3 perpendicularVector = normalize(vec3(-displacement.y, displacement.x, 0.0));
	vec3 offset = width*(vertexType.x-0.5)*(vertexType.y-0.5)*4.0*1.5*perpendicularVector;
	
	vec4 viewVertex = viewMatrix * vec4(vertexCenter.xyz,1.0)+vec4(offset,0.0);
	float displacementLength = length(displacement);
	vOffset = vec3(vertexType.x,updatedToSize/displacementLength*1.5,updatedFromSize/displacementLength*1.5);
	

	vec4 temp_pos = projectionMatrix*viewVertex;
	// vec4 eye_vec = vec4(0.0,0.0,0.0,0);
	// float dist = length(eye_vec);
	// vec4 lookat = eye_vec - temp_pos;
	// vec4 dir = temp_pos - eye_vec;
	// vec4 center = normalize(-eye_vec);
	// vec4 proj = dot(temp_pos, normalize(-lookat)) * normalize(-lookat);
	// vec4 c = temp_pos - proj;
	// float magnitude = 1.0-acos(dot(normalize(-eye_vec), normalize(temp_pos)));

	// c = length(c) * magnitude * normalize(c);
	// vec4 dir2 = normalize(c-lookat);
	// temp_pos.xy = (dir2).xy;
	// temp_pos.z = 0.0;
	// temp_pos.w = 1.0;


	gl_Position = temp_pos;
	
}
`
);
var Nn = (
  /*glsl*/
  `
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
 
uniform float globalSizeScale;
uniform float globalSizeBase;
uniform float globalWidthScale;
uniform float globalWidthBase;

uniform float globalOpacityScale;
uniform float globalOpacityBase;

attribute vec3 fromVertex;
attribute vec3 toVertex;
attribute vec2 vertexType;
// 0,1:  0.0, 1.0, // source, top
// 0,0:  0.0, 0.0, // source, bottom
// 1,1:  1.0, 1.0, // target, top
// 1,0:  1.0, 0.0, // target, bottom

attribute vec4 fromColor;
attribute vec4 toColor;
attribute float fromSize;
attribute float toSize;
attribute vec4 encodedIndex;

varying vec4 vColor;
varying vec3 vOffset;
varying vec4 vEncodedIndex;


vec2 hyperbolicNormFactor(vec2 vertex, float scaling){
	vec2 pos = vertex.xy;
	float r = length(pos.xy);
	// //polar
	// vec2 normFactor = (r+scaling)*vec2(1.0,1.0);
	// catersian
	vec2 normFactor = sqrt(vertex.xy*vertex.xy+scaling*scaling);
	return normFactor;
}

//varying float vZComponent;

void main(void){
	vColor = (fromColor)*vertexType.x + (toColor)*(1.0-vertexType.x);
	vColor.w = clamp(globalOpacityBase+globalOpacityScale*vColor.w,0.0,1.0);
	float updatedFromSize = globalSizeScale*fromSize+globalSizeBase;
	float updatedToSize = globalSizeScale*toSize+globalSizeBase;

	float width = globalWidthBase+globalWidthScale*((updatedFromSize)*vertexType.x + (updatedToSize)*(1.0-vertexType.x));
	vEncodedIndex = encodedIndex;
	//vZComponent = viewVertex.z;

	float scaling = -viewMatrix[3][2];
	
	vec4 fromVertexView = viewMatrix * vec4(fromVertex.xyz,1.0);
	vec4 toVertexView = viewMatrix * vec4(toVertex.xyz,1.0);

	vec2 normFactorFrom = hyperbolicNormFactor(fromVertexView.xy, scaling);
	vec2 normFactorTo = hyperbolicNormFactor(toVertexView.xy, scaling);
	
	vec3 vertexCenter = fromVertexView.xyz*vertexType.x + toVertexView.xyz*(1.0-vertexType.x);
	vec3 destinationVertexCenter = fromVertexView.xyz*(1.0-vertexType.x) + toVertexView.xyz*vertexType.x;

	vec2 normFactorCenter = hyperbolicNormFactor(vertexCenter.xy, scaling);
	vec2 normFactorDestinationCenter = hyperbolicNormFactor(destinationVertexCenter.xy, scaling);

	fromVertexView.xy = fromVertexView.xy/normFactorFrom/vec2(projectionMatrix[0][0],projectionMatrix[1][1]);
	toVertexView.xy = toVertexView.xy/normFactorTo/vec2(projectionMatrix[0][0],projectionMatrix[1][1]);
	vertexCenter.xy = vertexCenter.xy/normFactorCenter/vec2(projectionMatrix[0][0],projectionMatrix[1][1]);
	destinationVertexCenter.xy = destinationVertexCenter.xy/normFactorDestinationCenter/vec2(projectionMatrix[0][0],projectionMatrix[1][1]);

	vec3 displacement = vec4((destinationVertexCenter-vertexCenter),0.0).xyz;
	vec3 perpendicularVector = normalize(vec3(-displacement.y, displacement.x, 0.0));
	vec3 offset = width*(vertexType.x-0.5)*(vertexType.y-0.5)*4.0*1.0*perpendicularVector/length(normFactorCenter)*scaling;
	
	vec4 viewVertex = vec4(vertexCenter.xyz,1.0)+vec4(offset,0.0);
	float displacementLength = length(displacement);
	// vOffset = vec3(vertexType.x,updatedToSize/displacementLength*1.0,updatedFromSize/displacementLength*1.0);
	vOffset = vec3(0.0,0.0,0.0);
	viewVertex.zw = vec2(0.0,1.0);
	vec4 temp_pos = projectionMatrix*viewVertex;
	gl_Position = temp_pos;
}
`
);
var Lo = (
  /*glsl*/
  `
#ifdef GL_ES
	precision highp float;
#endif
//uniform vec2 nearFar;
varying vec4 vEncodedIndex;
varying vec4 vColor;
varying vec3 vOffset;
//varying float vZComponent;
//gl_DepthRange.near)/gl_DepthRange.diff
void main(){
	//float w = (-vZComponent-nearFar[0])/(nearFar[1]-nearFar[0]);
	if(vOffset.x<vOffset.y || vOffset.x>(1.0-vOffset.z)){
		discard;
	}

	// gl_FragColor = vec4(vOffset.x,vOffset.x,0,1.0);//vec4(vColor.xyz,globalOpacity*vColor.w);
	gl_FragColor = vColor;
}
`
);
var Uo = (
  /*glsl*/
  `
#ifdef GL_ES
	precision highp float;
#endif
//uniform vec2 nearFar;
varying vec4 vEncodedIndex;
varying vec4 vColor;
varying vec3 vOffset;
//varying float vZComponent;
//gl_DepthRange.near)/gl_DepthRange.diff
void main(){

	if(vOffset.x<vOffset.y*1.1 || vOffset.x>(1.0-vOffset.z*1.1) || (vEncodedIndex.x+vEncodedIndex.y+vEncodedIndex.z+vEncodedIndex.w)<=0.0){
		discard;
	}
	//float w = (-vZComponent-nearFar[0])/(nearFar[1]-nearFar[0]);
	gl_FragColor = vEncodedIndex;
	
}
`
);
var Qo = (
  /*glsl*/
  `
uniform mat4 projectionViewMatrix;
uniform float globalOpacityScale;
uniform float globalOpacityBase;

attribute vec3 vertex;
attribute vec4 color;


varying vec4 vColor;
varying vec4 vEncodedIndex;

//varying float vZComponent;

void main(void){
	vColor = color;
	vColor.w = clamp(globalOpacityBase+globalOpacityScale*vColor.w,0.0,1.0);
	//vZComponent = viewVertex.z;
	gl_Position =   projectionViewMatrix * vec4(vertex,1.0);
}
`
);
var Go = (
  /*glsl*/
  `
uniform mat4 projectionViewMatrix;
uniform float globalOpacityScale;
uniform float globalOpacityBase;

attribute vec3 vertex;
attribute vec4 color;


varying vec4 vColor;
varying vec4 vEncodedIndex;

//varying float vZComponent;

void main(void){
	vColor = color;
	vColor.w = clamp(globalOpacityBase+globalOpacityScale*vColor.w,0.0,1.0);
	//vZComponent = viewVertex.z;

	vec4 temp_pos = projectionViewMatrix * vec4(vertex,1.0);
	vec4 eye_vec = vec4(0.0,0.0,1.0,0);
	float dist = length(eye_vec);
	vec4 lookat = eye_vec - temp_pos;
	vec4 dir = temp_pos - eye_vec;
	vec4 center = normalize(-eye_vec);
	vec4 proj = dot(temp_pos, normalize(-lookat)) * normalize(-lookat);
	vec4 c = temp_pos - proj;
	float magnitude = 1.0-acos(dot(normalize(-eye_vec), normalize(temp_pos)));

	c = length(c) * magnitude * normalize(c);
	vec4 dir2 = normalize(c-lookat);
	temp_pos.xy = (dir2).xy;
	temp_pos.z = 0.0;
	temp_pos.w = 1.0;
	gl_Position = temp_pos;
}
`
);
var Vo = (
  /*glsl*/
  `
#ifdef GL_ES
	precision highp float;
#endif
//uniform vec2 nearFar;
varying vec4 vColor;
//varying float vZComponent;
//gl_DepthRange.near)/gl_DepthRange.diff
void main(){
	//float w = (-vZComponent-nearFar[0])/(nearFar[1]-nearFar[0]);
	gl_FragColor = vColor;
	// gl_FragColor = vec4(vEncodedIndex.x/10,0,0,1.0);
}

`
);
var Pt = (
  /*glsl*/
  `
// uniform mat4 projectionMatrix;
// uniform mat4 viewMatrix;
// uniform mat3 normalMatrix;


// attribute vec4 vertex;
// attribute vec3 normal;
// attribute vec3 position;
// attribute vec3 color;
// attribute float size;
// attribute float Opacity;

// varying vec3 vNormal;
// varying vec3 vEye;

// varying vec3 vColor;
// varying float vSize;
// varying float vOpacity;

// void main(void){
// 	vec4 viewVertex = viewMatrix * (vertex*vec4(vec3(size),1.0) + vec4(position,0.0));
// 	vNormal = normalMatrix * normal;
// 	vEye = -vec3(viewVertex);
// 	vOpacity = Opacity;
// 	vColor = color;
// 	gl_Position =   projectionMatrix * viewVertex;
// }

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

uniform float globalOpacityScale;
uniform float globalSizeScale;
uniform float globalOutlineWidthScale;

uniform float globalOpacityBase;
uniform float globalSizeBase;
uniform float globalOutlineWidthBase;

attribute vec2 vertex;
// attribute vec3 normal;
attribute vec3 position;
attribute vec4 color;
attribute float size;
attribute float outlineWidth;
attribute vec4 outlineColor;
attribute vec4 encodedIndex;

varying vec3 vNormal;
varying vec3 vEye;
varying vec4 vColor;
varying vec2 vOffset;
varying float vSize;
varying vec4 vEncodedIndex;
varying float vOutlineThreshold;
varying vec4 vOutlineColor;
varying vec4 vPosition;

void main(void){
	float BoxCorrection = 1.5;
	vec2 offset = vertex;
	float updatedSize = globalSizeScale*size+globalSizeBase;
	float updatedOutlineWidth = globalOutlineWidthScale*outlineWidth+globalOutlineWidthBase;
	float fullSize = updatedSize + updatedOutlineWidth;
	// vec4 viewCenters = viewMatrix*vec4(position,1);
	// vec3 viewCenters = position;
	// fragCenter = viewCenters
	// float scalingFactor = 1.0 / abs(centers.x)*0.001;
	// offset*=scalingFactor;
	vec3 cameraRight = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
	vec3 cameraUp = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));

	// viewCenters.xy += offset*updatedSize*CameraRight_worldspace;
	
	vec4 viewCenters = viewMatrix*vec4(position+BoxCorrection*fullSize*(cameraRight*offset.x + cameraUp*offset.y),1.0);
	vNormal = vec3(0.0,0.0,1.0); //normalMatrix * normal;
	vEye = -vec3(offset,0.0);
	vEncodedIndex = encodedIndex;
	vColor = color;
	vColor.w = clamp(globalOpacityBase+globalOpacityScale*vColor.w,0.0,1.0);
	vOutlineColor.w = clamp(globalOpacityBase+globalOpacityScale*vOutlineColor.w,0.0,1.0);
	vOffset = vertex;
	vSize = updatedSize;
	vOutlineThreshold = updatedOutlineWidth/fullSize;

	vOutlineColor = outlineColor;
	vPosition = projectionMatrix * viewCenters;

	// vec4 temp_pos = vPosition;
	// vec4 eye_vec = vec4(0.0,0.0,0.0,0);
	// float dist = length(eye_vec);
	// vec4 lookat = eye_vec - temp_pos;
	// vec4 dir = temp_pos - eye_vec;
	// vec4 center = normalize(-eye_vec);
	// vec4 proj = dot(temp_pos, normalize(-lookat)) * normalize(-lookat);
	// vec4 c = temp_pos - proj;
	// float magnitude = 1.0-acos(dot(normalize(-eye_vec), normalize(temp_pos)));

	// c = length(c) * magnitude * normalize(c);
	// vec4 dir2 = normalize(c-lookat);
	// vPosition.xy = (dir2).xy;
	// vPosition.z = 0.0;
	// vPosition.w = 1.0;
	gl_Position = vPosition;
}
`
);
var Ot = (
  /*glsl*/
  `
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

uniform float globalOpacityScale;
uniform float globalSizeScale;
uniform float globalOutlineWidthScale;

uniform float globalOpacityBase;
uniform float globalSizeBase;
uniform float globalOutlineWidthBase;

attribute vec2 vertex;
// attribute vec3 normal;
attribute vec3 position;
attribute vec4 color;
attribute float size;
attribute float outlineWidth;
attribute vec4 outlineColor;
attribute vec4 encodedIndex;

varying vec3 vNormal;
varying vec3 vEye;
varying vec4 vColor;
varying vec2 vOffset;
varying float vSize;
varying vec4 vEncodedIndex;
varying float vOutlineThreshold;
varying vec4 vOutlineColor;
varying vec4 vPosition;

vec2 hyperbolicNormFactor(vec2 vertex, float scaling){
	vec2 pos = vertex.xy;
	float r = length(pos.xy);
	// //polar
	// vec2 normFactor = (r+scaling)*vec2(1.0,1.0);
	// catersian
	vec2 normFactor = sqrt(vertex.xy*vertex.xy+scaling*scaling);
	return normFactor;
}

void main(void){
	float BoxCorrection = 1.5;
	vec2 offset = vertex;
	float updatedSize = globalSizeScale*size+globalSizeBase;
	float updatedOutlineWidth = globalOutlineWidthScale*outlineWidth+globalOutlineWidthBase;
	float fullSize = updatedSize + updatedOutlineWidth;
	// vec4 viewCenters = viewMatrix*vec4(position,1);
	// vec3 viewCenters = position;
	// fragCenter = viewCenters
	// float scalingFactor = 1.0 / abs(centers.x)*0.001;
	// offset*=scalingFactor;
	vec3 cameraRight = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
	vec3 cameraUp = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));

	// viewCenters.xy += offset*updatedSize*CameraRight_worldspace;
	


	// temp_pos.z = 0.0;
	// temp_pos.w = 1.0;



	vec4 viewCenters = viewMatrix*vec4(position.xyz,1.0);
	float scaling = -viewMatrix[3][2];
	vec4 temp_pos = viewCenters;
	
	vec2 normFactor = hyperbolicNormFactor(viewCenters.xy, scaling);
	// catersian
	// vec2 normFactor = sqrt(temp_pos.xy*temp_pos.xy+scaling*scaling);
	temp_pos.xy = temp_pos.xy/normFactor;

	viewCenters.xy = temp_pos.xy/vec2(projectionMatrix[0][0],projectionMatrix[1][1]);
	viewCenters.xy+=BoxCorrection*fullSize*offset.xy/length(normFactor)*scaling;
	

	vNormal = vec3(0.0,0.0,1.0); //normalMatrix * normal;
	vEye = -vec3(offset,0.0);
	vEncodedIndex = encodedIndex;
	vColor = color;
	vColor.w = clamp(globalOpacityBase+globalOpacityScale*vColor.w,0.0,1.0);
	vOutlineColor.w = clamp(globalOpacityBase+globalOpacityScale*vOutlineColor.w,0.0,1.0);
	vOffset = vertex;
	vSize = updatedSize;
	vOutlineThreshold = updatedOutlineWidth/fullSize;

	vOutlineColor = outlineColor;
	vPosition = projectionMatrix * viewCenters;

	gl_Position = vPosition;
}
`
);
var Wo = (
  /*glsl*/
  `// #ifdef GL_ES
// 	precision highp float;
// #endif

precision mediump float;
varying vec4 vColor;
varying vec4 vEncodedIndex;
varying vec3 vNormal;
varying vec3 vEye;
varying float vSize;
varying vec2 vOffset;
varying float vOutlineThreshold;
varying vec4 vOutlineColor;
varying vec4 vPosition;



void main(){
	// const vec3 lightDirection = vec3(0.577350269,0.577350269,0.577350269);
	// const float ambientFactor = 0.6;
	
	// vec3 normal = normalize(vNormal);
	// vec3 eye = normalize(vEye);
	
	// //Ambient+Diffuse
	// float cosTheta = max(dot(lightDirection,normal),0.0);
	// vec3 newColor = vColor*(ambientFactor+cosTheta);
	
	// //Specular
	// vec3 reflection = reflect(-lightDirection, normal);
	// float eyeDotReflection = max(dot(eye, reflection), 0.0);
	// newColor +=  vec3(0.5)* pow(eyeDotReflection, 60.0);
	
	// gl_FragColor = vec4(newColor,vOpacity);
	// gl_FragColor = vec4(eye,Opacity);
	//gl_FragData[0] = vec4(newColor,Opacity);

// Renaming variables passed from the Vertex Shader

	// vec3 cameraPos;
	// vec3 cameraNormal;

	// float lensqr = dot(vOffset, vOffset);

	// if(lensqr > 1.0)
	// 		discard;
		
	// cameraNormal = vec3(vOffset, sqrt(1.0 - lensqr));
	// cameraPos = (cameraNormal * size) + cameraSpherePos;

	// float len = length(point);
	// // VTK Fake Spheres
	// float radius = 1.;
	// if(len > radius)
	// 		discard;
	// vec3 normalizedPoint = normalize(vec3(point.xy, sqrt(1. - len)));
	// vec3 direction = normalize(vec3(1., 1., 1.));
	// float df2 = max(0, dot(direction, normalizedPoint));
	// float sf2 = pow(df2, 90);
	// fragOutput0 = vec4(max((df2+0.3) * color, sf2 * vec3(1)), 1);

	// fragOutput1 = vec4(vertexVC.xyz, 1.0);
	// fragOutput2 = vec4(normalVCVSOutput, 1.0);
	
	float lensqr = dot(vOffset, vOffset);

	if(lensqr > 1.0)
		discard;
	

	vec3 normalizedPoint = normalize(vec3(vOffset.xy, sqrt(1. - lensqr)));
	const vec3 lightDirection = vec3(0.577350269,0.577350269,0.577350269);
	const float ambientFactor = 0.6;
	
	vec3 normal = normalizedPoint;
	vec3 eye = normalize(vEye);
	
	//Ambient+Diffuse
	float cosTheta = max(dot(lightDirection,normal),0.0);
	vec3 newColor = vColor.xyz*(ambientFactor+cosTheta);
	
	//Specular
	vec3 reflection = reflect(-lightDirection, normal);
	float eyeDotReflection = max(dot(eye, reflection), 0.0);
	newColor +=  vec3(0.5)* pow(eyeDotReflection, 60.0);
	
	
	
	if(lensqr < 1.0-vOutlineThreshold){
		// gl_FragColor = vec4(vColor,vOpacity)
		gl_FragColor = vec4(newColor,vColor.w);;
	}else{
		gl_FragColor = vec4(vOutlineColor.xyz,vOutlineColor.w);
	}
	// gl_FragDepthEXT = 0.5; 
}
`
);
var Ho = (
  /*glsl*/
  `
// #ifdef GL_ES
// 	precision highp float;
// #endif

precision mediump float;
varying vec4 vColor;
varying vec4 vEncodedIndex;
varying vec3 vNormal;
varying vec3 vEye;
varying float vSize;
varying vec2 vOffset;
varying float vOutlineThreshold;
varying vec4 vOutlineColor;

void main(){
	float lensqr = dot(vOffset, vOffset);

	if(lensqr > 1.0)
			discard;
	
	gl_FragColor = vEncodedIndex;
}
`
);
var Yo = (
  /*glsl*/
  `
// #ifdef GL_ES
// 	precision highp float;
// #endif

precision mediump float;
varying vec4 vColor;
varying vec4 vEncodedIndex;
varying vec3 vNormal;
varying vec3 vEye;
varying float vSize;
varying vec2 vOffset;
varying float vOutlineThreshold;
varying vec4 vOutlineColor;
varying vec4 vPosition;



void main(){
	
	float lensqr = dot(vOffset, vOffset);

	if(lensqr > 1.0)
			discard;
	
	if(lensqr < 1.0-vOutlineThreshold){
		// gl_FragColor = vec4(vColor,vOpacity)
		gl_FragColor = vColor;
	}else{
		gl_FragColor = vOutlineColor;
	}
	// gl_FragDepthEXT = 0.5; 
}
`
);
var st = {};
var xt = {};
var Ye = {};
Object.defineProperty(Ye, "__esModule", {
  value: true
});
var qo = function() {
  function t4(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t4(e.prototype, n), r && t4(e, r), e;
  };
}();
function Xo(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var Pn = Ye.LinkedList = function() {
  function t4() {
    Xo(this, t4), this.length = 0, this.first = null, this.last = null;
  }
  return qo(t4, [{
    key: "forEach",
    value: function(n, r) {
      for (var i = this.first, a = this.length, o = 0; o < a; o++)
        n.call(r, i, o), i = i.next;
    }
  }, {
    key: "at",
    value: function(n) {
      if (!(n >= 0 && n < this.length))
        return null;
      for (var r = this.first; n--; )
        r = r.next;
      return r;
    }
  }, {
    key: "randomNode",
    value: function() {
      var n = Math.floor(Math.random() * this.length);
      return this.at(n);
    }
  }, {
    key: "toArray",
    value: function() {
      for (var n = [], r = this.first, i = this.length; i--; )
        n.push(r.data || r), r = r.next;
      return n;
    }
  }]), t4;
}();
Pn.prototype.each = Pn.prototype.forEach;
Object.defineProperty(xt, "__esModule", {
  value: true
});
xt.CircularLinkedList = void 0;
var jo = function() {
  function t4(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t4(e.prototype, n), r && t4(e, r), e;
  };
}();
var _r = Ye;
function $o(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Zo(t4, e) {
  if (!t4)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t4;
}
function Ko(t4, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t4.prototype = Object.create(e && e.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t4, e) : t4.__proto__ = e);
}
var On = xt.CircularLinkedList = function(t4) {
  Ko(e, t4);
  function e() {
    return $o(this, e), Zo(this, Object.getPrototypeOf(e).apply(this, arguments));
  }
  return jo(e, [{
    key: "append",
    value: function(r) {
      this.first === null ? (r.prev = r, r.next = r, this.first = r, this.last = r) : (r.prev = this.last, r.next = this.first, this.first.prev = r, this.last.next = r, this.last = r), this.length++;
    }
  }, {
    key: "prepend",
    value: function(r) {
      if (this.first === null) {
        this.append(r);
        return;
      } else
        r.prev = this.last, r.next = this.first, this.first.prev = r, this.last.next = r, this.first = r;
      this.length++;
    }
  }, {
    key: "insertAfter",
    value: function(r, i) {
      i.prev = r, i.next = r.next, r.next.prev = i, r.next = i, i.prev === this.last && (this.last = i), this.length++;
    }
  }, {
    key: "insertBefore",
    value: function(r, i) {
      i.prev = r.prev, i.next = r, r.prev.next = i, r.prev = i, i.next === this.first && (this.first = i), this.length++;
    }
  }, {
    key: "remove",
    value: function(r) {
      this.length > 1 ? (r.prev.next = r.next, r.next.prev = r.prev, r === this.first && (this.first = r.next), r === this.last && (this.last = r.prev)) : (this.first = null, this.last = null), r.prev = null, r.next = null, this.length--;
    }
  }, {
    key: "withData",
    value: function(r) {
      for (var i = this.first, a = this.last, o = Math.ceil(this.length / 2); o--; ) {
        if (i.data === r)
          return i;
        if (a.data === r)
          return a;
        i = i.next, a = a.prev;
      }
      return null;
    }
  }]), e;
}(_r.LinkedList);
On.fromArray = function(t4, e) {
  for (var n = new On(), r = t4.length; r--; )
    n.prepend(e ? new _r.LinkedList.Node(t4[r]) : t4[r]);
  return n;
};
var Se = {};
var fe = {};
Object.defineProperty(fe, "__esModule", {
  value: true
});
fe.PRECISION = 1e-6;
var Te = {};
var Ne = {};
var zn;
function Be() {
  if (zn)
    return Ne;
  zn = 1, Object.defineProperty(Ne, "__esModule", {
    value: true
  }), Ne.Matrix = void 0;
  var t4 = function() {
    function a(o, s) {
      for (var l = 0; l < s.length; l++) {
        var h = s[l];
        h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(o, h.key, h);
      }
    }
    return function(o, s, l) {
      return s && a(o.prototype, s), l && a(o, l), o;
    };
  }(), e = fe, n = ge();
  function r(a, o) {
    if (!(a instanceof o))
      throw new TypeError("Cannot call a class as a function");
  }
  var i = Ne.Matrix = function() {
    function a(o) {
      r(this, a), this.setElements(o);
    }
    return t4(a, [{
      key: "e",
      value: function(s, l) {
        return s < 1 || s > this.elements.length || l < 1 || l > this.elements[0].length ? null : this.elements[s - 1][l - 1];
      }
    }, {
      key: "row",
      value: function(s) {
        return s > this.elements.length ? null : new n.Vector(this.elements[s - 1]);
      }
    }, {
      key: "col",
      value: function(s) {
        if (this.elements.length === 0 || s > this.elements[0].length)
          return null;
        for (var l = [], h = this.elements.length, u = 0; u < h; u++)
          l.push(this.elements[u][s - 1]);
        return new n.Vector(l);
      }
    }, {
      key: "dimensions",
      value: function() {
        var s = this.elements.length === 0 ? 0 : this.elements[0].length;
        return { rows: this.elements.length, cols: s };
      }
    }, {
      key: "rows",
      value: function() {
        return this.elements.length;
      }
    }, {
      key: "cols",
      value: function() {
        return this.elements.length === 0 ? 0 : this.elements[0].length;
      }
    }, {
      key: "eql",
      value: function(s) {
        var l = s.elements || s;
        if ((!l[0] || typeof l[0][0] > "u") && (l = new a(l).elements), this.elements.length === 0 || l.length === 0)
          return this.elements.length === l.length;
        if (this.elements.length !== l.length || this.elements[0].length !== l[0].length)
          return false;
        for (var h = this.elements.length, u = this.elements[0].length, f; h--; )
          for (f = u; f--; )
            if (Math.abs(this.elements[h][f] - l[h][f]) > e.PRECISION)
              return false;
        return true;
      }
    }, {
      key: "dup",
      value: function() {
        return new a(this.elements);
      }
    }, {
      key: "map",
      value: function(s, l) {
        if (this.elements.length === 0)
          return new a([]);
        for (var h = [], u = this.elements.length, f = this.elements[0].length, c; u--; )
          for (c = f, h[u] = []; c--; )
            h[u][c] = s.call(l, this.elements[u][c], u + 1, c + 1);
        return new a(h);
      }
    }, {
      key: "isSameSizeAs",
      value: function(s) {
        var l = s.elements || s;
        return typeof l[0][0] > "u" && (l = new a(l).elements), this.elements.length === 0 ? l.length === 0 : this.elements.length === l.length && this.elements[0].length === l[0].length;
      }
    }, {
      key: "add",
      value: function(s) {
        if (this.elements.length === 0)
          return this.map(function(h) {
            return h;
          });
        var l = s.elements || s;
        return typeof l[0][0] > "u" && (l = new a(l).elements), this.isSameSizeAs(l) ? this.map(function(h, u, f) {
          return h + l[u - 1][f - 1];
        }) : null;
      }
    }, {
      key: "subtract",
      value: function(s) {
        if (this.elements.length === 0)
          return this.map(function(h) {
            return h;
          });
        var l = s.elements || s;
        return typeof l[0][0] > "u" && (l = new a(l).elements), this.isSameSizeAs(l) ? this.map(function(h, u, f) {
          return h - l[u - 1][f - 1];
        }) : null;
      }
    }, {
      key: "canMultiplyFromLeft",
      value: function(s) {
        if (this.elements.length === 0)
          return false;
        var l = s.elements || s;
        return typeof l[0][0] > "u" && (l = new a(l).elements), this.elements[0].length === l.length;
      }
    }, {
      key: "multiply",
      value: function(s) {
        if (this.elements.length === 0)
          return null;
        if (!s.elements)
          return this.map(function(x) {
            return x * s;
          });
        var l = !!s.modulus, p = s.elements || s;
        if (typeof p[0][0] > "u" && (p = new a(p).elements), !this.canMultiplyFromLeft(p))
          return null;
        for (var h = this.elements.length, u = p[0].length, f, c = this.elements[0].length, d, v = [], g; h--; )
          for (f = u, v[h] = []; f--; ) {
            for (d = c, g = 0; d--; )
              g += this.elements[h][d] * p[d][f];
            v[h][f] = g;
          }
        var p = new a(v);
        return l ? p.col(1) : p;
      }
    }, {
      key: "minor",
      value: function(s, l, h, u) {
        if (this.elements.length === 0)
          return null;
        for (var f = [], c = h, d, v, g, p = this.elements.length, x = this.elements[0].length; c--; )
          for (d = h - c - 1, f[d] = [], v = u; v--; )
            g = u - v - 1, f[d][g] = this.elements[(s + d - 1) % p][(l + g - 1) % x];
        return new a(f);
      }
    }, {
      key: "transpose",
      value: function() {
        if (this.elements.length === 0)
          return new a([]);
        for (var s = this.elements.length, f, l = this.elements[0].length, h, u = [], f = l; f--; )
          for (h = s, u[f] = []; h--; )
            u[f][h] = this.elements[h][f];
        return new a(u);
      }
    }, {
      key: "isSquare",
      value: function() {
        var s = this.elements.length === 0 ? 0 : this.elements[0].length;
        return this.elements.length === s;
      }
    }, {
      key: "max",
      value: function() {
        if (this.elements.length === 0)
          return null;
        for (var s = 0, l = this.elements.length, h = this.elements[0].length, u; l--; )
          for (u = h; u--; )
            Math.abs(this.elements[l][u]) > Math.abs(s) && (s = this.elements[l][u]);
        return s;
      }
    }, {
      key: "indexOf",
      value: function(s) {
        if (this.elements.length === 0)
          return null;
        var l = this.elements.length, h, u = this.elements[0].length, f;
        for (h = 0; h < l; h++)
          for (f = 0; f < u; f++)
            if (this.elements[h][f] === s)
              return {
                i: h + 1,
                j: f + 1
              };
        return null;
      }
    }, {
      key: "diagonal",
      value: function() {
        if (!this.isSquare)
          return null;
        for (var s = [], l = this.elements.length, h = 0; h < l; h++)
          s.push(this.elements[h][h]);
        return new n.Vector(s);
      }
    }, {
      key: "toRightTriangular",
      value: function() {
        if (this.elements.length === 0)
          return new a([]);
        var s = this.dup(), l, h = this.elements.length, u, f, c = this.elements[0].length, d;
        for (u = 0; u < h; u++) {
          if (s.elements[u][u] === 0) {
            for (f = u + 1; f < h; f++)
              if (s.elements[f][u] !== 0) {
                for (l = [], d = 0; d < c; d++)
                  l.push(s.elements[u][d] + s.elements[f][d]);
                s.elements[u] = l;
                break;
              }
          }
          if (s.elements[u][u] !== 0)
            for (f = u + 1; f < h; f++) {
              var v = s.elements[f][u] / s.elements[u][u];
              for (l = [], d = 0; d < c; d++)
                l.push(d <= u ? 0 : s.elements[f][d] - s.elements[u][d] * v);
              s.elements[f] = l;
            }
        }
        return s;
      }
    }, {
      key: "determinant",
      value: function() {
        if (this.elements.length === 0)
          return 1;
        if (!this.isSquare())
          return null;
        for (var s = this.toRightTriangular(), l = s.elements[0][0], h = s.elements.length, u = 1; u < h; u++)
          l = l * s.elements[u][u];
        return l;
      }
    }, {
      key: "isSingular",
      value: function() {
        return this.isSquare() && this.determinant() === 0;
      }
    }, {
      key: "trace",
      value: function() {
        if (this.elements.length === 0)
          return 0;
        if (!this.isSquare())
          return null;
        for (var s = this.elements[0][0], l = this.elements.length, h = 1; h < l; h++)
          s += this.elements[h][h];
        return s;
      }
    }, {
      key: "rank",
      value: function() {
        if (this.elements.length === 0)
          return 0;
        for (var s = this.toRightTriangular(), l = 0, h = this.elements.length, u = this.elements[0].length, f; h--; )
          for (f = u; f--; )
            if (Math.abs(s.elements[h][f]) > e.PRECISION) {
              l++;
              break;
            }
        return l;
      }
    }, {
      key: "augment",
      value: function(s) {
        if (this.elements.length === 0)
          return this.dup();
        var l = s.elements || s;
        typeof l[0][0] > "u" && (l = new a(l).elements);
        var h = this.dup(), u = h.elements[0].length, f = h.elements.length, c = l[0].length, d;
        if (f !== l.length)
          return null;
        for (; f--; )
          for (d = c; d--; )
            h.elements[f][u + d] = l[f][d];
        return h;
      }
    }, {
      key: "inverse",
      value: function() {
        if (this.elements.length === 0 || !this.isSquare() || this.isSingular())
          return null;
        for (var s = this.elements.length, l = s, h, u = this.augment(a.I(s)).toRightTriangular(), f = u.elements[0].length, c, d, v, g = [], p; l--; ) {
          for (d = [], g[l] = [], v = u.elements[l][l], c = 0; c < f; c++)
            p = u.elements[l][c] / v, d.push(p), c >= s && g[l].push(p);
          for (u.elements[l] = d, h = l; h--; ) {
            for (d = [], c = 0; c < f; c++)
              d.push(u.elements[h][c] - u.elements[l][c] * u.elements[h][l]);
            u.elements[h] = d;
          }
        }
        return new a(g);
      }
    }, {
      key: "round",
      value: function() {
        return this.map(function(s) {
          return Math.round(s);
        });
      }
    }, {
      key: "snapTo",
      value: function(s) {
        return this.map(function(l) {
          return Math.abs(l - s) <= e.PRECISION ? s : l;
        });
      }
    }, {
      key: "inspect",
      value: function() {
        var s = [], l = this.elements.length;
        if (l === 0)
          return "[]";
        for (var h = 0; h < l; h++)
          s.push(new n.Vector(this.elements[h]).inspect());
        return s.join(`
`);
      }
    }, {
      key: "setElements",
      value: function(s) {
        var l, h, u = s.elements || s;
        if (u[0] && typeof u[0][0] < "u") {
          for (l = u.length, this.elements = []; l--; )
            for (h = u[l].length, this.elements[l] = []; h--; )
              this.elements[l][h] = u[l][h];
          return this;
        }
        var f = u.length;
        for (this.elements = [], l = 0; l < f; l++)
          this.elements.push([u[l]]);
        return this;
      }
      //From glUtils.js
    }, {
      key: "flatten",
      value: function() {
        var s = [];
        if (this.elements.length == 0)
          return [];
        for (var l = 0; l < this.elements[0].length; l++)
          for (var h = 0; h < this.elements.length; h++)
            s.push(this.elements[h][l]);
        return s;
      }
      //From glUtils.js
    }, {
      key: "ensure4x4",
      value: function() {
        if (this.elements.length == 4 && this.elements[0].length == 4)
          return this;
        if (this.elements.length > 4 || this.elements[0].length > 4)
          return null;
        for (var s = 0; s < this.elements.length; s++)
          for (var l = this.elements[s].length; l < 4; l++)
            s == l ? this.elements[s].push(1) : this.elements[s].push(0);
        for (var s = this.elements.length; s < 4; s++)
          s == 0 ? this.elements.push([1, 0, 0, 0]) : s == 1 ? this.elements.push([0, 1, 0, 0]) : s == 2 ? this.elements.push([0, 0, 1, 0]) : s == 3 && this.elements.push([0, 0, 0, 1]);
        return this;
      }
      //From glUtils.js
    }, {
      key: "make3x3",
      value: function() {
        return this.elements.length != 4 || this.elements[0].length != 4 ? null : new a([[this.elements[0][0], this.elements[0][1], this.elements[0][2]], [this.elements[1][0], this.elements[1][1], this.elements[1][2]], [this.elements[2][0], this.elements[2][1], this.elements[2][2]]]);
      }
    }]), a;
  }();
  return i.I = function(a) {
    for (var o = [], s = a, l; s--; )
      for (l = a, o[s] = []; l--; )
        o[s][l] = s === l ? 1 : 0;
    return new i(o);
  }, i.Diagonal = function(a) {
    for (var o = a.length, s = i.I(o); o--; )
      s.elements[o][o] = a[o];
    return s;
  }, i.Rotation = function(a, o) {
    if (!o)
      return new i([[Math.cos(a), -Math.sin(a)], [Math.sin(a), Math.cos(a)]]);
    var s = o.dup();
    if (s.elements.length !== 3)
      return null;
    var l = s.modulus(), h = s.elements[0] / l, u = s.elements[1] / l, f = s.elements[2] / l, c = Math.sin(a), d = Math.cos(a), v = 1 - d;
    return new i([[v * h * h + d, v * h * u - c * f, v * h * f + c * u], [v * h * u + c * f, v * u * u + d, v * u * f - c * h], [v * h * f - c * u, v * u * f + c * h, v * f * f + d]]);
  }, i.RotationX = function(a) {
    var o = Math.cos(a), s = Math.sin(a);
    return new i([[1, 0, 0], [0, o, -s], [0, s, o]]);
  }, i.RotationY = function(a) {
    var o = Math.cos(a), s = Math.sin(a);
    return new i([[o, 0, s], [0, 1, 0], [-s, 0, o]]);
  }, i.RotationZ = function(a) {
    var o = Math.cos(a), s = Math.sin(a);
    return new i([[o, -s, 0], [s, o, 0], [0, 0, 1]]);
  }, i.Random = function(a, o) {
    return i.Zero(a, o).map(function() {
      return Math.random();
    });
  }, i.Translation = function(a) {
    if (a.elements.length == 2) {
      var o = i.I(3);
      return o.elements[2][0] = a.elements[0], o.elements[2][1] = a.elements[1], o;
    }
    if (a.elements.length == 3) {
      var o = i.I(4);
      return o.elements[0][3] = a.elements[0], o.elements[1][3] = a.elements[1], o.elements[2][3] = a.elements[2], o;
    }
    throw "Invalid length for Translation";
  }, i.Zero = function(a, o) {
    for (var s = [], l = a, h; l--; )
      for (h = o, s[l] = []; h--; )
        s[l][h] = 0;
    return new i(s);
  }, i.prototype.toUpperTriangular = i.prototype.toRightTriangular, i.prototype.det = i.prototype.determinant, i.prototype.tr = i.prototype.trace, i.prototype.rk = i.prototype.rank, i.prototype.inv = i.prototype.inverse, i.prototype.x = i.prototype.multiply, Ne;
}
var Dn;
function ge() {
  if (Dn)
    return Te;
  Dn = 1, Object.defineProperty(Te, "__esModule", {
    value: true
  }), Te.Vector = void 0;
  var t4 = function() {
    function a(o, s) {
      for (var l = 0; l < s.length; l++) {
        var h = s[l];
        h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(o, h.key, h);
      }
    }
    return function(o, s, l) {
      return s && a(o.prototype, s), l && a(o, l), o;
    };
  }(), e = Be(), n = fe;
  function r(a, o) {
    if (!(a instanceof o))
      throw new TypeError("Cannot call a class as a function");
  }
  var i = Te.Vector = function() {
    function a(o) {
      r(this, a), this.setElements(o);
    }
    return t4(a, [{
      key: "e",
      value: function(s) {
        return s < 1 || s > this.elements.length ? null : this.elements[s - 1];
      }
    }, {
      key: "dimensions",
      value: function() {
        return this.elements.length;
      }
    }, {
      key: "modulus",
      value: function() {
        return Math.sqrt(this.dot(this));
      }
    }, {
      key: "eql",
      value: function(s) {
        var l = this.elements.length, h = s.elements || s;
        if (l !== h.length)
          return false;
        for (; l--; )
          if (Math.abs(this.elements[l] - h[l]) > n.PRECISION)
            return false;
        return true;
      }
    }, {
      key: "dup",
      value: function() {
        return new a(this.elements);
      }
    }, {
      key: "map",
      value: function(s, l) {
        var h = [];
        return this.each(function(u, f) {
          h.push(s.call(l, u, f));
        }), new a(h);
      }
    }, {
      key: "forEach",
      value: function(s, l) {
        for (var h = this.elements.length, u = 0; u < h; u++)
          s.call(l, this.elements[u], u + 1);
      }
    }, {
      key: "toUnitVector",
      value: function() {
        var s = this.modulus();
        return s === 0 ? this.dup() : this.map(function(l) {
          return l / s;
        });
      }
    }, {
      key: "angleFrom",
      value: function(s) {
        var l = s.elements || s, h = this.elements.length;
        if (h !== l.length)
          return null;
        var u = 0, f = 0, c = 0;
        if (this.each(function(v, g) {
          u += v * l[g - 1], f += v * v, c += l[g - 1] * l[g - 1];
        }), f = Math.sqrt(f), c = Math.sqrt(c), f * c === 0)
          return null;
        var d = u / (f * c);
        return d < -1 && (d = -1), d > 1 && (d = 1), Math.acos(d);
      }
    }, {
      key: "isParallelTo",
      value: function(s) {
        var l = this.angleFrom(s);
        return l === null ? null : l <= n.PRECISION;
      }
    }, {
      key: "isAntiparallelTo",
      value: function(s) {
        var l = this.angleFrom(s);
        return l === null ? null : Math.abs(l - Math.PI) <= n.PRECISION;
      }
    }, {
      key: "isPerpendicularTo",
      value: function(s) {
        var l = this.dot(s);
        return l === null ? null : Math.abs(l) <= n.PRECISION;
      }
    }, {
      key: "add",
      value: function(s) {
        var l = s.elements || s;
        return this.elements.length !== l.length ? null : this.map(function(h, u) {
          return h + l[u - 1];
        });
      }
    }, {
      key: "subtract",
      value: function(s) {
        var l = s.elements || s;
        return this.elements.length !== l.length ? null : this.map(function(h, u) {
          return h - l[u - 1];
        });
      }
    }, {
      key: "multiply",
      value: function(s) {
        return this.map(function(l) {
          return l * s;
        });
      }
    }, {
      key: "dot",
      value: function(s) {
        var l = s.elements || s, h = 0, u = this.elements.length;
        if (u !== l.length)
          return null;
        for (; u--; )
          h += this.elements[u] * l[u];
        return h;
      }
    }, {
      key: "cross",
      value: function(s) {
        var l = s.elements || s;
        if (this.elements.length !== 3 || l.length !== 3)
          return null;
        var h = this.elements;
        return new a([h[1] * l[2] - h[2] * l[1], h[2] * l[0] - h[0] * l[2], h[0] * l[1] - h[1] * l[0]]);
      }
    }, {
      key: "max",
      value: function() {
        for (var s = 0, l = this.elements.length; l--; )
          Math.abs(this.elements[l]) > Math.abs(s) && (s = this.elements[l]);
        return s;
      }
    }, {
      key: "indexOf",
      value: function(s) {
        for (var l = null, h = this.elements.length, u = 0; u < h; u++)
          l === null && this.elements[u] === s && (l = u + 1);
        return l;
      }
    }, {
      key: "toDiagonalMatrix",
      value: function() {
        return e.Matrix.Diagonal(this.elements);
      }
    }, {
      key: "round",
      value: function() {
        return this.map(function(s) {
          return Math.round(s);
        });
      }
    }, {
      key: "snapTo",
      value: function(s) {
        return this.map(function(l) {
          return Math.abs(l - s) <= n.PRECISION ? s : l;
        });
      }
    }, {
      key: "distanceFrom",
      value: function(s) {
        if (s.anchor || s.start && s.end)
          return s.distanceFrom(this);
        var l = s.elements || s;
        if (l.length !== this.elements.length)
          return null;
        var h = 0, u;
        return this.each(function(f, c) {
          u = f - l[c - 1], h += u * u;
        }), Math.sqrt(h);
      }
    }, {
      key: "liesOn",
      value: function(s) {
        return s.contains(this);
      }
    }, {
      key: "liesIn",
      value: function(s) {
        return s.contains(this);
      }
    }, {
      key: "rotate",
      value: function(s, l) {
        var h, u = null, f, c, d;
        switch (s.determinant && (u = s.elements), this.elements.length) {
          case 2:
            return h = l.elements || l, h.length !== 2 ? null : (u || (u = e.Matrix.Rotation(s).elements), f = this.elements[0] - h[0], c = this.elements[1] - h[1], new a([h[0] + u[0][0] * f + u[0][1] * c, h[1] + u[1][0] * f + u[1][1] * c]));
          case 3: {
            if (!l.direction)
              return null;
            var v = l.pointClosestTo(this).elements;
            return u || (u = e.Matrix.Rotation(s, l.direction).elements), f = this.elements[0] - v[0], c = this.elements[1] - v[1], d = this.elements[2] - v[2], new a([v[0] + u[0][0] * f + u[0][1] * c + u[0][2] * d, v[1] + u[1][0] * f + u[1][1] * c + u[1][2] * d, v[2] + u[2][0] * f + u[2][1] * c + u[2][2] * d]);
          }
          default:
            return null;
        }
      }
    }, {
      key: "reflectionIn",
      value: function(s) {
        if (s.anchor) {
          var l = this.elements.slice(), h = s.pointClosestTo(l).elements;
          return new a([h[0] + (h[0] - l[0]), h[1] + (h[1] - l[1]), h[2] + (h[2] - (l[2] || 0))]);
        } else {
          var u = s.elements || s;
          return this.elements.length !== u.length ? null : this.map(function(f, c) {
            return u[c - 1] + (u[c - 1] - f);
          });
        }
      }
    }, {
      key: "to3D",
      value: function() {
        var s = this.dup();
        switch (s.elements.length) {
          case 3:
            break;
          case 2: {
            s.elements.push(0);
            break;
          }
          default:
            return null;
        }
        return s;
      }
    }, {
      key: "inspect",
      value: function() {
        return "[" + this.elements.join(", ") + "]";
      }
    }, {
      key: "setElements",
      value: function(s) {
        return this.elements = (s.elements || s).slice(), this;
      }
      //From glUtils.js
    }, {
      key: "flatten",
      value: function() {
        return this.elements;
      }
    }]), a;
  }();
  return i.Random = function(a) {
    for (var o = []; a--; )
      o.push(Math.random());
    return new i(o);
  }, i.Zero = function(a) {
    for (var o = []; a--; )
      o.push(0);
    return new i(o);
  }, i.prototype.x = i.prototype.multiply, i.prototype.each = i.prototype.forEach, i.i = new i([1, 0, 0]), i.j = new i([0, 1, 0]), i.k = new i([0, 0, 1]), Te;
}
var Pe = {};
var Ln;
function bt() {
  if (Ln)
    return Pe;
  Ln = 1, Object.defineProperty(Pe, "__esModule", {
    value: true
  }), Pe.Plane = void 0;
  var t4 = function() {
    function s(l, h) {
      for (var u = 0; u < h.length; u++) {
        var f = h[u];
        f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(l, f.key, f);
      }
    }
    return function(l, h, u) {
      return h && s(l.prototype, h), u && s(l, u), l;
    };
  }(), e = fe, n = Be(), r = ge(), i = wt();
  function a(s, l) {
    if (!(s instanceof l))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = Pe.Plane = function() {
    function s(l, h, u) {
      a(this, s), this.setVectors(l, h, u);
    }
    return t4(s, [{
      key: "eql",
      value: function(h) {
        return this.contains(h.anchor) && this.isParallelTo(h);
      }
    }, {
      key: "dup",
      value: function() {
        return new s(this.anchor, this.normal);
      }
    }, {
      key: "translate",
      value: function(h) {
        var u = h.elements || h;
        return new s([this.anchor.elements[0] + u[0], this.anchor.elements[1] + u[1], this.anchor.elements[2] + (u[2] || 0)], this.normal);
      }
    }, {
      key: "isParallelTo",
      value: function(h) {
        var u;
        return h.normal ? (u = this.normal.angleFrom(h.normal), Math.abs(u) <= e.PRECISION || Math.abs(Math.PI - u) <= e.PRECISION) : h.direction ? this.normal.isPerpendicularTo(h.direction) : null;
      }
    }, {
      key: "isPerpendicularTo",
      value: function(h) {
        var u = this.normal.angleFrom(h.normal);
        return Math.abs(Math.PI / 2 - u) <= e.PRECISION;
      }
    }, {
      key: "distanceFrom",
      value: function(h) {
        if (this.intersects(h) || this.contains(h))
          return 0;
        if (h.anchor) {
          var u = this.anchor.elements, f = h.anchor.elements, c = this.normal.elements;
          return Math.abs((u[0] - f[0]) * c[0] + (u[1] - f[1]) * c[1] + (u[2] - f[2]) * c[2]);
        } else {
          var d = h.elements || h, u = this.anchor.elements, c = this.normal.elements;
          return Math.abs((u[0] - d[0]) * c[0] + (u[1] - d[1]) * c[1] + (u[2] - (d[2] || 0)) * c[2]);
        }
      }
    }, {
      key: "contains",
      value: function(h) {
        if (h.normal)
          return null;
        if (h.direction)
          return this.contains(h.anchor) && this.contains(h.anchor.add(h.direction));
        var u = h.elements || h, f = this.anchor.elements, c = this.normal.elements, d = Math.abs(c[0] * (f[0] - u[0]) + c[1] * (f[1] - u[1]) + c[2] * (f[2] - (u[2] || 0)));
        return d <= e.PRECISION;
      }
    }, {
      key: "intersects",
      value: function(h) {
        return typeof h.direction > "u" && typeof h.normal > "u" ? null : !this.isParallelTo(h);
      }
    }, {
      key: "intersectionWith",
      value: function(h) {
        if (!this.intersects(h))
          return null;
        if (h.direction) {
          var u = h.anchor.elements, f = h.direction.elements, c = this.anchor.elements, d = this.normal.elements, v = (d[0] * (c[0] - u[0]) + d[1] * (c[1] - u[1]) + d[2] * (c[2] - u[2])) / (d[0] * f[0] + d[1] * f[1] + d[2] * f[2]);
          return new r.Vector([u[0] + f[0] * v, u[1] + f[1] * v, u[2] + f[2] * v]);
        } else if (h.normal) {
          for (var g = this.normal.cross(h.normal).toUnitVector(), d = this.normal.elements, u = this.anchor.elements, p = h.normal.elements, x = h.anchor.elements, w = n.Matrix.Zero(2, 2), b = 0; w.isSingular(); )
            b++, w = new n.Matrix([[d[b % 3], d[(b + 1) % 3]], [p[b % 3], p[(b + 1) % 3]]]);
          for (var m = w.inverse().elements, _ = d[0] * u[0] + d[1] * u[1] + d[2] * u[2], A = p[0] * x[0] + p[1] * x[1] + p[2] * x[2], C = [m[0][0] * _ + m[0][1] * A, m[1][0] * _ + m[1][1] * A], k = [], M = 1; M <= 3; M++)
            k.push(b === M ? 0 : C[(M + (5 - b) % 3) % 3]);
          return new i.Line(k, g);
        }
      }
    }, {
      key: "pointClosestTo",
      value: function(h) {
        var u = h.elements || h, f = this.anchor.elements, c = this.normal.elements, d = (f[0] - u[0]) * c[0] + (f[1] - u[1]) * c[1] + (f[2] - (u[2] || 0)) * c[2];
        return new r.Vector([u[0] + c[0] * d, u[1] + c[1] * d, (u[2] || 0) + c[2] * d]);
      }
    }, {
      key: "rotate",
      value: function(h, u) {
        var f = h.determinant ? h.elements : n.Matrix.Rotation(h, u.direction).elements, c = u.pointClosestTo(this.anchor).elements, d = this.anchor.elements, v = this.normal.elements, g = c[0], p = c[1], x = c[2], w = d[0], b = d[1], m = d[2], _ = w - g, A = b - p, C = m - x;
        return new s([g + f[0][0] * _ + f[0][1] * A + f[0][2] * C, p + f[1][0] * _ + f[1][1] * A + f[1][2] * C, x + f[2][0] * _ + f[2][1] * A + f[2][2] * C], [f[0][0] * v[0] + f[0][1] * v[1] + f[0][2] * v[2], f[1][0] * v[0] + f[1][1] * v[1] + f[1][2] * v[2], f[2][0] * v[0] + f[2][1] * v[1] + f[2][2] * v[2]]);
      }
    }, {
      key: "reflectionIn",
      value: function(h) {
        if (h.normal) {
          var u = this.anchor.elements, f = this.normal.elements, c = u[0], d = u[1], v = u[2], g = f[0], p = f[1], x = f[2], w = this.anchor.reflectionIn(h).elements, b = c + g, m = d + p, _ = v + x, A = h.pointClosestTo([b, m, _]).elements, C = [A[0] + (A[0] - b) - w[0], A[1] + (A[1] - m) - w[1], A[2] + (A[2] - _) - w[2]];
          return new s(w, C);
        } else {
          if (h.direction)
            return this.rotate(Math.PI, h);
          var k = h.elements || h;
          return new s(this.anchor.reflectionIn([k[0], k[1], k[2] || 0]), this.normal);
        }
      }
    }, {
      key: "setVectors",
      value: function(h, u, f) {
        if (h = new r.Vector(h), h = h.to3D(), h === null || (u = new r.Vector(u), u = u.to3D(), u === null))
          return null;
        if (typeof f > "u")
          f = null;
        else if (f = new r.Vector(f), f = f.to3D(), f === null)
          return null;
        var c = h.elements[0], d = h.elements[1], v = h.elements[2], g = u.elements[0], p = u.elements[1], x = u.elements[2], w, b;
        if (f !== null) {
          var m = f.elements[0], _ = f.elements[1], A = f.elements[2];
          if (w = new r.Vector([(p - d) * (A - v) - (x - v) * (_ - d), (x - v) * (m - c) - (g - c) * (A - v), (g - c) * (_ - d) - (p - d) * (m - c)]), b = w.modulus(), b === 0)
            return null;
          w = new r.Vector([w.elements[0] / b, w.elements[1] / b, w.elements[2] / b]);
        } else {
          if (b = Math.sqrt(g * g + p * p + x * x), b === 0)
            return null;
          w = new r.Vector([u.elements[0] / b, u.elements[1] / b, u.elements[2] / b]);
        }
        return this.anchor = h, this.normal = w, this;
      }
    }]), s;
  }();
  return o.XY = new o(r.Vector.Zero(3), r.Vector.k), o.YZ = new o(r.Vector.Zero(3), r.Vector.i), o.ZX = new o(r.Vector.Zero(3), r.Vector.j), o.YX = o.XY, o.ZY = o.YZ, o.XZ = o.ZX, o.fromPoints = function(s) {
    var l = s.length, h = [], u, f, c, d, v, g, p, x, w, b, m = r.Vector.Zero(3);
    for (u = 0; u < l; u++) {
      if (f = new r.Vector(s[u]).to3D(), f === null)
        return null;
      if (h.push(f), c = h.length, c > 2) {
        if (v = h[c - 1].elements, g = h[c - 2].elements, p = h[c - 3].elements, d = new r.Vector([(v[1] - g[1]) * (p[2] - g[2]) - (v[2] - g[2]) * (p[1] - g[1]), (v[2] - g[2]) * (p[0] - g[0]) - (v[0] - g[0]) * (p[2] - g[2]), (v[0] - g[0]) * (p[1] - g[1]) - (v[1] - g[1]) * (p[0] - g[0])]).toUnitVector(), c > 3 && (w = d.angleFrom(b), w !== null && !(Math.abs(w) <= e.PRECISION || Math.abs(w - Math.PI) <= e.PRECISION)))
          return null;
        m = m.add(d), b = d;
      }
    }
    return v = h[1].elements, g = h[0].elements, p = h[c - 1].elements, x = h[c - 2].elements, m = m.add(new r.Vector([(v[1] - g[1]) * (p[2] - g[2]) - (v[2] - g[2]) * (p[1] - g[1]), (v[2] - g[2]) * (p[0] - g[0]) - (v[0] - g[0]) * (p[2] - g[2]), (v[0] - g[0]) * (p[1] - g[1]) - (v[1] - g[1]) * (p[0] - g[0])]).toUnitVector()).add(new r.Vector([(g[1] - p[1]) * (x[2] - p[2]) - (g[2] - p[2]) * (x[1] - p[1]), (g[2] - p[2]) * (x[0] - p[0]) - (g[0] - p[0]) * (x[2] - p[2]), (g[0] - p[0]) * (x[1] - p[1]) - (g[1] - p[1]) * (x[0] - p[0])]).toUnitVector()), new o(h[0], m);
  }, Pe;
}
var Un;
function wt() {
  if (Un)
    return Se;
  Un = 1, Object.defineProperty(Se, "__esModule", {
    value: true
  }), Se.Line = void 0;
  var t4 = function() {
    function s(l, h) {
      for (var u = 0; u < h.length; u++) {
        var f = h[u];
        f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(l, f.key, f);
      }
    }
    return function(l, h, u) {
      return h && s(l.prototype, h), u && s(l, u), l;
    };
  }(), e = fe, n = ge(), r = Be(), i = bt();
  function a(s, l) {
    if (!(s instanceof l))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = Se.Line = function() {
    function s(l, h) {
      a(this, s), this.setVectors(l, h);
    }
    return t4(s, [{
      key: "eql",
      value: function(h) {
        return this.isParallelTo(h) && this.contains(h.anchor);
      }
    }, {
      key: "dup",
      value: function() {
        return new s(this.anchor, this.direction);
      }
    }, {
      key: "translate",
      value: function(h) {
        var u = h.elements || h;
        return new s([this.anchor.elements[0] + u[0], this.anchor.elements[1] + u[1], this.anchor.elements[2] + (u[2] || 0)], this.direction);
      }
    }, {
      key: "isParallelTo",
      value: function(h) {
        if (h.normal || h.start && h.end)
          return h.isParallelTo(this);
        var u = this.direction.angleFrom(h.direction);
        return Math.abs(u) <= e.PRECISION || Math.abs(u - Math.PI) <= e.PRECISION;
      }
    }, {
      key: "distanceFrom",
      value: function(h) {
        if (h.normal || h.start && h.end)
          return h.distanceFrom(this);
        if (h.direction) {
          if (this.isParallelTo(h))
            return this.distanceFrom(h.anchor);
          var u = this.direction.cross(h.direction).toUnitVector().elements, f = this.anchor.elements, c = h.anchor.elements;
          return Math.abs((f[0] - c[0]) * u[0] + (f[1] - c[1]) * u[1] + (f[2] - c[2]) * u[2]);
        } else {
          var d = h.elements || h, f = this.anchor.elements, v = this.direction.elements, g = d[0] - f[0], p = d[1] - f[1], x = (d[2] || 0) - f[2], w = Math.sqrt(g * g + p * p + x * x);
          if (w === 0)
            return 0;
          var b = (g * v[0] + p * v[1] + x * v[2]) / w, m = 1 - b * b;
          return Math.abs(w * Math.sqrt(m < 0 ? 0 : m));
        }
      }
    }, {
      key: "contains",
      value: function(h) {
        if (h.start && h.end)
          return this.contains(h.start) && this.contains(h.end);
        var u = this.distanceFrom(h);
        return u !== null && u <= e.PRECISION;
      }
    }, {
      key: "positionOf",
      value: function(h) {
        if (!this.contains(h))
          return null;
        var u = h.elements || h, f = this.anchor.elements, c = this.direction.elements;
        return (u[0] - f[0]) * c[0] + (u[1] - f[1]) * c[1] + ((u[2] || 0) - f[2]) * c[2];
      }
    }, {
      key: "liesIn",
      value: function(h) {
        return h.contains(this);
      }
    }, {
      key: "intersects",
      value: function(h) {
        return h.normal ? h.intersects(this) : !this.isParallelTo(h) && this.distanceFrom(h) <= e.PRECISION;
      }
    }, {
      key: "intersectionWith",
      value: function(h) {
        if (h.normal || h.start && h.end)
          return h.intersectionWith(this);
        if (!this.intersects(h))
          return null;
        var u = this.anchor.elements, f = this.direction.elements, c = h.anchor.elements, d = h.direction.elements, v = f[0], g = f[1], p = f[2], x = d[0], w = d[1], b = d[2], m = u[0] - c[0], _ = u[1] - c[1], A = u[2] - c[2], C = -v * m - g * _ - p * A, k = x * m + w * _ + b * A, M = v * v + g * g + p * p, P = x * x + w * w + b * b, I = v * x + g * w + p * b, N = (C * P / M + I * k) / (P - I * I);
        return new n.Vector([u[0] + N * v, u[1] + N * g, u[2] + N * p]);
      }
    }, {
      key: "pointClosestTo",
      value: function(h) {
        if (h.start && h.end) {
          var u = h.pointClosestTo(this);
          return u === null ? null : this.pointClosestTo(u);
        } else if (h.direction) {
          if (this.intersects(h))
            return this.intersectionWith(h);
          if (this.isParallelTo(h))
            return null;
          var f = this.direction.elements, c = h.direction.elements, d = f[0], v = f[1], g = f[2], p = c[0], x = c[1], w = c[2], b = g * p - d * w, m = d * x - v * p, _ = v * w - g * x, A = [b * w - m * x, m * p - _ * w, _ * x - b * p], u = new i.Plane(h.anchor, A);
          return u.intersectionWith(this);
        } else {
          var u = h.elements || h;
          if (this.contains(u))
            return new n.Vector(u);
          var C = this.anchor.elements, f = this.direction.elements, d = f[0], v = f[1], g = f[2], k = C[0], M = C[1], P = C[2], b = d * (u[1] - M) - v * (u[0] - k), m = v * ((u[2] || 0) - P) - g * (u[1] - M), _ = g * (u[0] - k) - d * ((u[2] || 0) - P), I = new n.Vector([v * b - g * _, g * m - d * b, d * _ - v * m]), N = this.distanceFrom(u) / I.modulus();
          return new n.Vector([u[0] + I.elements[0] * N, u[1] + I.elements[1] * N, (u[2] || 0) + I.elements[2] * N]);
        }
      }
      // Returns a copy of the line rotated by t radians about the given line. Works
      // by finding the argument's closest point to this line's anchor point (call
      // this C) and rotating the anchor about C. Also rotates the line's direction
      // about the argument's. Be careful with this - the rotation axis' direction
      // affects the outcome!
    }, {
      key: "rotate",
      value: function(h, u) {
        typeof u.direction > "u" && (u = new s(u.to3D(), n.Vector.k));
        var f = r.Matrix.Rotation(h, u.direction).elements, c = u.pointClosestTo(this.anchor).elements, d = this.anchor.elements, v = this.direction.elements, g = c[0], p = c[1], x = c[2], w = d[0], b = d[1], m = d[2], _ = w - g, A = b - p, C = m - x;
        return new s([g + f[0][0] * _ + f[0][1] * A + f[0][2] * C, p + f[1][0] * _ + f[1][1] * A + f[1][2] * C, x + f[2][0] * _ + f[2][1] * A + f[2][2] * C], [f[0][0] * v[0] + f[0][1] * v[1] + f[0][2] * v[2], f[1][0] * v[0] + f[1][1] * v[1] + f[1][2] * v[2], f[2][0] * v[0] + f[2][1] * v[1] + f[2][2] * v[2]]);
      }
    }, {
      key: "reverse",
      value: function() {
        return new s(this.anchor, this.direction.x(-1));
      }
    }, {
      key: "reflectionIn",
      value: function(h) {
        if (h.normal) {
          var u = this.anchor.elements, f = this.direction.elements, c = u[0], d = u[1], v = u[2], g = f[0], p = f[1], x = f[2], w = this.anchor.reflectionIn(h).elements, b = c + g, m = d + p, _ = v + x, A = h.pointClosestTo([b, m, _]).elements, C = [A[0] + (A[0] - b) - w[0], A[1] + (A[1] - m) - w[1], A[2] + (A[2] - _) - w[2]];
          return new s(w, C);
        } else {
          if (h.direction)
            return this.rotate(Math.PI, h);
          var k = h.elements || h;
          return new s(this.anchor.reflectionIn([k[0], k[1], k[2] || 0]), this.direction);
        }
      }
    }, {
      key: "setVectors",
      value: function(h, u) {
        if (h = new n.Vector(h), u = new n.Vector(u), h.elements.length === 2 && h.elements.push(0), u.elements.length === 2 && u.elements.push(0), h.elements.length > 3 || u.elements.length > 3)
          return null;
        var f = u.modulus();
        return f === 0 ? null : (this.anchor = h, this.direction = new n.Vector([u.elements[0] / f, u.elements[1] / f, u.elements[2] / f]), this);
      }
    }]), s;
  }();
  return o.X = new o(n.Vector.Zero(3), n.Vector.i), o.Y = new o(n.Vector.Zero(3), n.Vector.j), o.Z = new o(n.Vector.Zero(3), n.Vector.k), Se;
}
var Et = {};
Object.defineProperty(Et, "__esModule", {
  value: true
});
Et.LineSegment = void 0;
var Jo = function() {
  function t4(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t4(e.prototype, n), r && t4(e, r), e;
  };
}();
var Oe = ge();
var el = bt();
var tl = wt();
function nl(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
Et.LineSegment = function() {
  function t4(e, n) {
    nl(this, t4), this.setPoints(e, n);
  }
  return Jo(t4, [{
    key: "eql",
    value: function(n) {
      return this.start.eql(n.start) && this.end.eql(n.end) || this.start.eql(n.end) && this.end.eql(n.start);
    }
  }, {
    key: "dup",
    value: function() {
      return new t4(this.start, this.end);
    }
  }, {
    key: "length",
    value: function() {
      var n = this.start.elements, r = this.end.elements, i = r[0] - n[0], a = r[1] - n[1], o = r[2] - n[2];
      return Math.sqrt(i * i + a * a + o * o);
    }
  }, {
    key: "toVector",
    value: function() {
      var n = this.start.elements, r = this.end.elements;
      return new Oe.Vector([r[0] - n[0], r[1] - n[1], r[2] - n[2]]);
    }
  }, {
    key: "midpoint",
    value: function() {
      var n = this.start.elements, r = this.end.elements;
      return new Oe.Vector([(r[0] + n[0]) / 2, (r[1] + n[1]) / 2, (r[2] + n[2]) / 2]);
    }
  }, {
    key: "bisectingPlane",
    value: function() {
      return new el.Plane(this.midpoint(), this.toVector());
    }
  }, {
    key: "translate",
    value: function(n) {
      var r = n.elements || n, i = this.start.elements, a = this.end.elements;
      return new t4([i[0] + r[0], i[1] + r[1], i[2] + (r[2] || 0)], [a[0] + r[0], a[1] + r[1], a[2] + (r[2] || 0)]);
    }
  }, {
    key: "isParallelTo",
    value: function(n) {
      return this.line.isParallelTo(n);
    }
  }, {
    key: "distanceFrom",
    value: function(n) {
      var r = this.pointClosestTo(n);
      return r === null ? null : r.distanceFrom(n);
    }
  }, {
    key: "contains",
    value: function(n) {
      if (n.start && n.end)
        return this.contains(n.start) && this.contains(n.end);
      var r = (n.elements || n).slice();
      if (r.length === 2 && r.push(0), this.start.eql(r))
        return true;
      var i = this.start.elements, a = new Oe.Vector([i[0] - r[0], i[1] - r[1], i[2] - (r[2] || 0)]), o = this.toVector();
      return a.isAntiparallelTo(o) && a.modulus() <= o.modulus();
    }
  }, {
    key: "intersects",
    value: function(n) {
      return this.intersectionWith(n) !== null;
    }
  }, {
    key: "intersectionWith",
    value: function(n) {
      if (!this.line.intersects(n))
        return null;
      var r = this.line.intersectionWith(n);
      return this.contains(r) ? r : null;
    }
  }, {
    key: "pointClosestTo",
    value: function(n) {
      if (n.normal) {
        var r = this.line.intersectionWith(n);
        return r === null ? null : this.pointClosestTo(r);
      } else {
        var i = this.line.pointClosestTo(n);
        return i === null ? null : this.contains(i) ? i : (this.line.positionOf(i) < 0 ? this.start : this.end).dup();
      }
    }
  }, {
    key: "setPoints",
    value: function(n, r) {
      return n = new Oe.Vector(n).to3D(), r = new Oe.Vector(r).to3D(), n === null || r === null ? null : (this.line = new tl.Line(n, r.subtract(n)), this.start = n, this.end = r, this);
    }
  }]), t4;
}();
var ln = {};
Object.defineProperty(ln, "__esModule", {
  value: true
});
function rl(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
ln.LinkedListNode = function t3(e) {
  rl(this, t3), this.prev = null, this.next = null, this.data = e;
};
var kt = {};
Object.defineProperty(kt, "__esModule", {
  value: true
});
kt.Polygon = void 0;
var il = function() {
  function t4(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t4(e.prototype, n), r && t4(e, r), e;
  };
}();
var oe = Ye;
var Qn = fe;
var al = Be();
var ze = ge();
var zt = bt();
var sl = wt();
function ol(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
kt.Polygon = function() {
  function t4(e, n) {
    ol(this, t4), this.setVertices(e, n);
  }
  return il(t4, [{
    key: "v",
    value: function(n) {
      return this.vertices.at(n - 1).data;
    }
  }, {
    key: "nodeFor",
    value: function(n) {
      return this.vertices.withData(n);
    }
  }, {
    key: "dup",
    value: function() {
      return new t4(this.vertices, this.plane);
    }
  }, {
    key: "translate",
    value: function(n) {
      var r = n.elements || n;
      return this.vertices.each(function(i) {
        var a = i.data.elements;
        i.data.setElements([a[0] + r[0], a[1] + r[1], a[2] + (r[2] || 0)]);
      }), this.plane = this.plane.translate(n), this.updateTrianglePlanes(function(i) {
        return i.translate(n);
      }), this;
    }
  }, {
    key: "rotate",
    value: function(n, r) {
      var i = al.Matrix.Rotation(n, r.direction);
      return this.vertices.each(function(a) {
        a.data.setElements(a.data.rotate(i, r).elements);
      }), this.plane = this.plane.rotate(i, r), this.updateTrianglePlanes(function(a) {
        return a.rotate(i, r);
      }), this;
    }
  }, {
    key: "scale",
    value: function(n, r) {
      var i = r.elements || r;
      this.vertices.each(function(o) {
        var s = o.data.elements;
        o.data.setElements([i[0] + n * (s[0] - i[0]), i[1] + n * (s[1] - i[1]), (i[2] || 0) + n * (s[2] - (i[2] || 0))]);
      });
      var a = this.vertices.first.data;
      return this.plane.anchor.setElements(a), this.updateTrianglePlanes(function(o) {
        return new zt.Plane(a, o.normal);
      }), this;
    }
    // Updates the plane properties of all the cached triangles belonging to the
    // polygon according to the given function. For example, suppose you just
    // rotated the polygon, you should call:
    //
    //   poly.updateTrianglePlanes(function(plane) { return plane.rotate(t, line); });
    //
    // This method is called automatically by Polygon.translate,
    // Polygon.rotate and Polygon.scale transformation methods.
  }, {
    key: "updateTrianglePlanes",
    value: function(n) {
      var r;
      if (this.cached.triangles !== null)
        for (r = this.cached.triangles.length; r--; )
          this.cached.triangles[r].plane = n(this.cached.triangles[r].plane);
      if (this.cached.surfaceIntegralElements !== null)
        for (r = this.cached.surfaceIntegralElements.length; r--; )
          this.cached.surfaceIntegralElements[r].plane = n(this.cached.surfaceIntegralElements[r].plane);
    }
  }, {
    key: "isTriangle",
    value: function() {
      return this.vertices.length === 3;
    }
    // Returns a collection of triangles used for calculating area and center of
    // mass. Some of the triangles will not lie inside the polygon - this
    // collection is essentially a series of itervals in a surface integral, so
    // some are 'negative'. If you want the polygon broken into constituent
    // triangles, use toTriangles(). This method is used because it's much faster
    // than toTriangles().
    //
    // The triangles generated share vertices with the original polygon, so they
    // transform with the polygon. They are cached after first calculation and
    // should remain in sync with changes to the parent polygon.
  }, {
    key: "trianglesForSurfaceIntegral",
    value: function() {
      if (this.cached.surfaceIntegralElements !== null)
        return this.cached.surfaceIntegralElements;
      var n = [], r = this.vertices.first.data, i = this.plane;
      return this.vertices.each(function(a, o) {
        if (!(o < 2)) {
          var s = [r, a.prev.data, a.data];
          n.push(new t4(s, zt.Plane.fromPoints(s) || i));
        }
      }), this.setCache("surfaceIntegralElements", n);
    }
  }, {
    key: "area",
    value: function() {
      if (this.isTriangle()) {
        var n = this.vertices.first, r = n.next, i = r.next;
        return n = n.data.elements, r = r.data.elements, i = i.data.elements, 0.5 * new ze.Vector([(n[1] - r[1]) * (i[2] - r[2]) - (n[2] - r[2]) * (i[1] - r[1]), (n[2] - r[2]) * (i[0] - r[0]) - (n[0] - r[0]) * (i[2] - r[2]), (n[0] - r[0]) * (i[1] - r[1]) - (n[1] - r[1]) * (i[0] - r[0])]).modulus();
      } else {
        for (var a = this.trianglesForSurfaceIntegral(), o = 0, s = a.length; s--; )
          o += a[s].area() * a[s].plane.normal.dot(this.plane.normal);
        return o;
      }
    }
  }, {
    key: "centroid",
    value: function() {
      if (this.isTriangle()) {
        var n = this.v(1).elements, r = this.v(2).elements, i = this.v(3).elements;
        return new ze.Vector([(n[0] + r[0] + i[0]) / 3, (n[1] + r[1] + i[1]) / 3, (n[2] + r[2] + i[2]) / 3]);
      } else {
        for (var n, a = 0, o = ze.Vector.Zero(3), s, i, l = this.trianglesForSurfaceIntegral(), h = l.length; h--; )
          n = l[h].area() * l[h].plane.normal.dot(this.plane.normal), a += n, s = o.elements, i = l[h].centroid().elements, o.setElements([s[0] + i[0] * n, s[1] + i[1] * n, s[2] + i[2] * n]);
        return o.x(1 / a);
      }
    }
  }, {
    key: "projectionOn",
    value: function(n) {
      var r = [];
      return this.vertices.each(function(i) {
        r.push(n.pointClosestTo(i.data));
      }), new t4(r);
    }
  }, {
    key: "removeVertex",
    value: function(n) {
      if (!this.isTriangle()) {
        var r = this.nodeFor(n);
        if (r === null)
          return null;
        this.clearCache();
        var i = r.prev, a = r.next, o = i.data.isConvex(this), s = a.data.isConvex(this);
        return r.data.isConvex(this) ? this.convexVertices.remove(this.convexVertices.withData(r.data)) : this.reflexVertices.remove(this.reflexVertices.withData(r.data)), this.vertices.remove(r), o !== i.data.isConvex(this) && (o ? (this.convexVertices.remove(this.convexVertices.withData(i.data)), this.reflexVertices.append(new oe.LinkedList.Node(i.data))) : (this.reflexVertices.remove(this.reflexVertices.withData(i.data)), this.convexVertices.append(new oe.LinkedList.Node(i.data)))), s !== a.data.isConvex(this) && (s ? (this.convexVertices.remove(this.convexVertices.withData(a.data)), this.reflexVertices.append(new oe.LinkedList.Node(a.data))) : (this.reflexVertices.remove(this.reflexVertices.withData(a.data)), this.convexVertices.append(new oe.LinkedList.Node(a.data)))), this;
      }
    }
  }, {
    key: "contains",
    value: function(n) {
      return this.containsByWindingNumber(n);
    }
  }, {
    key: "containsByWindingNumber",
    value: function(n) {
      var r = n.elements || n;
      if (!this.plane.contains(r) || this.hasEdgeContaining(r))
        return false;
      var i, a, o, s, l = 0, h, u = 0, f = this;
      return this.vertices.each(function(c) {
        i = c.data.elements, a = c.next.data.elements, o = new ze.Vector([i[0] - r[0], i[1] - r[1], i[2] - (r[2] || 0)]), s = new ze.Vector([a[0] - r[0], a[1] - r[1], a[2] - (r[2] || 0)]), h = o.angleFrom(s), !(h === null || h === 0) && (l += (o.cross(s).isParallelTo(f.plane.normal) ? 1 : -1) * h, l >= 2 * Math.PI - Qn.PRECISION && (u++, l -= 2 * Math.PI), l <= -2 * Math.PI + Qn.PRECISION && (u--, l += 2 * Math.PI));
      }), u !== 0;
    }
  }, {
    key: "hasEdgeContaining",
    value: function(n) {
      var r = n.elements || n, i = false;
      return this.vertices.each(function(a) {
        sl.Line.Segment.create(a.data, a.next.data).contains(r) && (i = true);
      }), i;
    }
  }, {
    key: "toTriangles",
    value: function() {
      return this.cached.triangles !== null ? this.cached.triangles : this.setCache("triangles", this.triangulateByEarClipping());
    }
    // Implementation of ear clipping algorithm
    // Found in 'Triangulation by ear clipping', by David Eberly
    // at http://www.geometrictools.com
    // This will not deal with overlapping sections - contruct your polygons
    // sensibly
  }, {
    key: "triangulateByEarClipping",
    value: function() {
      for (var n = this.dup(), r = [], i, a, o, s; !n.isTriangle(); ) {
        for (i = false; !i; )
          i = true, a = n.convexVertices.randomNode(), o = n.vertices.withData(a.data), s = new t4([o.data, o.next.data, o.prev.data], this.plane), n.reflexVertices.each(function(l) {
            l.data !== o.prev.data && l.data !== o.next.data && (s.contains(l.data) || s.hasEdgeContaining(l.data)) && (i = false);
          });
        r.push(s), n.removeVertex(o.data);
      }
      return r.push(new t4(n.vertices, this.plane)), r;
    }
  }, {
    key: "setVertices",
    value: function(n, r) {
      var i = n.toArray ? n.toArray() : n;
      if (this.plane = r && r.normal ? r.dup() : zt.Plane.fromPoints(i), this.plane === null)
        return null;
      this.vertices = new oe.LinkedList.Circular();
      for (var a = i.length, o; a--; )
        o = i[a].isConvex ? i[a] : new t4.Vertex(i[a]), this.vertices.prepend(new oe.LinkedList.Node(o));
      return this.clearCache(), this.populateVertexTypeLists(), this;
    }
  }, {
    key: "populateVertexTypeLists",
    value: function() {
      this.convexVertices = new oe.LinkedList.Circular(), this.reflexVertices = new oe.LinkedList.Circular();
      var n = this;
      this.vertices.each(function(r) {
        n[r.data.type(n) + "Vertices"].append(new oe.LinkedList.Node(r.data));
      });
    }
  }, {
    key: "copyVertices",
    value: function() {
      this.clearCache(), this.vertices.each(function(n) {
        n.data = new t4.Vertex(n.data);
      }), this.populateVertexTypeLists();
    }
  }, {
    key: "clearCache",
    value: function() {
      this.cached = {
        triangles: null,
        surfaceIntegralElements: null
      };
    }
  }, {
    key: "setCache",
    value: function(n, r) {
      return this.cached[n] = r, r;
    }
  }, {
    key: "inspect",
    value: function() {
      var n = [];
      return this.vertices.each(function(r) {
        n.push(r.data.inspect());
      }), n.join(" -> ");
    }
  }]), t4;
}();
var Ct = {};
Object.defineProperty(Ct, "__esModule", {
  value: true
});
Ct.Vertex = void 0;
var ll = function() {
  function t4(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t4(e.prototype, n), r && t4(e, r), e;
  };
}();
var ul = ge();
var Gn = fe;
function hl(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Vn(t4, e) {
  if (!t4)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t4;
}
function fl(t4, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t4.prototype = Object.create(e && e.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t4, e) : t4.__proto__ = e);
}
var Wn = Ct.Vertex = function(t4) {
  fl(e, t4);
  function e(n) {
    hl(this, e);
    var r = Vn(this, Object.getPrototypeOf(e).call(this, n));
    if (r.setElements(n), r.elements.length === 2 && r.elements.push(0), r.elements.length !== 3) {
      var i;
      return i = null, Vn(r, i);
    }
    return r;
  }
  return ll(e, [{
    key: "isConvex",
    value: function(r) {
      var i = r.nodeFor(this);
      if (i === null)
        return null;
      var a = i.prev.data, o = i.next.data, s = o.subtract(this), l = a.subtract(this), h = s.angleFrom(l);
      return h <= Gn.PRECISION ? true : Math.abs(h - Math.PI) <= Gn.PRECISION ? false : s.cross(l).dot(r.plane.normal) > 0;
    }
    // Returns true iff the vertex's internal angle is 180 <= x < 360
  }, {
    key: "isReflex",
    value: function(r) {
      var i = this.isConvex(r);
      return i === null ? null : !i;
    }
  }, {
    key: "type",
    value: function(r) {
      var i = this.isConvex(r);
      return i === null ? null : i ? "convex" : "reflex";
    }
  }]), e;
}(ul.Vector);
Wn.convert = function(t4) {
  for (var e = t4.toArray ? t4.toArray() : t4, n = [], r = e.length, i = 0; i < r; i++)
    n.push(new Wn(e[i]));
  return n;
};
var we = {};
Object.defineProperty(we, "__esModule", {
  value: true
});
we.mht = cl;
we.makeLookAt = dl;
we.makeOrtho = gl;
we.makePerspective = vl;
we.makeFrustum = yr;
var Dt = ge();
var gt = Be();
function cl(t4) {
  var e = "";
  if (t4.length == 16)
    for (var n = 0; n < 4; n++)
      e += "<span style='font-family: monospace'>[" + t4[n * 4 + 0].toFixed(4) + "," + t4[n * 4 + 1].toFixed(4) + "," + t4[n * 4 + 2].toFixed(4) + "," + t4[n * 4 + 3].toFixed(4) + "]</span><br>";
  else if (t4.length == 9)
    for (var n = 0; n < 3; n++)
      e += "<span style='font-family: monospace'>[" + t4[n * 3 + 0].toFixed(4) + "," + t4[n * 3 + 1].toFixed(4) + "," + t4[n * 3 + 2].toFixed(4) + "]</font><br>";
  else
    return t4.toString();
  return e;
}
function dl(t4, e, n, r, i, a, o, s, l) {
  var h = new Dt.Vector([t4, e, n]), u = new Dt.Vector([r, i, a]), f = new Dt.Vector([o, s, l]), c = h.subtract(u).toUnitVector(), d = f.cross(c).toUnitVector(), v = c.cross(d).toUnitVector(), g = new gt.Matrix([[d.e(1), d.e(2), d.e(3), 0], [v.e(1), v.e(2), v.e(3), 0], [c.e(1), c.e(2), c.e(3), 0], [0, 0, 0, 1]]), p = new gt.Matrix([[1, 0, 0, -t4], [0, 1, 0, -e], [0, 0, 1, -n], [0, 0, 0, 1]]);
  return g.x(p);
}
function gl(t4, e, n, r, i, a) {
  var o = -(e + t4) / (e - t4), s = -(r + n) / (r - n), l = -(a + i) / (a - i);
  return new gt.Matrix([[2 / (e - t4), 0, 0, o], [0, 2 / (r - n), 0, s], [0, 0, -2 / (a - i), l], [0, 0, 0, 1]]);
}
function vl(t4, e, n, r) {
  var i = n * Math.tan(t4 * Math.PI / 360), a = -i, o = a * e, s = i * e;
  return yr(o, s, a, i, n, r);
}
function yr(t4, e, n, r, i, a) {
  var o = 2 * i / (e - t4), s = 2 * i / (r - n), l = (e + t4) / (e - t4), h = (r + n) / (r - n), u = -(a + i) / (a - i), f = -2 * a * i / (a - i);
  return new gt.Matrix([[o, 0, l, 0], [0, s, h, 0], [0, 0, u, f], [0, 0, -1, 0]]);
}
(function(t4) {
  Object.defineProperty(t4, "__esModule", {
    value: true
  });
  var e = xt;
  Object.defineProperty(t4, "CircularLinkedList", {
    enumerable: true,
    get: function() {
      return e.CircularLinkedList;
    }
  });
  var n = wt();
  Object.defineProperty(t4, "Line", {
    enumerable: true,
    get: function() {
      return n.Line;
    }
  });
  var r = Et;
  Object.defineProperty(t4, "LineSegment", {
    enumerable: true,
    get: function() {
      return r.LineSegment;
    }
  });
  var i = Ye;
  Object.defineProperty(t4, "LinkedList", {
    enumerable: true,
    get: function() {
      return i.LinkedList;
    }
  });
  var a = ln;
  Object.defineProperty(t4, "LinkedListNode", {
    enumerable: true,
    get: function() {
      return a.LinkedListNode;
    }
  });
  var o = Be();
  Object.defineProperty(t4, "Matrix", {
    enumerable: true,
    get: function() {
      return o.Matrix;
    }
  });
  var s = bt();
  Object.defineProperty(t4, "Plane", {
    enumerable: true,
    get: function() {
      return s.Plane;
    }
  });
  var l = kt;
  Object.defineProperty(t4, "Polygon", {
    enumerable: true,
    get: function() {
      return l.Polygon;
    }
  });
  var h = ge();
  Object.defineProperty(t4, "Vector", {
    enumerable: true,
    get: function() {
      return h.Vector;
    }
  });
  var u = Ct;
  Object.defineProperty(t4, "Vertex", {
    enumerable: true,
    get: function() {
      return u.Vertex;
    }
  });
  var f = we;
  Object.defineProperty(t4, "mht", {
    enumerable: true,
    get: function() {
      return f.mht;
    }
  }), Object.defineProperty(t4, "makeLookAt", {
    enumerable: true,
    get: function() {
      return f.makeLookAt;
    }
  }), Object.defineProperty(t4, "makePerspective", {
    enumerable: true,
    get: function() {
      return f.makePerspective;
    }
  }), Object.defineProperty(t4, "makeFrustum", {
    enumerable: true,
    get: function() {
      return f.makeFrustum;
    }
  }), Object.defineProperty(t4, "makeOrtho", {
    enumerable: true,
    get: function() {
      return f.makeOrtho;
    }
  });
  var c = fe;
  Object.defineProperty(t4, "PRECISION", {
    enumerable: true,
    get: function() {
      return c.PRECISION;
    }
  });
})(st);
function It(t4) {
  for (var e = t4.length / 6 | 0, n = new Array(e), r = 0; r < e; )
    n[r] = "#" + t4.slice(r * 6, ++r * 6);
  return n;
}
function Bt(t4) {
  var e = t4.length;
  return function(n) {
    return t4[Math.max(0, Math.min(e - 1, Math.floor(n * e)))];
  };
}
Bt(It("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
Bt(It("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var ml = Bt(It("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
Bt(It("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
var pl = (
  /*glsl*/
  `precision highp float; 

uniform sampler2D input_tex;
uniform sampler2D lut_tex;  
uniform float diverging;  
varying vec2 tex_coord;     
void main(){
	float val = texture2D( input_tex, tex_coord ).r+0.5*diverging;
	vec4 color = texture2D( lut_tex, vec2(val, 0.5) );
	gl_FragColor = vec4(color.rgb,1.0);
}
`
);
var Al = (
  /*glsl*/
  `

attribute vec2 vertex;   
attribute vec2 texCoord; 
uniform mat4 uMVMatrix;  
uniform mat4 uPMatrix;   
varying vec2 tex_coord;  
void main(){
	tex_coord = texCoord; 
	gl_Position = uPMatrix * uMVMatrix * vec4( vertex, 0.0, 1.0 ); 
}

`
);
var _l = (
  /*glsl*/
  `precision highp float;

varying vec2 quad_coord; 
varying float v_kernel_weight; 
uniform float kernel_weightScale; 
void main(void) { 
	float len = length( quad_coord ); 
	float nrm = v_kernel_weight * kernel_weightScale * 0.3989422804014327 * exp( -0.5*25.0*len*len ); 
	// gl_FragColor = vec4(1,1,1,1.0);//vec4(nrm,nrm,nrm, nrm );	
	gl_FragColor = vec4(nrm,nrm,nrm, nrm );
	// gl_FragColor = vec4(1,1,1, 1.0 ); 
}

`
);
var yl = (
  /*glsl*/
  `

attribute vec3 position;
attribute float kernel_weight;

attribute vec2 offset;
// attribute vec3 normal;

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;

uniform mat4 uMVMatrix; 
uniform mat4 uPMatrix; 
uniform float bandwidthScale; 
uniform vec2 bandwidth; 
varying vec2 quad_coord; 
varying float v_kernel_weight; 

void main(void) { 
	// vec4 viewCenters = viewMatrix*vec4(position,1.0);
	// vec2 pos = (viewCenters).xy; 
	// quad_coord = offset.xy;  
	// pos += bandwidthScale * bandwidth * quad_coord; 
	// gl_Position = uPMatrix * uMVMatrix * vec4( pos, 0.0, 1.0); 
	


	float BoxCorrection = 1.5;
	float fullSize = bandwidthScale * 5.5;
	vec3 cameraRight = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
	vec3 cameraUp = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));
	// vec4 viewCenters = viewMatrix*vec4(position+BoxCorrection*fullSize*(cameraRight*offset.x + cameraUp*offset.y),1.0);
	vec4 viewCenters = viewMatrix*vec4(position,1.0);
	viewCenters.xy += bandwidthScale * bandwidth * offset.xy;
	quad_coord = offset.xy; 
	v_kernel_weight = kernel_weight;
	gl_Position = projectionMatrix * viewCenters;
} 
`
);
function vt(t4, e, n) {
  let r = t4.createShader(n);
  return t4.shaderSource(r, e), t4.compileShader(r), t4.getShaderParameter(r, t4.COMPILE_STATUS) ? r : (console.log(t4.getShaderInfoLog(r)), null);
}
function xl(t4) {
  let e = vt(t4, _l, t4.FRAGMENT_SHADER), n = vt(t4, yl, t4.VERTEX_SHADER), r = t4.createProgram();
  return t4.attachShader(r, n), t4.attachShader(r, e), t4.linkProgram(r), t4.getProgramParameter(r, t4.LINK_STATUS) || alert("Could not initialise shaders"), t4.useProgram(r), r.vertexPositionAttribute = t4.getAttribLocation(r, "position"), r.vertexKernelWeightAttribute = t4.getAttribLocation(r, "kernel_weight"), r.vertexOffsetAttribute = t4.getAttribLocation(r, "offset"), r.pMatrixUniform = t4.getUniformLocation(r, "uPMatrix"), r.mvMatrixUniform = t4.getUniformLocation(r, "uMVMatrix"), r.projectionMatrixUniform = t4.getUniformLocation(r, "projectionMatrix"), r.viewMatrixUniform = t4.getUniformLocation(r, "viewMatrix"), r.bandwidthUniform = t4.getUniformLocation(r, "bandwidth"), r.bandwidthScaleUniform = t4.getUniformLocation(r, "bandwidthScale"), r.kernel_weightScaleUniform = t4.getUniformLocation(r, "kernel_weightScale"), r;
}
function bl(t4) {
  let e = vt(t4, pl, t4.FRAGMENT_SHADER), n = vt(t4, Al, t4.VERTEX_SHADER), r = t4.createProgram();
  return t4.attachShader(r, n), t4.attachShader(r, e), t4.linkProgram(r), t4.getProgramParameter(r, t4.LINK_STATUS) || alert("Could not initialise shaders"), t4.useProgram(r), r.vertexAttribute = t4.getAttribLocation(r, "vertex"), r.texCoordAttribute = t4.getAttribLocation(r, "texCoord"), r.pMatrixUniform = t4.getUniformLocation(r, "uPMatrix"), r.mvMatrixUniform = t4.getUniformLocation(r, "uMVMatrix"), r.input_texUniform = t4.getUniformLocation(r, "input_tex"), r.lut_texUniform = t4.getUniformLocation(r, "lut_tex"), r.divergingUniform = t4.getUniformLocation(r, "diverging"), r;
}
function le(t4) {
  console.log(t4);
}
var wl = class {
  constructor(e, n, r, i = 0.1) {
    this.gl = e, this.FBO, this.lutShader, this.shaderProgram, this.mvMatrix, this.pMatrix, this.qualityScale = i, this._divergingColormap = false, this.bandwidth = [5.5, 5.5], this.bandwidthScale = 5, this.kernel_weightScale = 0.5, this.triangleVertexPositionBuffer, this.squareVertexPositionBuffer, this.PANEL_TEX_COORDS = [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1], this.PANEL_TEX_POS = [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1], this.QUAD_POS_BUFFER, this.QUAD_COORD_BUFFER, this.LUT_TEX, this.DATA = null, this.kernel_weights = null, this.resize(n, r), this.shaderProgram = xl(this.gl), this.lutShader = bl(this.gl), this.initBuffers(), this.setColormap();
  }
  loadIdentity() {
    this.mvMatrix = st.Matrix.I(4);
  }
  multMatrix(e) {
    this.mvMatrix = this.mvMatrix.x(e);
  }
  mvScale(e) {
    this.mvMatrix.elements[0][0] *= e[0], this.mvMatrix.elements[0][1] *= e[0], this.mvMatrix.elements[0][2] *= e[0], this.mvMatrix.elements[0][3] *= e[0], this.mvMatrix.elements[1][0] *= e[1], this.mvMatrix.elements[1][1] *= e[1], this.mvMatrix.elements[1][2] *= e[1], this.mvMatrix.elements[1][3] *= e[1], this.mvMatrix.elements[2][0] *= e[2], this.mvMatrix.elements[2][1] *= e[2], this.mvMatrix.elements[2][2] *= e[2], this.mvMatrix.elements[2][3] *= e[2];
  }
  mvTranslate(e) {
    var n = st.Matrix.Translation($V([e[0], e[1], e[2]])).ensure4x4();
    this.multMatrix(n);
  }
  perspective(e, n, r, i) {
    this.pMatrix = makePerspective(e, n, r, i);
  }
  ortho(e, n, r, i) {
    this.pMatrix = st.makeOrtho(e, n, r, i, -1, 1);
  }
  setMatrixUniforms(e) {
    this.gl.uniformMatrix4fv(e.pMatrixUniform, false, new Float32Array(this.pMatrix.flatten())), this.gl.uniformMatrix4fv(e.mvMatrixUniform, false, new Float32Array(this.mvMatrix.flatten()));
  }
  initBuffers() {
    let e = this.gl;
    this.triangleVertexPositionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
    var n = [
      0,
      1,
      0,
      -1,
      -1,
      0,
      1,
      -1,
      0
    ];
    e.bufferData(e.ARRAY_BUFFER, new Float32Array(n), e.STATIC_DRAW), this.triangleVertexPositionBuffer.itemSize = 3, this.triangleVertexPositionBuffer.numItems = 3, this.squareVertexPositionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.squareVertexPositionBuffer), n = [
      1,
      1,
      0,
      -1,
      1,
      0,
      1,
      -1,
      0,
      -1,
      -1,
      0
    ], e.bufferData(e.ARRAY_BUFFER, new Float32Array(n), e.STATIC_DRAW), this.squareVertexPositionBuffer.itemSize = 3, this.squareVertexPositionBuffer.numItems = 4, this.QUAD_POS_BUFFER = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.QUAD_POS_BUFFER), e.bufferData(e.ARRAY_BUFFER, new Float32Array(this.PANEL_TEX_POS), e.STATIC_DRAW), this.QUAD_POS_BUFFER.itemSize = 2, this.QUAD_POS_BUFFER.numItems = 6, this.QUAD_COORD_BUFFER = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.QUAD_COORD_BUFFER), e.bufferData(e.ARRAY_BUFFER, new Float32Array(this.PANEL_TEX_COORDS), e.STATIC_DRAW), this.QUAD_COORD_BUFFER.itemSize = 2, this.QUAD_COORD_BUFFER.numItems = 6, this.nodesGeometry = pr(e, false, false);
  }
  drawScene(e, n) {
    let r = this.width, i = this.height, a = this.gl, o = a.getExtension("ANGLE_instanced_arrays"), s = a.getParameter(a.FRAMEBUFFER_BINDING), l = a.getParameter(a.VIEWPORT);
    a.viewport(0, 0, r * this.qualityScale, i * this.qualityScale), this.ortho(0, r, i, 0), this.loadIdentity(), this.projectionMatrix = e, this.viewMatrix = n, a.bindFramebuffer(a.FRAMEBUFFER, this.FBO.id), a.clearColor(0, 0, 0, 1), a.clear(a.COLOR_BUFFER_BIT), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE), a.useProgram(this.shaderProgram), this.setMatrixUniforms(this.shaderProgram), a.uniform1f(this.shaderProgram.bandwidthScaleUniform, this.bandwidthScale), a.uniformMatrix4fv(this.shaderProgram.viewMatrixUniform, false, this.viewMatrix), a.uniformMatrix4fv(this.shaderProgram.projectionMatrixUniform, false, this.projectionMatrix), a.uniform2f(this.shaderProgram.bandwidthUniform, this.bandwidth[0], this.bandwidth[1]), a.uniform1f(this.shaderProgram.kernel_weightScaleUniform, this.kernel_weightScale), a.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute), a.enableVertexAttribArray(this.shaderProgram.vertexKernelWeightAttribute), a.enableVertexAttribArray(this.shaderProgram.vertexOffsetAttribute), a.bindBuffer(a.ARRAY_BUFFER, this.nodesGeometry.vertexObject), a.vertexAttribPointer(this.shaderProgram.vertexOffsetAttribute, 3, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(this.shaderProgram.vertexOffsetAttribute, 0), a.bindBuffer(a.ARRAY_BUFFER, this.kernelWeightsBuffer), a.vertexAttribPointer(this.shaderProgram.vertexKernelWeightAttribute, 1, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(this.shaderProgram.vertexKernelWeightAttribute, 1), a.bindBuffer(a.ARRAY_BUFFER, this.positionsBuffer), a.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.positionsBuffer.itemSize, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(this.shaderProgram.vertexPositionAttribute, 1), this.nodesGeometry.indexObject ? o.drawElementsInstancedANGLE(a.TRIANGLES, this.nodesGeometry.numIndices, this.nodesGeometry.indexType, 0, this.positionsBuffer.numItems) : o.drawArraysInstancedANGLE(a.TRIANGLE_STRIP, 0, this.nodesGeometry.numIndices, this.positionsBuffer.numItems), o.vertexAttribDivisorANGLE(this.shaderProgram.vertexPositionAttribute, 0), o.vertexAttribDivisorANGLE(this.shaderProgram.vertexKernelWeightAttribute, 0), a.bindFramebuffer(a.FRAMEBUFFER, s), a.disableVertexAttribArray(this.shaderProgram.vertexPositionAttribute), a.disableVertexAttribArray(this.shaderProgram.vertexKernelWeightAttribute), a.disableVertexAttribArray(this.shaderProgram.vertexOffsetAttribute), a.disable(a.BLEND), a.viewport(l[0], l[1], l[2], l[3]), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this.FBO.tex), a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this.LUT_TEX), a.useProgram(this.lutShader), a.enableVertexAttribArray(this.lutShader.vertexAttribute), a.enableVertexAttribArray(this.lutShader.texCoordAttribute), a.uniform1i(this.lutShader.input_texUniform, 0), a.uniform1i(this.lutShader.lut_texUniform, 1), a.uniform1f(this.lutShader.divergingUniform, +this._divergingColormap), this.ortho(0, 1, 0, 1), this.loadIdentity(), this.setMatrixUniforms(this.lutShader), a.bindBuffer(a.ARRAY_BUFFER, this.QUAD_POS_BUFFER), a.vertexAttribPointer(this.lutShader.vertexAttribute, this.QUAD_POS_BUFFER.itemSize, a.FLOAT, false, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this.QUAD_COORD_BUFFER), a.vertexAttribPointer(this.lutShader.texCoordAttribute, this.QUAD_COORD_BUFFER.itemSize, a.FLOAT, false, 0, 0), a.drawArrays(a.TRIANGLES, 0, this.QUAD_POS_BUFFER.numItems), a.disableVertexAttribArray(this.lutShader.vertexAttribute), a.disableVertexAttribArray(this.lutShader.texCoordAttribute);
  }
  resize(e, n, r = false) {
    (this.width !== e || this.height !== n || r) && (e > 0 && (this.width = e), n > 0 && (this.height = n), this.deleteFBO(), this.create_FBO());
  }
  create_FBO() {
    let e = this.width * this.qualityScale, n = this.height * this.qualityScale, r = this.gl;
    try {
      var i = r.getExtension("OES_texture_float"), a = r.getExtension("OES_texture_float_linear");
    } catch {
      var i = false, a = false;
    }
    let o = {};
    o.id = r.createFramebuffer(), o.tex = r.createTexture(), r.bindTexture(r.TEXTURE_2D, o.tex), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), i && a ? (le("[ OK ] Floating point textures (OES_texture_float) is supported"), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e, n, 0, r.RGBA, r.FLOAT, null)) : (le("[FAIL] Floating point textures (OES_texture_float) is <B>NOT</B> supported, falling back to 8 bit blending. OES_texture_float is supported in Chrome dev version."), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e, n, 0, r.RGBA, r.UNSIGNED_BYTE, null)), r.bindTexture(r.TEXTURE_2D, null), r.bindFramebuffer(r.FRAMEBUFFER, o.id), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, o.tex, 0);
    let s = r.checkFramebufferStatus(r.FRAMEBUFFER);
    s == r.FRAMEBUFFER_COMPLETE ? le("[ OK ] Framebuffer Initialization") : s == r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT ? le("[FAIL] Framebuffer Creation FAIL GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT <br/>               Not all framebuffer attachment points are framebuffer attachment complete.") : s == r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS ? le("[FAIL] Framebuffer Creation FAIL GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS <br/>               Not all attached images have the same width and height. ") : s == r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT ? le("[FAIL] Framebuffer Creation FAIL GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT <br/> No images are attached to the framebuffer. ") : s == r.FRAMEBUFFER_INCOMPLETE_UNSUPPORTED ? le("[FAIL] Framebuffer Creation FAIL GL_FRAMEBUFFER_INCOMPLETE_UNSUPPORTED <br/> The combination of internal formats of the attached images violates an implementation-dependent set of restrictions.") : s == r.FRAMEBUFFER_UNSUPPORTED ? le("[FAIL] Framebuffer Creation FAIL GL_FRAMEBUFFER_UNSUPPORTED <br/>             The combination of internal formats of the attached images violates an implementation-dependent set of restrictions.") : le("[FAIL] Framebuffer Creation FAIL Unknown Error"), r.bindFramebuffer(r.FRAMEBUFFER, null), this.FBO = o;
  }
  deleteFBO() {
    if (this.FBO) {
      let e = this.gl;
      e.deleteFramebuffer(this.FBO.id), e.deleteTexture(this.FBO.tex);
    }
  }
  setBandwidth(e) {
    this.bandwidthScale = e;
  }
  setKernelWeightScale(e) {
    this.kernel_weightScale = e;
  }
  setColormap(e, n = 0) {
    self = this;
    let r = this.gl, i = r.createTexture();
    r.bindTexture(r.TEXTURE_2D, i), n <= 0 && (n = 1024), e || (e = ml);
    var a = new Uint8Array(n * 4);
    for (let o = 0; o < n; o++) {
      let s = o / (n - 1), l = ut(e(s));
      a[o * 4 + 0] = l.r, a[o * 4 + 1] = l.g, a[o * 4 + 2] = l.b, a[o * 4 + 3] = 0.1;
    }
    r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, n, 1, 0, r.RGBA, r.UNSIGNED_BYTE, a), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.bindTexture(r.TEXTURE_2D, null), this.LUT_TEX = i;
  }
  setData(e) {
    this.DATA = e, this.updateTheDatabuffer();
  }
  setWeights(e) {
    this.kernel_weights = e, this.updateTheKernelWeightsBuffer();
  }
  update_span() {
    for (let e = 0; e < this.DATA.length; e += 1)
      this.DATA[e][0], this.DATA[e][1];
  }
  updateTheDatabuffer() {
    let e = this.gl;
    this.positionsBuffer || (this.positionsBuffer = e.createBuffer(), this.positionsBuffer.itemSize = 3), e.bindBuffer(e.ARRAY_BUFFER, this.positionsBuffer), e.bufferData(e.ARRAY_BUFFER, this.DATA, e.DYNAMIC_DRAW), this.positionsBuffer.numItems = this.DATA.length / 3, this.update_span();
  }
  updateTheKernelWeightsBuffer() {
    let e = this.gl;
    this.kernelWeightsBuffer || (this.kernelWeightsBuffer = e.createBuffer(), this.kernelWeightsBuffer.itemSize = 1), e.bindBuffer(e.ARRAY_BUFFER, this.kernelWeightsBuffer), e.bufferData(e.ARRAY_BUFFER, this.kernel_weights, e.DYNAMIC_DRAW), this.kernelWeightsBuffer.numItems = this.kernel_weights.length;
  }
  qualityScale(e) {
    return e === void 0 ? this.quality_scale : (this.quality_scale != e && (this.quality_scale = e, this.resize(0, 0, true)), this);
  }
  divergingColormap(e) {
    return e === void 0 ? this._divergingColormap : (this._divergingColormap != e && (this._divergingColormap = e, console.log("DIVERGING COLORMAP", e)), this);
  }
  cleanup() {
    let e = this.gl;
    e.deleteBuffer(this.positionsBuffer), e.deleteBuffer(this.kernelWeightsBuffer), e.deleteTexture(this.LUT_TEX), e.deleteProgram(this.program), e.deleteFramebuffer(this.framebuffer), e.deleteRenderbuffer(this.renderbuffer), e.deleteTexture(this.texture), e.deleteVertexArray(this.vao), this.positionsBuffer = null, this.kernelWeightsBuffer = null, this.LUT_TEX = null, this.program = null, this.framebuffer = null, this.renderbuffer = null, this.texture = null, this.vao = null, this.DATA = null, this.kernel_weights = null, this.BUFFER_LIST = null, this.gl = null;
  }
};
function El(t4, e = (n) => n.key) {
  var n = [];
  return jt(t4, "", true, (r) => n.push(r), e), n.join("");
}
function jt(t4, e, n, r, i) {
  if (t4) {
    r(`${e}${n ? "└── " : "├── "}${i(t4)}
`);
    const a = e + (n ? "    " : "│   ");
    t4.left && jt(t4.left, a, false, r, i), t4.right && jt(t4.right, a, true, r, i);
  }
}
function $t(t4) {
  if (t4 === null)
    return true;
  var e = mt(t4.left), n = mt(t4.right);
  return !!(Math.abs(e - n) <= 1 && $t(t4.left) && $t(t4.right));
}
function mt(t4) {
  return t4 ? 1 + Math.max(mt(t4.left), mt(t4.right)) : 0;
}
function Zt(t4, e, n, r, i) {
  const a = i - r;
  if (a > 0) {
    const o = r + Math.floor(a / 2), s = e[o], l = n[o], h = { key: s, data: l, parent: t4 };
    return h.left = Zt(h, e, n, r, o), h.right = Zt(h, e, n, o + 1, i), h;
  }
  return null;
}
function Kt(t4) {
  if (t4 === null)
    return 0;
  const e = Kt(t4.left), n = Kt(t4.right);
  return t4.balanceFactor = e - n, Math.max(e, n) + 1;
}
function Jt(t4, e, n, r, i) {
  if (n >= r)
    return;
  const a = t4[n + r >> 1];
  let o = n - 1, s = r + 1;
  for (; ; ) {
    do
      o++;
    while (i(t4[o], a) < 0);
    do
      s--;
    while (i(t4[s], a) > 0);
    if (o >= s)
      break;
    let l = t4[o];
    t4[o] = t4[s], t4[s] = l, l = e[o], e[o] = e[s], e[s] = l;
  }
  Jt(t4, e, n, s, i), Jt(t4, e, s + 1, r, i);
}
function kl(t4, e) {
  return t4 > e ? 1 : t4 < e ? -1 : 0;
}
function Je(t4) {
  var e = t4.right;
  return t4.right = e.left, e.left && (e.left.parent = t4), e.parent = t4.parent, e.parent && (e.parent.left === t4 ? e.parent.left = e : e.parent.right = e), t4.parent = e, e.left = t4, t4.balanceFactor += 1, e.balanceFactor < 0 && (t4.balanceFactor -= e.balanceFactor), e.balanceFactor += 1, t4.balanceFactor > 0 && (e.balanceFactor += t4.balanceFactor), e;
}
function et(t4) {
  var e = t4.left;
  return t4.left = e.right, t4.left && (t4.left.parent = t4), e.parent = t4.parent, e.parent && (e.parent.left === t4 ? e.parent.left = e : e.parent.right = e), t4.parent = e, e.right = t4, t4.balanceFactor -= 1, e.balanceFactor > 0 && (t4.balanceFactor -= e.balanceFactor), e.balanceFactor -= 1, t4.balanceFactor < 0 && (e.balanceFactor += t4.balanceFactor), e;
}
var pt = class {
  /**
   * Callback for comparator
   * @callback comparatorCallback
   * @param {Key} a
   * @param {Key} b
   * @returns {number}
   */
  /**
   * @class AVLTree
   * @constructor
   * @param  {comparatorCallback} [comparator]
   * @param  {boolean}            [noDuplicates=false] Disallow duplicates
   */
  constructor(e, n = false) {
    this._comparator = e || kl, this._root = null, this._size = 0, this._noDuplicates = !!n;
  }
  /**
   * Clear the tree
   * @return {AVLTree}
   */
  destroy() {
    return this.clear();
  }
  /**
   * Clear the tree
   * @return {AVLTree}
   */
  clear() {
    return this._root = null, this._size = 0, this;
  }
  /**
   * Number of nodes
   * @return {number}
   */
  get size() {
    return this._size;
  }
  /**
   * Whether the tree contains a node with the given key
   * @param  {Key} key
   * @return {boolean} true/false
   */
  contains(e) {
    if (this._root)
      for (var n = this._root, r = this._comparator; n; ) {
        var i = r(e, n.key);
        if (i === 0)
          return true;
        i < 0 ? n = n.left : n = n.right;
      }
    return false;
  }
  /* eslint-disable class-methods-use-this */
  /**
   * Successor node
   * @param  {Node} node
   * @return {?Node}
   */
  next(e) {
    var n = e;
    if (n)
      if (n.right)
        for (n = n.right; n.left; )
          n = n.left;
      else
        for (n = e.parent; n && n.right === e; )
          e = n, n = n.parent;
    return n;
  }
  /**
   * Predecessor node
   * @param  {Node} node
   * @return {?Node}
   */
  prev(e) {
    var n = e;
    if (n)
      if (n.left)
        for (n = n.left; n.right; )
          n = n.right;
      else
        for (n = e.parent; n && n.left === e; )
          e = n, n = n.parent;
    return n;
  }
  /* eslint-enable class-methods-use-this */
  /**
   * Callback for forEach
   * @callback forEachCallback
   * @param {Node} node
   * @param {number} index
   */
  /**
   * @param  {forEachCallback} callback
   * @return {AVLTree}
   */
  forEach(e) {
    for (var n = this._root, r = [], i = false, a = 0; !i; )
      n ? (r.push(n), n = n.left) : r.length > 0 ? (n = r.pop(), e(n, a++), n = n.right) : i = true;
    return this;
  }
  /**
   * Walk key range from `low` to `high`. Stops if `fn` returns a value.
   * @param  {Key}      low
   * @param  {Key}      high
   * @param  {Function} fn
   * @param  {*?}       ctx
   * @return {SplayTree}
   */
  range(e, n, r, i) {
    const a = [], o = this._comparator;
    let s = this._root, l;
    for (; a.length !== 0 || s; )
      if (s)
        a.push(s), s = s.left;
      else {
        if (s = a.pop(), l = o(s.key, n), l > 0)
          break;
        if (o(s.key, e) >= 0 && r.call(i, s))
          return this;
        s = s.right;
      }
    return this;
  }
  /**
   * Returns all keys in order
   * @return {Array<Key>}
   */
  keys() {
    for (var e = this._root, n = [], r = [], i = false; !i; )
      e ? (n.push(e), e = e.left) : n.length > 0 ? (e = n.pop(), r.push(e.key), e = e.right) : i = true;
    return r;
  }
  /**
   * Returns `data` fields of all nodes in order.
   * @return {Array<Value>}
   */
  values() {
    for (var e = this._root, n = [], r = [], i = false; !i; )
      e ? (n.push(e), e = e.left) : n.length > 0 ? (e = n.pop(), r.push(e.data), e = e.right) : i = true;
    return r;
  }
  /**
   * Returns node at given index
   * @param  {number} index
   * @return {?Node}
   */
  at(e) {
    for (var n = this._root, r = [], i = false, a = 0; !i; )
      if (n)
        r.push(n), n = n.left;
      else if (r.length > 0) {
        if (n = r.pop(), a === e)
          return n;
        a++, n = n.right;
      } else
        i = true;
    return null;
  }
  /**
   * Returns node with the minimum key
   * @return {?Node}
   */
  minNode() {
    var e = this._root;
    if (!e)
      return null;
    for (; e.left; )
      e = e.left;
    return e;
  }
  /**
   * Returns node with the max key
   * @return {?Node}
   */
  maxNode() {
    var e = this._root;
    if (!e)
      return null;
    for (; e.right; )
      e = e.right;
    return e;
  }
  /**
   * Min key
   * @return {?Key}
   */
  min() {
    var e = this._root;
    if (!e)
      return null;
    for (; e.left; )
      e = e.left;
    return e.key;
  }
  /**
   * Max key
   * @return {?Key}
   */
  max() {
    var e = this._root;
    if (!e)
      return null;
    for (; e.right; )
      e = e.right;
    return e.key;
  }
  /**
   * @return {boolean} true/false
   */
  isEmpty() {
    return !this._root;
  }
  /**
   * Removes and returns the node with smallest key
   * @return {?Node}
   */
  pop() {
    var e = this._root, n = null;
    if (e) {
      for (; e.left; )
        e = e.left;
      n = { key: e.key, data: e.data }, this.remove(e.key);
    }
    return n;
  }
  /**
   * Removes and returns the node with highest key
   * @return {?Node}
   */
  popMax() {
    var e = this._root, n = null;
    if (e) {
      for (; e.right; )
        e = e.right;
      n = { key: e.key, data: e.data }, this.remove(e.key);
    }
    return n;
  }
  /**
   * Find node by key
   * @param  {Key} key
   * @return {?Node}
   */
  find(e) {
    for (var n = this._root, r = n, i, a = this._comparator; r; ) {
      if (i = a(e, r.key), i === 0)
        return r;
      i < 0 ? r = r.left : r = r.right;
    }
    return null;
  }
  /**
   * Insert a node into the tree
   * @param  {Key} key
   * @param  {Value} [data]
   * @return {?Node}
   */
  insert(e, n) {
    if (!this._root)
      return this._root = {
        parent: null,
        left: null,
        right: null,
        balanceFactor: 0,
        key: e,
        data: n
      }, this._size++, this._root;
    var r = this._comparator, i = this._root, a = null, o = 0;
    if (this._noDuplicates)
      for (; i; ) {
        if (o = r(e, i.key), a = i, o === 0)
          return null;
        o < 0 ? i = i.left : i = i.right;
      }
    else
      for (; i; )
        o = r(e, i.key), a = i, o <= 0 ? i = i.left : i = i.right;
    var s = {
      left: null,
      right: null,
      balanceFactor: 0,
      parent: a,
      key: e,
      data: n
    }, l;
    for (o <= 0 ? a.left = s : a.right = s; a && (o = r(a.key, e), o < 0 ? a.balanceFactor -= 1 : a.balanceFactor += 1, a.balanceFactor !== 0); ) {
      if (a.balanceFactor < -1) {
        a.right.balanceFactor === 1 && et(a.right), l = Je(a), a === this._root && (this._root = l);
        break;
      } else if (a.balanceFactor > 1) {
        a.left.balanceFactor === -1 && Je(a.left), l = et(a), a === this._root && (this._root = l);
        break;
      }
      a = a.parent;
    }
    return this._size++, s;
  }
  /**
   * Removes the node from the tree. If not found, returns null.
   * @param  {Key} key
   * @return {?Node}
   */
  remove(e) {
    if (!this._root)
      return null;
    for (var n = this._root, r = this._comparator, i = 0; n && (i = r(e, n.key), i !== 0); )
      i < 0 ? n = n.left : n = n.right;
    if (!n)
      return null;
    var a = n.key, o, s;
    if (n.left) {
      for (o = n.left; o.left || o.right; ) {
        for (; o.right; )
          o = o.right;
        n.key = o.key, n.data = o.data, o.left && (n = o, o = o.left);
      }
      n.key = o.key, n.data = o.data, n = o;
    }
    if (n.right) {
      for (s = n.right; s.left || s.right; ) {
        for (; s.left; )
          s = s.left;
        n.key = s.key, n.data = s.data, s.right && (n = s, s = s.right);
      }
      n.key = s.key, n.data = s.data, n = s;
    }
    for (var l = n.parent, h = n, u; l && (l.left === h ? l.balanceFactor -= 1 : l.balanceFactor += 1, l.balanceFactor < -1 ? (l.right.balanceFactor === 1 && et(l.right), u = Je(l), l === this._root && (this._root = u), l = u) : l.balanceFactor > 1 && (l.left.balanceFactor === -1 && Je(l.left), u = et(l), l === this._root && (this._root = u), l = u), !(l.balanceFactor === -1 || l.balanceFactor === 1)); )
      h = l, l = l.parent;
    return n.parent && (n.parent.left === n ? n.parent.left = null : n.parent.right = null), n === this._root && (this._root = null), this._size--, a;
  }
  /**
   * Bulk-load items
   * @param  {Array<Key>}  keys
   * @param  {Array<Value>}  [values]
   * @return {AVLTree}
   */
  load(e = [], n = [], r) {
    if (this._size !== 0)
      throw new Error("bulk-load: tree is not empty");
    const i = e.length;
    return r && Jt(e, n, 0, i - 1, this._comparator), this._root = Zt(null, e, n, 0, i), Kt(this._root), this._size = i, this;
  }
  /**
   * Returns true if the tree is balanced
   * @return {boolean}
   */
  isBalanced() {
    return $t(this._root);
  }
  /**
   * String representation of the tree - primitive horizontal print-out
   * @param  {Function(Node):string} [printNode]
   * @return {string}
   */
  toString(e) {
    return El(this._root, e);
  }
};
pt.default = pt;
var Cl = class {
  constructor(e = true) {
    this.map = /* @__PURE__ */ new Map(), this.ascending = e, this.ascending ? this.tree = new pt((n, r) => n.key === r.key ? 0 : n.value === r.value ? n.key < r.key ? -1 : 1 : n.value - r.value) : this.tree = new pt((n, r) => n.key === r.key ? 0 : n.value === r.value ? n.key < r.key ? -1 : 1 : r.value - n.value);
  }
  set(e, n) {
    if (this.map.has(e)) {
      const r = this.map.get(e);
      this.tree.remove({ key: e, value: r });
    }
    this.map.set(e, n), this.tree.insert({ key: e, value: n });
  }
  delete(e) {
    if (this.map.has(e)) {
      const n = this.map.get(e);
      this.map.delete(e), this.tree.remove({ key: e, value: n });
    }
  }
  get(e) {
    return this.map.get(e);
  }
  getSortedKeys() {
    return this.tree.keys().map((e) => e.key);
  }
  getSortedPairs() {
    return this.tree.keys().map((e) => [e.key, e.value]);
  }
};
var Il = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
function Bl(t4, e = 250) {
  let n = false;
  return (...r) => {
    n || (t4(...r), n = true, setTimeout(() => {
      n = false;
    }, e));
  };
}
var Ml = class {
  // the class constructor
  /**
   * constructor description
   * @param {Object} config - The configuration object
   * @param {string} [config.elementID="helios"] - The ID of the element to attach the canvas to
   * @param {boolean} [config.density=false] - Whether to display the density
   * @param {Object} [config.nodes={}] - The nodes object. should be a dictionary of node IDs and node attributes.
   * 		@see {@link Network#addNodes}
   * @param {Object[]} [config.edges=[]] - The edges array of objects. Each object should have source and target attributes.
   * 		@see {@link Network#addEdges}
   * @param {boolean} [config.use2D=false] - Whether to use 2D mode
   * @param {boolean} [config.orthographic=false] - Whether to use orthographic projection instead of perspective
   * @param {boolean} [config.hyperbolic=false] - Whether to use hyperbolic mode
   * @param {boolean} [config.fastEdges=false] - Whether to use fast edges (edges have always 1 pixel width)
   * @param {boolean} [config.forceSupersample=false] - Whether to force supersampling (improves quality of the render even for high density displays)
   * @param {boolean} [config.autoStartLayout=true] - Whether to start the layout automatically
   * @param {boolean} [config.autoCleanup=true] - Whether to automatically cleanup helios if canvas or element is removed (useful for react and vue)
   * @param {Object} [config.webglOptions=defaults] - The webgl options object. See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext|getContext} for more information.
   * Defaults to 
   * 
   * 	{
   * 		antialias: true,
   * 		powerPreference: "high-performance",
   * 		desynchronized: true,
   * 	}
   * 
   * 
   * @example <caption>Example usage of the constructor.</caption>
   * // create a new helios object
   * let helios = new Helios({
   * 	elementID: "helios",
   * 	nodes: {
   * 		"0": {label: "Node 0"},
   * 		"1": {label: "Node 1"},
   * 		"2": {label: "Node 2"},
   * 		"3": {label: "Node 3"},
   * 	},
   * 	edges: [
   * 		{source: "0", target: "1"},
   * 		{source: "1", target: "2"},
   * 		{source: "2", target: "3"},
   * 		{source: "3", target: "0"},
   * 	],
   * });
   * 
  */
  constructor({
    element: e = null,
    elementID: n = null,
    density: r = false,
    nodes: i = {},
    edges: a = [],
    use2D: o = false,
    orthographic: s = false,
    hyperbolic: l = false,
    fastEdges: h = false,
    tracking: u = true,
    fieldOfView: f = 70,
    forceSupersample: c = false,
    autoStartLayout: d = true,
    autoCleanup: v = true,
    // cleanup helios if canvas or element is removed
    webglOptions: g = {}
  }) {
    if (this.element = null, e == null ? this.element = document.getElementById(n) : this.element = e, this.element.innerHTML = "", getComputedStyle(this.element).position === "static" && (this.container.style.position = "relative"), this.canvasElement = document.createElement("canvas"), this.canvasElement.style.position = "absolute", this.canvasElement.style.width = "100%", this.canvasElement.style.height = "100%", this.canvasElement.style.display = "block", this.canvasElement.style.boxSizing = "border-box", this.element.appendChild(this.canvasElement), this.svgLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this.svgLayer.style.position = "absolute", this.svgLayer.style.width = "100%", this.svgLayer.style.height = "100%", this.svgLayer.style.display = "block", this.svgLayer.style.boxSizing = "border-box", this.svgLayer.style.pointerEvents = "none", this.element.appendChild(this.svgLayer), this.overlay = document.createElement("div"), this.overlay.style.position = "absolute", this.overlay.style.width = "100%", this.overlay.style.height = "100%", this.overlay.style.display = "block", this.overlay.style.boxSizing = "border-box", this.overlay.style.pointerEvents = "none", this.element.appendChild(this.overlay), this.network = new So(i, a), this._autoCleanup = v, this._hasCleanup = false, this.rotationMatrix = Re(), this.translatePosition = at(), this.lastTranslatePosition = at(), this.targetTranslatePosition = at(), this.lastPanX = 0, this.lastPanY = 0, this.panX = 0, this.panY = 0, this._fieldOfView = f, this.targetPanX = 0, this.targetPanY = 0, this.translateTime = 0, this.translateDuration = 0, this.mouseDown = false, this.lastMouseX = null, this.lastMouseY = null, this.redrawingFromMouseWheelEvent = false, this.fastEdges = h, this.animate = false, this.useShadedNodes = false, this.forceSupersample = c, this.cameraDistance = 500, this.interacting = false, this.rotateLinearX = 0, this.rotateLinearY = 0, this.saveResolutionRatio = 1, this.pickingResolutionRatio = 0.25, this._trackingMaxPixels = 2e4, this._trackingBufferEnabled = u, this._trackingBuffer = null, this._trackingBufferTexture = null, this._trackingBufferPixels = null, this._attributeTrackers = {}, this._trackingNodeDataMinimumUpdateInterval = 200, this._trackingNodeMinimumUpdateInterval = 1e3 / 30, this._updateTrackerNodesDataThrottle = Bl(() => {
      this._updateTrackerNodesData();
    }, this._trackingNodeDataMinimumUpdateInterval), this._lastCanvasDimensions = [this.canvasElement.clientWidth, this.canvasElement.clientHeight], this._zoomFactor = 1, this._semanticZoomExponent = 0.25, this._nodesGlobalOpacityScale = 1, this._nodesGlobalOpacityBase = 0, this._nodesGlobalSizeScale = 1, this._nodesGlobalSizeBase = 0, this._edgesGlobalOpacityScale = 1, this._edgesGlobalOpacityBase = 0, this._edgesGlobalWidthScale = 0.25, this._edgesGlobalWidthBase = 0, this._nodesGlobalOutlineWidthScale = 1, this._nodesGlobalOutlineWidthBase = 0, this._edgesColorsFromNodes = true, this._edgesWidthFromNodes = true, this._backgroundColor = [0.5, 0.5, 0.5, 1], this._use2D = o || l, this._orthographic = s || o, this._hyperbolic = l, this._autoStartLayout = d, this.useAdditiveBlending = false, this._pickeableEdges = /* @__PURE__ */ new Set(), this.scheduler = new To(this, { throttle: false }), this._webglOptions = g, this._use2D)
      for (let x = 0; x < this.network.positions.length; x++)
        this.network.positions[x * 3 + 2] = 0;
    this._edgeIndicesUpdate = true, Tt(this.rotationMatrix), this.gl = lo(this.canvasElement, this._webglOptions), r && (this.densityMap = new wl(this.gl, this.canvasElement.clientWidth, this.canvasElement.clientHeight), this.densityMap.setBandwidth(10), this.densityMap.setKernelWeightScale(0.01), this.densityPlot = true), this._centerNodes = [], this._centerNodesTransition = null, this.onNodeClickCallback = null, this.onNodeDoubleClickCallback = null, this.onNodeHoverStartCallback = null, this.onNodeHoverMoveCallback = null, this.onNodeHoverEndCallback = null, this.onEdgeClickCallback = null, this.onEdgeDoubleClickCallback = null, this.onEdgeHoverStartCallback = null, this.onEdgeHoverMoveCallback = null, this.onEdgeHoverEndCallback = null, this.onZoomCallback = null, this.onRotationCallback = null, this.onResizeCallback = null, this.onLayoutStartCallback = null, this.onLayoutStopCallback = null, this.onDrawCallback = null, this.onReadyCallback = null, this.isReady = false, this._onresizeEvent = (x) => {
      for (let w of x)
        this._willResizeEvent(w);
    }, this.resizeObserver = new ResizeObserver(this._onresizeEvent), this.resizeObserver.observe(this.canvasElement), this._initialize();
  }
  // d3-like function Set/Get
  //zoom()
  //rotate()
  //pan()
  //highlightNodes()
  //centerNode()
  /** Initialize the webgl context 
   * @private
   * @method _initialize
   * @memberof Helios
   * @instance
   * 
  */
  _initialize() {
    var _a2;
    this._setupDensity(), this._setupShaders(), this._buildNodesGeometry(), this._buildPickingBuffers(), this._buildTrackingBuffers(), this._buildEdgesGeometry(), this._willResizeEvent(0), this._setupCamera(), this._setupEvents(), this._setupLayout(), this.scheduler.start(), (_a2 = this.onReadyCallback) == null ? void 0 : _a2.call(this, this), this.onReadyCallback = null, this.isReady = true;
  }
  /** Setup the layout worker
   * @private
   * @method _setupLayout
   * @memberof Helios
   * @instance
   */
  _setupLayout() {
    this._layoutLastUpdate = null, this._alpha = 1e-3, this.newPositions = this.network.positions.slice(0);
    let e = (i) => {
      this.newPositions = i.positions, this._layoutLastUpdate || (this._layoutLastUpdate = performance.now());
      let a = performance.now() - this._layoutLastUpdate;
      a < 200 ? a = 200 : a > 2500 && (a = 2500), this._alpha = 1 / a;
      let o = {
        name: "1.1.positionInterpolator",
        callback: (s, l) => {
          let h = 0;
          const u = this._alpha, f = this.network.positions.length, c = this.newPositions, d = this.network.positions;
          for (let v = 0; v < f; v++) {
            const g = c[v] - d[v];
            d[v] += u * g * s, h = Math.max(Math.abs(g), h);
          }
          this._updateCenterNodesPosition(), this._updateCameraInterpolation(true), h < 1 && this.scheduler.unschedule("1.1.positionInterpolator");
        },
        delay: 0,
        repeat: true,
        synchronized: true,
        immediateUpdates: false,
        redraw: true,
        updateNodesGeometry: true,
        updateEdgesGeometry: true
      };
      this.scheduler.schedule({
        name: "1.0.positionChange",
        callback: (s, l) => {
          this.scheduler.schedule(o);
        },
        delay: 0,
        repeat: false,
        synchronized: true,
        immediateUpdates: false,
        redraw: false,
        updateNodesGeometry: false,
        updateEdgesGeometry: false
      });
    }, n = () => {
      var _a2;
      (_a2 = this.onLayoutStopCallback) == null ? void 0 : _a2.call(this);
    }, r = () => {
      var _a2;
      this._layoutLastUpdate = null, (_a2 = this.onLayoutStartCallback) == null ? void 0 : _a2.call(this);
    };
    this.layoutWorker = new Do({
      network: this.network,
      onUpdate: e,
      onStop: n,
      onStart: r,
      use2D: this._use2D
    }), this._autoStartLayout && this.layoutWorker.start();
  }
  /** Setup the density map
   * @private
   * @method _setupDensity
   * @memberof Helios
   * @instance
   * 
   */
  _setupDensity() {
    if (this.densityMap) {
      this.densityWeights = new Float32Array(this.network.nodeCount);
      let e = 1;
      for (let n = 0; n < this.network.nodeCount; n++) {
        let r = this.network.nodes[n].edges.length;
        this.densityWeights[n] = r, e = Math.max(e, r);
      }
      for (let n = 0; n < this.network.nodeCount; n++)
        this.densityWeights[n] /= e;
    }
  }
  /**
   * Pauses the layout computation of the network visualization.
   * @public
   * @method pauseLayout
   * @memberof Helios
   * @instance
   * @chainable
   * @returns {this} Returns the current Helios instance for chaining
   * 
   */
  pauseLayout() {
    return this.layoutWorker.pause(), this;
  }
  /**
   * Resumes the layout computation of the network visualization after it has been paused.
   * @public
   * @method resumeLayout
   * @memberof Helios
   * @instance
   * @chainable
   * @returns {this} Returns the current Helios instance for chaining
   * 
   */
  resumeLayout() {
    return this.layoutWorker.resume(), this;
  }
  /**
   * Calls the appropriate event callback based on the given pickID, eventType, and event.
   * @private
   * @method _callEventFromPickID
   * @memberof Helios
   * @instance
   * @param {number} pickID - The unique identifier for the picked node or edge.
   * @param {string} eventType - The type of event to be triggered (e.g., click, doubleClick, hoverStart, hoverMove, hoverEnd).
   * @param {Event} event - The original DOM event associated with the interaction.
   * 
   */
  _callEventFromPickID(e, n, r) {
    var _a2, _b, _c, _d, _e2, _f, _g, _h, _i2, _j;
    let i = null, a = true;
    if (e >= 0) {
      if (e < this.network.nodeCount)
        a = true, i = this.network.index2Node[e];
      else if (e >= this.network.nodeCount) {
        let o = e - this.network.nodeCount;
        if (o < this.network.indexedEdges.length / 2) {
          let s = {
            source: this.network.index2Node[this.network.indexedEdges[2 * o]],
            target: this.network.index2Node[this.network.indexedEdges[2 * o + 1]],
            index: o
          };
          a = false, i = s;
        }
      }
    }
    if (i)
      switch (n) {
        case "click": {
          a ? (_a2 = this.onNodeClickCallback) == null ? void 0 : _a2.call(this, i, r) : (_b = this.onEdgeClickCallback) == null ? void 0 : _b.call(this, i, r);
          break;
        }
        case "doubleClick": {
          a ? (_c = this.onNodeDoubleClickCallback) == null ? void 0 : _c.call(this, i, r) : (_d = this.onEdgeDoubleClickCallback) == null ? void 0 : _d.call(this, i, r);
          break;
        }
        case "hoverStart": {
          a ? (_e2 = this.onNodeHoverStartCallback) == null ? void 0 : _e2.call(this, i, r) : (_f = this.onEdgeHoverStartCallback) == null ? void 0 : _f.call(this, i, r);
          break;
        }
        case "hoverMove": {
          a ? (_g = this.onNodeHoverMoveCallback) == null ? void 0 : _g.call(this, i, r) : (_h = this.onEdgeHoverMoveCallback) == null ? void 0 : _h.call(this, i, r);
          break;
        }
        case "hoverEnd": {
          a ? (_i2 = this.onNodeHoverEndCallback) == null ? void 0 : _i2.call(this, i, r) : (_j = this.onEdgeHoverEndCallback) == null ? void 0 : _j.call(this, i, r);
          break;
        }
      }
  }
  /**
   * Sets up event listeners for user interactions such as click, double-click, and hover events.
   * @private
   * @method _setupEvents
   * @memberof Helios
   * @instance
   * 
   */
  _setupEvents() {
    this.lastMouseX = -1, this.lastMouseY = -1, this.currentHoverIndex = -1, this._autoCleanup && (this._mutationObserver = new MutationObserver((e) => {
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        if (r.type == "childList" && r.removedNodes.length > 0)
          for (let i = 0; i < r.removedNodes.length; i++) {
            let a = r.removedNodes[i];
            if (a == this.canvasElement || a == this.element) {
              this._mutationObserver.disconnect(), this.cleanup();
              return;
            }
          }
      }
    }), this._mutationObserver.observe(this.element, { childList: true }), this._mutationObserver.observe(this.element.parentNode, { childList: true })), this._clickEventListener = (e) => {
      var _a2, _b;
      const n = this.canvasElement.getBoundingClientRect();
      this.lastMouseX = e.clientX, this.lastMouseY = e.clientY;
      const r = this.pickPoint(this.lastMouseX - n.left, this.lastMouseY - n.top);
      r >= 0 ? this._callEventFromPickID(r, "click", e) : ((_a2 = this.onNodeClickCallback) == null ? void 0 : _a2.call(this, null, e), (_b = this.onEdgeClickCallback) == null ? void 0 : _b.call(this, null, e));
    }, this._doubleClickEventListener = (e) => {
      var _a2, _b;
      const n = this.canvasElement.getBoundingClientRect();
      this.lastMouseX = e.clientX, this.lastMouseY = e.clientY;
      const r = this.pickPoint(this.lastMouseX - n.left, this.lastMouseY - n.top);
      r >= 0 ? this._callEventFromPickID(r, "doubleClick", e) : ((_a2 = this.onNodeDoubleClickCallback) == null ? void 0 : _a2.call(this, null, e), (_b = this.onEdgeDoubleClickCallback) == null ? void 0 : _b.call(this, null, e));
    }, this._hoverMoveEventListener = (e) => {
      this.lastMouseX = e.clientX, this.lastMouseY = e.clientY, this.triggerHoverEvents(e);
    }, this._hoverLeaveEventListener = (e) => {
      this.currentHoverIndex >= 0 && (this._callEventFromPickID(this.currentHoverIndex, "hoverEnd", e), this.currentHoverIndex = -1, this.lastMouseX = -1, this.lastMouseY = -1);
    }, this._hoverLeaveWindowEventListener = (e) => {
      !e.relatedTarget && !e.toElement && this.currentHoverIndex >= 0 && (this._callEventFromPickID(this.currentHoverIndex, "hoverEnd", e), this.currentHoverIndex = -1, this.lastMouseX = -1, this.lastMouseY = -1);
    }, this.canvasElement.addEventListener("click", this._clickEventListener), this.canvasElement.addEventListener("dblclick", this._doubleClickEventListener), this.canvasElement.addEventListener("mousemove", this._hoverMoveEventListener), this.canvasElement.addEventListener("mouseleave", this._hoverLeaveEventListener), document.body.addEventListener("mouseout", this._hoverLeaveWindowEventListener);
  }
  /**
   * Downloads the image data as a file with the specified filename, supersampling factor, and file format.
   * @private
   * @method _downloadImageData
   * @memberof Helios
   * @instance
   * @param {ImageData} imageData - The image data to be downloaded.
   * @param {string} filename - The name of the file to be downloaded.
   * @param {number} supersampleFactor - The supersampling factor for resizing the image.
   * @returns {Promise<void>} A Promise that resolves when the download is complete.
   */
  async _downloadImageData(e, n, r, i = 1) {
    let a = new Xt({
      // features:["all"],
    }), o = document.createElement("canvas"), s = document.createElement("canvas"), l = o.getContext("2d"), h = s.getContext("2d");
    s.width = e.width, s.height = e.height, console.log(e.width, e.height, r, i), o.width = e.width / r, o.height = e.height / r, l.imageSmoothingEnabled = true, h.imageSmoothingEnabled = true, typeof l.imageSmoothingQuality < "u" && (l.imageSmoothingQuality = "high"), typeof h.imageSmoothingQuality < "u" && (h.imageSmoothingQuality = "high"), h.putImageData(e, 0, 0), h.transform(1, 0, 0, -1, 0, s.height), h.globalCompositeOperation = "copy", h.drawImage(h.canvas, 0, 0), h.globalCompositeOperation = "source-over", await a.resize(s, o, {
      alpha: true
    });
    let u = document.createElement("a");
    Il && o.toDataURL(), u.setAttribute("download", n);
    let f = await a.toBlob(o, "image/png");
    if (f)
      if (n.endsWith("svg")) {
        let c = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  width="${o.width / i}" height="${o.height / i}" viewBox="0 0 ${o.width / i} ${o.height / i}" ><image width="${o.width / i}" height="${o.height / i}" xlink:href="${o.toDataURL()}" />`, d = this.svgLayer.innerHTML;
        c += d, c += "</svg>", u.setAttribute("download", n);
        let v = new Blob([c], { type: "image/svg+xml" }), g = URL.createObjectURL(v);
        u.setAttribute("href", g), u.click();
      } else {
        let c = URL.createObjectURL(f);
        u.setAttribute("href", c), u.click();
      }
    else
      window.alert("An error occured while trying to download the image. Please try again. (Error: blob is null.)");
  }
  /**
   * Returns the image data from the specified framebuffer.
   * @private
   * @method _framebufferImage
   * @memberof Helios
   * @instance
   * @param {WebGLFramebuffer} framebuffer - The WebGLFramebuffer from which to read the image data.
   * @returns {ImageData} An ImageData object containing the image data from the framebuffer.
   */
  _framebufferImage(e) {
    const n = e.size.width, r = e.size.height, i = new Uint8ClampedArray(4 * n * r), a = this.gl;
    return a.bindFramebuffer(a.FRAMEBUFFER, e), a.readPixels(
      0,
      // x
      0,
      // y
      n,
      // width
      r,
      // height
      a.RGBA,
      // format
      a.UNSIGNED_BYTE,
      // type
      i
    ), new ImageData(i, n, r);
  }
  /**
   * Exports the current figure to an image file.
   * @method exportFigure
   * @memberof Helios
   * @instance
   * @param {string} filename - The filename for the exported image, including the extension (e.g., "image.png").
   * @param {Object} options - An object containing export options.
   * @param {number} [options.scale=1.0] - The scale factor for the exported image.
   * @param {number} [options.supersampleFactor=4.0] - The supersampling factor for the exported image.
   * @param {number|null} [options.width=null] - The width of the exported image. If null, the current canvas width is used.
   * @param {number|null} [options.height=null] - The height of the exported image. If null, the current canvas height is used.
   * @param {string|null} [options.backgroundColor=null] - The background color of the exported image. If null, the current background color is used.
   * @example
   * helios.exportFigure("figure.png", {
   *   scale: 1.0,
   *   supersampleFactor: 4.0,
   *   width: 800,
   *   height: 600,
   *   backgroundColor: "#FFFFFF",
   * });
   */
  exportFigure(e, {
    scale: n,
    supersampleFactor: r,
    width: i = null,
    height: a = null,
    backgroundColor: o = null
  }) {
    typeof n > "u" && (n = 1), typeof r > "u" && (r = 2);
    let s = this._createOffscreenFramebuffer();
    i == null && a == null ? (i = this.canvasElement.clientWidth, a = this.canvasElement.clientHeight) : i ? a || (a = Math.round(i * this.canvasElement.height / this.canvasElement.width)) : i = Math.round(a * this.canvasElement.width / this.canvasElement.height), o || (o = this.backgroundColor), s.setSize(i * n * r, a * n * r), s.backgroundColor = o, this._redrawAll(s);
    let l = this._framebufferImage(s);
    this._downloadImageData(l, e, r, n), s.discard();
  }
  /**
   * Forces triggering hover events based on the current mouse position.
   * @method triggerHoverEvents
   * @memberof Helios
   * @instance
   * @param {Event} event - The MouseEvent object associated with the triggering event (e.g., mousemove, touchmove).
   * @param {boolean} shallCancel - If true, the method returns immediately without triggering any events.
   * @example
   * helios.triggerHoverEvents(event, false);
   */
  triggerHoverEvents(e, n) {
    if (!this.isReady || this.lastMouseX == -1 || this.lastMouseY == -1)
      return;
    let r = -1;
    if (!this.interacting) {
      const i = this.canvasElement.getBoundingClientRect();
      r = this.pickPoint(this.lastMouseX - i.left, this.lastMouseY - i.top);
    }
    r >= 0 && this.currentHoverIndex == -1 ? (this.currentHoverIndex = r, this._callEventFromPickID(r, "hoverStart", e)) : r >= 0 && this.currentHoverIndex == r ? this._callEventFromPickID(r, "hoverMove", e) : r >= 0 && this.currentHoverIndex != r ? (this._callEventFromPickID(this.currentHoverIndex, "hoverEnd", e), this.currentHoverIndex = r, this._callEventFromPickID(r, "hoverStart", e)) : r == -1 && this.currentHoverIndex != r && (this._callEventFromPickID(this.currentHoverIndex, "hoverEnd", e), this.currentHoverIndex = -1);
  }
  /**
   * Initializes the shader programs used for rendering nodes and edges.
   * @method _setupShaders
   * @memberof Helios
   * @instance
   * @private
   */
  _setupShaders() {
    const e = this.gl;
    this.edgesShaderProgram = new Ee(
      Z(e, this._hyperbolic ? Nn : Tn, e.VERTEX_SHADER),
      Z(e, Lo, e.FRAGMENT_SHADER),
      [
        "viewMatrix",
        "projectionMatrix",
        "nearFar",
        "globalOpacityScale",
        "globalWidthScale",
        "globalSizeScale",
        "globalOpacityBase",
        "globalWidthBase",
        "globalSizeBase"
      ],
      ["fromVertex", "toVertex", "vertexType", "fromColor", "toColor", "fromSize", "toSize", "encodedIndex"],
      this.gl
    ), this.edgesFastShaderProgram = new Ee(
      Z(e, this._hyperbolic ? Go : Qo, e.VERTEX_SHADER),
      Z(e, Vo, e.FRAGMENT_SHADER),
      ["projectionViewMatrix", "nearFar", "globalOpacityScale", "globalOpacityBase"],
      ["vertex", "color"],
      this.gl
    ), this.edgesPickingShaderProgram = new Ee(
      Z(e, this._hyperbolic ? Nn : Tn, e.VERTEX_SHADER),
      Z(e, Uo, e.FRAGMENT_SHADER),
      [
        "viewMatrix",
        "projectionMatrix",
        "nearFar",
        "globalOpacityScale",
        "globalWidthScale",
        "globalSizeScale",
        "globalOpacityBase",
        "globalWidthBase",
        "globalSizeBase"
      ],
      ["fromVertex", "toVertex", "vertexType", "fromColor", "toColor", "fromSize", "toSize", "encodedIndex"],
      this.gl
    ), this.nodesShaderProgram = new Ee(
      Z(e, this._hyperbolic ? Ot : Pt, e.VERTEX_SHADER),
      Z(e, Wo, e.FRAGMENT_SHADER),
      [
        "viewMatrix",
        "projectionMatrix",
        "normalMatrix",
        "globalOpacityScale",
        "globalSizeScale",
        "globalOutlineWidthScale",
        "globalOpacityBase",
        "globalSizeBase",
        "globalOutlineWidthBase"
      ],
      ["vertex", "position", "color", "size", "outlineWidth", "outlineColor", "encodedIndex"],
      this.gl
    ), this.nodesFastShaderProgram = new Ee(
      Z(e, this._hyperbolic ? Ot : Pt, e.VERTEX_SHADER),
      Z(e, Yo, e.FRAGMENT_SHADER),
      [
        "viewMatrix",
        "projectionMatrix",
        "normalMatrix",
        "globalOpacityScale",
        "globalSizeScale",
        "globalOutlineWidthScale",
        "globalOpacityBase",
        "globalSizeBase",
        "globalOutlineWidthBase"
      ],
      ["vertex", "position", "color", "size", "outlineWidth", "outlineColor", "encodedIndex"],
      this.gl
    ), this.nodesPickingShaderProgram = new Ee(
      Z(e, this._hyperbolic ? Ot : Pt, e.VERTEX_SHADER),
      Z(e, Ho, e.FRAGMENT_SHADER),
      [
        "viewMatrix",
        "projectionMatrix",
        "normalMatrix",
        "globalOpacityScale",
        "globalSizeScale",
        "globalOutlineWidthScale",
        "globalOpacityBase",
        "globalSizeBase",
        "globalOutlineWidthBase"
      ],
      ["vertex", "position", "color", "size", "outlineWidth", "outlineColor", "encodedIndex"],
      this.gl
    );
  }
  /**
   * Initializes the picking framebuffer used for object selection.
   * @method _buildPickingBuffers
   * @memberof Helios
   * @instance
   * @private
   */
  _buildPickingBuffers() {
    this.gl, this.pickingFramebuffer = this._createOffscreenFramebuffer();
  }
  /**
   * Initializes the tracking framebuffer used for getting the displayed objects.
   * @method _buildTrackingBuffers
   * @memberof Helios
   * @instance
   * @private
   */
  _buildTrackingBuffers() {
    this.gl, this._trackingBufferEnabled && (this._trackingFramebuffer = this._createOffscreenFramebuffer());
  }
  /**
   * Creates and initializes an offscreen framebuffer for rendering operations.
   * @method createOffscreenFramebuffer
   * @memberof Helios
   * @instance
   * @returns {WebGLFramebuffer} An offscreen framebuffer with associated texture and depth buffer.
   * @private
   */
  _createOffscreenFramebuffer() {
    const e = this.gl;
    let n = e.createFramebuffer();
    n.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, n.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n.depthBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, n.depthBuffer), e.bindFramebuffer(e.FRAMEBUFFER, n), n.size = {
      width: 0,
      height: 0
    }, n.setSize = (a, o) => {
      e.bindTexture(e.TEXTURE_2D, n.texture);
      const s = 0, l = e.RGBA, h = 0, u = e.RGBA, f = e.UNSIGNED_BYTE, c = null, d = a, v = o;
      e.texImage2D(
        e.TEXTURE_2D,
        s,
        l,
        d,
        v,
        h,
        u,
        f,
        c
      ), e.bindRenderbuffer(e.RENDERBUFFER, n.depthBuffer), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, d, v), n.size.width = a, n.size.height = o;
    }, n.discard = () => {
      e.deleteRenderbuffer(n.depthBuffer), e.deleteTexture(n.texture), e.deleteFramebuffer(n);
    };
    const r = e.COLOR_ATTACHMENT0, i = 0;
    return e.framebufferTexture2D(e.FRAMEBUFFER, r, e.TEXTURE_2D, n.texture, i), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, n.depthBuffer), n;
  }
  /**
   * Builds the nodes geometry and creates related WebGL buffers.
   * @method _buildNodesGeometry
   * @memberof Helios
   * @instance
   * @private
   */
  _buildNodesGeometry() {
    const e = this.gl;
    this.nodesGeometry = pr(e, false, false), this.nodesPositionBuffer = e.createBuffer(), this.nodesColorBuffer = e.createBuffer(), this.nodesSizeBuffer = e.createBuffer(), this.nodesOutlineWidthBuffer = e.createBuffer(), this.nodesOutlineColorBuffer = e.createBuffer(), this.nodesIndexBuffer = e.createBuffer(), this.nodesIndexArray = new Float32Array(this.network.index2Node.length * 4);
    for (let n = 0; n < this.network.index2Node.length; n++)
      this.nodesIndexArray[4 * n] = (n + 1 >> 0 & 255) / 255, this.nodesIndexArray[4 * n + 1] = (n + 1 >> 8 & 255) / 255, this.nodesIndexArray[4 * n + 2] = (n + 1 >> 16 & 255) / 255, this.nodesIndexArray[4 * n + 3] = (n + 1 >> 24 & 255) / 255;
    e.bindBuffer(e.ARRAY_BUFFER, this.nodesIndexBuffer), e.bufferData(e.ARRAY_BUFFER, this.nodesIndexArray, e.STATIC_DRAW), this.updateNodesGeometry();
  }
  /** Updates the density map with the current node positions.
   * @method updateDensityMap
   * @memberof Helios
   * @instance
   * @chainable
   * @example<caption>Update the density map</caption>
   * helios.updateDensityMap();
   * @example<caption>Update the density map and render the scene</caption>
   * helios.updateDensityMap().render();
   * @returns {this} Returns the current Helios instance for chaining.
   */
  updateDensityMap() {
    var _a2, _b;
    let e = this.network.positions;
    return (_a2 = this.densityMap) == null ? void 0 : _a2.setData(e), (_b = this.densityMap) == null ? void 0 : _b.setWeights(this.densityWeights), this;
  }
  /** Force update of Nodes Geometry.
   * @method updateNodesGeometry
   * @memberof Helios
   * @instance
   * @chainable
   * @example<caption>Update the nodes geometry</caption>
   * helios.updateNodesGeometry();
   * @example<caption>Update the nodes geometry and render the scene</caption>
   * helios.updateNodesGeometry().render();
   * @returns {this} Returns the current Helios instance for chaining.
   */
  updateNodesGeometry() {
    const e = this.gl;
    let n = this.network.positions;
    this.updateDensityMap(), e.bindBuffer(e.ARRAY_BUFFER, this.nodesPositionBuffer), e.bufferData(e.ARRAY_BUFFER, n, e.DYNAMIC_DRAW);
    let r = this.network.colors;
    e.bindBuffer(e.ARRAY_BUFFER, this.nodesColorBuffer), e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW);
    let i = this.network.sizes;
    e.bindBuffer(e.ARRAY_BUFFER, this.nodesSizeBuffer), e.bufferData(e.ARRAY_BUFFER, i, e.STATIC_DRAW);
    let a = this.network.outlineWidths;
    e.bindBuffer(e.ARRAY_BUFFER, this.nodesOutlineWidthBuffer), e.bufferData(e.ARRAY_BUFFER, a, e.STATIC_DRAW);
    let o = this.network.outlineColors;
    return e.bindBuffer(e.ARRAY_BUFFER, this.nodesOutlineColorBuffer), e.bufferData(e.ARRAY_BUFFER, o, e.STATIC_DRAW), this;
  }
  /** Initializes the geometry and buffers used for rendering edges.
   * @method _buildFastEdgesGeometry
   * @memberof Helios
   * @instance
   * @private
   */
  _buildFastEdgesGeometry() {
    const e = this.gl;
    let n = this.network.indexedEdges, r = this.network.positions;
    this.network.colors;
    let i;
    this.fastEdgesGeometry = null, this.fastEdgesIndicesArray = null;
    let a = new Object();
    if (r.length < 65535)
      i = new Uint16Array(n), a.indexType = e.UNSIGNED_SHORT;
    else {
      var o = e.getExtension("OES_element_index_uint");
      o == null ? (i = new Uint16Array(n), a.indexType = e.UNSIGNED_SHORT) : (i = new Uint32Array(n), a.indexType = e.UNSIGNED_INT);
    }
    a.vertexObject = e.createBuffer(), a.colorObject = e.createBuffer(), a.numIndices = i.length, a.indexObject = e.createBuffer(), this.fastEdgesGeometry = a, this.fastEdgesIndicesArray = i;
  }
  /** Initializes the geometry and buffers used for advanced rendering edges.
   * @method _buildAdvancedEdgesGeometry
   * @memberof Helios
   * @instance
   * @private
   */
  _buildAdvancedEdgesGeometry() {
    const e = this.gl;
    let n = [
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      0
    ], r = new Object();
    r.edgeVertexTypeBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, r.edgeVertexTypeBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array(n), e.STATIC_DRAW), r.verticesBuffer = e.createBuffer(), r.colorBuffer = e.createBuffer(), r.sizeBuffer = e.createBuffer(), r.indexBuffer = e.createBuffer(), this.edgesGeometry = r, this.edgesGeometry.count = this.network.indexedEdges.length / 2, this.edgesGeometry.edgesIndexArray = new Float32Array(this.network.indexedEdges.length * 4 / 2), this._edgeIndicesUpdate = true;
  }
  /** Initializes the geometry and buffers used for rendering edges.
   * @method _buildEdgesGeometry
   * @memberof Helios
   * @instance
   * @private
   */
  _buildEdgesGeometry() {
    this.fastEdges ? this._buildFastEdgesGeometry() : this._buildAdvancedEdgesGeometry(), this.updateEdgesGeometry();
  }
  /** Updates the indices used for picking edges.
   * @method _updateEdgeIndices
   * @memberof Helios
   * @instance
   * @private
   */
  _updateEdgeIndices() {
    if (this._edgeIndicesUpdate) {
      const e = this.gl;
      for (let n = 0; n < this.network.indexedEdges.length / 2; n++) {
        let r = this.network.index2Node.length + n;
        this._pickeableEdges.has(n) ? (this.edgesGeometry.edgesIndexArray[4 * n] = (r + 1 >> 0 & 255) / 255, this.edgesGeometry.edgesIndexArray[4 * n + 1] = (r + 1 >> 8 & 255) / 255, this.edgesGeometry.edgesIndexArray[4 * n + 2] = (r + 1 >> 16 & 255) / 255, this.edgesGeometry.edgesIndexArray[4 * n + 3] = (r + 1 >> 24 & 255) / 255) : (this.edgesGeometry.edgesIndexArray[4 * n] = 0, this.edgesGeometry.edgesIndexArray[4 * n + 1] = 0, this.edgesGeometry.edgesIndexArray[4 * n + 2] = 0, this.edgesGeometry.edgesIndexArray[4 * n + 3] = 0);
      }
      e.bindBuffer(e.ARRAY_BUFFER, this.edgesGeometry.indexBuffer), e.bufferData(e.ARRAY_BUFFER, this.edgesGeometry.edgesIndexArray, e.DYNAMIC_DRAW), this._edgeIndicesUpdate = false;
    }
  }
  /** Updates the geometry and buffers used for rendering edges.
   * @method updateEdgesGeometry
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} [force=false] - Forces the update of the geometry and buffers.
   * @returns {this} Returns the current Helios instance for chaining.
   */
  updateEdgesGeometry() {
    const e = this.gl;
    this.network.indexedEdges;
    let n = this.network.positions, r = this.network.colors;
    if (this.fastEdges)
      this.fastEdgesGeometry || this._buildEdgesGeometry(), e.bindBuffer(e.ARRAY_BUFFER, this.fastEdgesGeometry.vertexObject), e.bufferData(e.ARRAY_BUFFER, n, e.STREAM_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this.fastEdgesGeometry.colorObject), e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.fastEdgesGeometry.indexObject), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.fastEdgesIndicesArray, e.STREAM_DRAW);
    else {
      const i = this.gl;
      this.network.updateEdgePositions(), this._edgesColorsFromNodes && this.network.updateEdgeColors(), this._edgesWidthFromNodes && this.network.updateEdgeSizes(), this._updateEdgeIndices(), this.network.positions, i.bindBuffer(i.ARRAY_BUFFER, this.edgesGeometry.verticesBuffer), i.bufferData(i.ARRAY_BUFFER, this.network.edgePositions, i.DYNAMIC_DRAW), i.bindBuffer(i.ARRAY_BUFFER, this.edgesGeometry.colorBuffer), i.bufferData(i.ARRAY_BUFFER, this.network.edgeColors, i.DYNAMIC_DRAW), i.bindBuffer(i.ARRAY_BUFFER, this.edgesGeometry.sizeBuffer), i.bufferData(i.ARRAY_BUFFER, this.network.edgeSizes, i.DYNAMIC_DRAW);
    }
    return this;
  }
  /** Updates the all the framebuffers
   * @method _updatePickingFramebufferSize
   * @memberof Helios
   * @instance
   * @private
   * @param {number} newWidth - The new width of the framebuffers.
   * @param {number} newHeight - The new height of the framebuffers.
   * @returns {this} Returns the current Helios instance for chaining.
   */
  _resizeGL(e, n) {
    this.canvasElement.width = e, this.canvasElement.height = n, this.pickingFramebuffer.setSize(Math.round(e * this.pickingResolutionRatio), Math.round(n * this.pickingResolutionRatio)), this._lastCanvasDimensions = [this.canvasElement.clientWidth, this.canvasElement.clientHeight];
    let r = e / n;
    if (this._trackingBufferEnabled) {
      let i, a;
      r > 1 ? (i = Math.sqrt(this._trackingMaxPixels * r), a = this._trackingMaxPixels / i) : (a = Math.sqrt(this._trackingMaxPixels / r), i = this._trackingMaxPixels / a), this._trackingFramebuffer.setSize(Math.round(i), Math.round(a));
      let o = this._trackingFramebuffer.size.width * this._trackingFramebuffer.size.height;
      this._pixelXYOnScreen = Array(o), this._trackingBufferPixels = new Uint8Array(4 * o), this._nodesOnScreen = Array(o), this._nodesOnScreen.fill(-1);
      for (let s = 0; s < this._pixelXYOnScreen.length; s++) {
        let l = s % this._trackingFramebuffer.size.width / this._trackingFramebuffer.size.width * this.canvasElement.clientWidth, h = Math.floor(s / this._trackingFramebuffer.size.width) / this._trackingFramebuffer.size.height * this.canvasElement.clientHeight;
        this._pixelXYOnScreen[s] = [l, h];
      }
    }
    return this.densityPlot && this.densityMap.resize(e, n), this.render(true), this;
  }
  /** Setup the camera data.
   * @method _setupCamera
   * @memberof Helios
   * @instance
   * @private
   */
  _setupCamera() {
    this.zoom = Js().on("zoom", (e) => {
      var _a2;
      this.interacting = true, this._zoomFactor = e.transform.k, this.triggerHoverEvents(e), this.prevK === void 0 && (this.prevK = e.transform.k);
      let n = 0, r = 0;
      (this.prevK == e.transform.k || this._use2D) && (this.prevX === void 0 || this._use2D ? this._use2D ? (n = e.transform.x - this.canvasElement.clientWidth / 2, r = e.transform.y - this.canvasElement.clientHeight / 2) : (n = e.transform.x, r = e.transform.y) : (n = e.transform.x - this.prevX * this._zoomFactor, r = e.transform.y - this.prevY * this._zoomFactor)), this._use2D || (this.prevX = e.transform.x / this._zoomFactor, this.prevY = e.transform.y / this._zoomFactor), this.prevK = e.transform.k;
      let i = Re();
      if (this._use2D || ((_a2 = e.sourceEvent) == null ? void 0 : _a2.shiftKey)) {
        const a = this.canvasElement.clientHeight, o = Math.PI * 2 / 360 * this._fieldOfView, l = 2 * (this.cameraDistance / this._zoomFactor) * Math.tan(o / 2) / a;
        this._centerNodes.length == 0 && (this._use2D ? (this.panX = n * l, this.panY = -r * l) : (this.panX = this.panX + n * l, this.panY = this.panY - r * l));
      } else
        Tt(i), Fn(i, i, Mn(n / 2), [0, 1, 0]), Fn(i, i, Mn(r / 2), [1, 0, 0]), Nt(this.rotationMatrix, i, this.rotationMatrix);
      this.update(), this.render();
    }).on("end", (e) => {
      this.interacting = false;
    }), j(this.canvasElement).call(this.zoom).on("dblclick.zoom", null);
  }
  /** Set the zoom factor.
   * @method zoomFactor
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} zoomFactor - The zoom factor.
   * @param {number} [duration] - The duration of the zoom animation in milliseconds.
   * @returns {this | number} Returns this for chaining if zoomFactor is defined, otherwise returns the current zoom factor.
   * @example
   * // Set the zoom factor to 0.5
   * helios.zoomFactor(0.5);
   * @example
   * // Set the zoom factor to 0.5 with an animation duration of 500 milliseconds
   * helios.zoomFactor(0.5, 500);
   * @example
   * // Get the current zoom factor
   * let zoomFactor = helios.zoomFactor();
   */
  zoomFactor(e, n) {
    return e !== void 0 ? (n === void 0 ? this._use2D ? j(this.canvasElement).call(
      this.zoom.transform,
      _e.translate(this.canvasElement.clientWidth / 2, this.canvasElement.clientHeight / 2).scale(e)
    ) : j(this.canvasElement).call(this.zoom.transform, _e.translate(0, 0).scale(e)) : this._use2D ? j(this.canvasElement).transition().ease(un).duration(n).call(this.zoom.transform, _e.translate(this.canvasElement.clientWidth / 2, this.canvasElement.clientHeight / 2).scale(e)) : j(this.canvasElement).transition().ease(un).duration(n).call(this.zoom.transform, _e.translate(0, 0).scale(e)), this) : this._zoomFactor;
  }
  /** Set the semantic zoom exponent.
   * @method semanticZoomExponent
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} semanticZoomExponent - The semantic zoom exponent.
   * @returns {this | number} Returns this for chaining if semanticZoomExponent is defined, otherwise returns the current semantic zoom exponent.
   * @example
   * // Set the semantic zoom exponent to 0.5
   * helios.semanticZoomExponent(0.5);
   * @example
   * // Get the current semantic zoom exponent
   * let semanticZoomExponent = helios.semanticZoomExponent();
   */
  semanticZoomExponent(e) {
    return e !== void 0 ? (this._semanticZoomExponent = e, this) : this._semanticZoomExponent;
  }
  /** Will resize event helper function
   * @method _willResizeEvent
   * @memberof Helios
   * @instance
   * @private
   * @param {Event} event - The resize event.
   */
  _willResizeEvent(e) {
    var _a2;
    let n = window.devicePixelRatio || 1;
    (n < 2 || this.forceSupersample) && (n = n * 2);
    let r = n * this.canvasElement.clientWidth, i = n * this.canvasElement.clientHeight;
    requestAnimationFrame(() => {
      this._resizeGL(r, i);
    }), this._updateCameraInteraction(), (_a2 = this.onResizeCallback) == null ? void 0 : _a2.call(this, e);
  }
  /** Update Camera Interaction.
   * @method _updateCameraInteraction
   * @memberof Helios
   * @instance
   * @private
   * @chainable
   * @returns {this} Returns this for chaining.
   */
  _updateCameraInteraction() {
    if (this.zoom && this._use2D) {
      const e = this.canvasElement.clientHeight, n = Math.PI * 2 / 360 * this._fieldOfView, i = 2 * (this.cameraDistance / this._zoomFactor) * Math.tan(n / 2) / e;
      j(this.canvasElement).property(
        "__zoom",
        _e.translate(
          this.panX / i + this._lastCanvasDimensions[0] / 2,
          -this.panY / i + this._lastCanvasDimensions[1] / 2
        ).scale(this._zoomFactor)
      );
    }
  }
  /** Will hint force Helios to redraw the network.
   * @method redraw
   * @memberof Helios
   * @instance
   * @chainable
   * @returns {this} Returns this for chaining.
   * @fires Helios#redraw
   * @fires Helios#draw
   * @fires Helios#HoverEvent
   * @example
   * // Redraw the network
   * helios.redraw();
   * @example
   * // Update geometry and redraw the network
   * helios.update().redraw();
   */
  redraw() {
    var _a2;
    return this._redrawAll(null, "normal"), this._redrawAll(this.pickingFramebuffer, "picking"), this._trackingBufferEnabled && this._redrawAll(this._trackingFramebuffer, "tracking"), this.triggerHoverEvents(null), this._updateTrackerNodesDataThrottle(), (_a2 = this.onDrawCallback) == null ? void 0 : _a2.call(this), this;
  }
  /** Will hint or force Helios to update the network geometry.
   * this method needs to be called after any changes to the network data
   * or visual properties.
   * @method update
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} [immediate=false] - If true, the update will be performed immediately, otherwise it will be scheduled.
   * @param {boolean} [nodes=true] - If true, the node geometry will be updated.
   * @param {boolean} [edges=true] - If true, the edge geometry will be updated.
   * @returns {this} Returns this for chaining.
   * @example
   * // Update the network geometry
   * helios.update();
   * @example
   * // Update the network geometry immediately
   * helios.update(true);
   */
  update(e = false, n = true, r = true) {
    return this.scheduler.schedule({
      name: "9.0.update",
      callback: null,
      delay: 0,
      repeat: false,
      synchronized: true,
      immediateUpdates: e,
      // redraw: true,
      updateNodesGeometry: n,
      updateEdgesGeometry: r
    }), this;
  }
  /** Will hint or force Helios to render the network.
   * @method render
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} [immediate=false] - If true, the render will be performed immediately, otherwise it will be scheduled.
   * @returns {this} Returns this for chaining.
   * @example
   * // Render the network
   * helios.render();
   * @example
   * // Update geometry and render the network
   * helios.update().render();
   */
  render(e = false) {
    return this.scheduler.schedule({
      name: "9.1.render",
      callback: null,
      delay: 0,
      repeat: false,
      synchronized: true,
      immediateUpdates: e,
      redraw: true
      // updateNodesGeometry: true,
      // updateEdgesGeometry: true,
    }), this;
  }
  /** Helper method to prepare drawing framebuffers
   * @method _redrawPrepare
   * @memberof Helios
   * @instance
   * @private
   * @param {WebGLFramebuffer} destination - The destination framebuffer.
   * @param {boolean} isPicking - If true, the framebuffer is used for picking.
   * @param {Object} viewport - The viewport to use.
   */
  _redrawPrepare(e, n, r) {
    typeof n > "u" && (n = "normal");
    const i = this.gl, a = (e == null ? void 0 : e.size.width) || this.canvasElement.width, o = (e == null ? void 0 : e.size.height) || this.canvasElement.height;
    e == null ? (i.bindFramebuffer(i.FRAMEBUFFER, null), i.clearColor(...this._backgroundColor)) : n != "normal" ? (i.bindFramebuffer(i.FRAMEBUFFER, e), i.clearColor(0, 0, 0, 0)) : (i.bindFramebuffer(i.FRAMEBUFFER, e), typeof e.backgroundColor > "u" ? i.clearColor(...this._backgroundColor) : i.clearColor(...e.backgroundColor)), typeof r > "u" ? i.viewport(0, 0, a, o) : i.viewport(...r), i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT), i.depthFunc(i.LEQUAL), this.projectionMatrix = Re(), this.viewMatrix = Re(), this.projectionViewMatrix = Re();
    let s = Math.PI * 2 / 360 * this._fieldOfView, l = a / o;
    if (this._use2D || this._orthographic) {
      const h = this.cameraDistance / this._zoomFactor, u = 2 * h * Math.tan(s / 2), f = u * l, c = -f / 2, d = f / 2, v = -u / 2, g = u / 2;
      so(
        this.projectionMatrix,
        c,
        d,
        v,
        g,
        -100 + h,
        1e4 + h
      );
    } else
      io(this.projectionMatrix, s, l, 1, null);
    Tt(this.viewMatrix), Bn(this.viewMatrix, this.viewMatrix, [this.panX, this.panY, -this.cameraDistance / this._zoomFactor]), Nt(this.viewMatrix, this.viewMatrix, this.rotationMatrix), Bn(this.viewMatrix, this.viewMatrix, this.translatePosition), Nt(this.projectionViewMatrix, this.projectionMatrix, this.viewMatrix);
  }
  /** Helper method to draw nodes
   * @method _redrawNodes
   * @memberof Helios
   * @instance
   * @private
   * @param {WebGLFramebuffer} destination - The destination framebuffer.
   * @param {boolean} isPicking - If true, the framebuffer is used for picking.
   */
  _redrawNodes(e, n) {
    typeof n > "u" && (n = "normal");
    const r = this.gl;
    let i = r.getExtension("ANGLE_instanced_arrays"), a = 1 / Math.pow(this._zoomFactor, this._semanticZoomExponent);
    n != "normal" && (a = 1 / Math.pow(this._zoomFactor, 0.75 * this._semanticZoomExponent));
    let o;
    n == "normal" ? (r.enable(r.BLEND), r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), this.useShadedNodes ? o = this.nodesShaderProgram : o = this.nodesFastShaderProgram) : (r.disable(r.BLEND), o = this.nodesPickingShaderProgram), o.use(r), o.attributes.enable("vertex"), o.attributes.enable("position"), o.attributes.enable("size"), o.attributes.enable("outlineWidth"), o.attributes.enable("outlineColor"), o.attributes.enable("encodedIndex"), r.bindBuffer(r.ARRAY_BUFFER, this.nodesGeometry.vertexObject), r.vertexAttribPointer(o.attributes.vertex, 3, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.vertex, 0), this.nodesGeometry.indexObject && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.nodesGeometry.indexObject), r.uniformMatrix4fv(o.uniforms.projectionMatrix, false, this.projectionMatrix), r.uniformMatrix4fv(o.uniforms.viewMatrix, false, this.viewMatrix), r.uniform1f(o.uniforms.globalOpacityScale, this._nodesGlobalOpacityScale), r.uniform1f(o.uniforms.globalOpacityBase, this._nodesGlobalOpacityBase), r.uniform1f(o.uniforms.globalSizeScale, this._nodesGlobalSizeScale * a), r.uniform1f(o.uniforms.globalSizeBase, this._nodesGlobalSizeBase * a), r.uniform1f(o.uniforms.globalOutlineWidthScale, this._nodesGlobalOutlineWidthScale * a), r.uniform1f(o.uniforms.globalOutlineWidthBase, this._nodesGlobalOutlineWidthBase * a);
    let s = to();
    no(s, this.viewMatrix), r.uniformMatrix3fv(o.uniforms.normalMatrix, false, s), this.network.colors, this.network.positions, this.network.sizes, this.network.outlineWidths, r.bindBuffer(r.ARRAY_BUFFER, this.nodesPositionBuffer), r.enableVertexAttribArray(o.attributes.position), r.vertexAttribPointer(o.attributes.position, 3, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.position, 1), r.bindBuffer(r.ARRAY_BUFFER, this.nodesColorBuffer), r.enableVertexAttribArray(o.attributes.color), r.vertexAttribPointer(o.attributes.color, 4, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.color, 1), r.bindBuffer(r.ARRAY_BUFFER, this.nodesSizeBuffer), r.enableVertexAttribArray(o.attributes.size), r.vertexAttribPointer(o.attributes.size, 1, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.size, 1), r.bindBuffer(r.ARRAY_BUFFER, this.nodesOutlineColorBuffer), r.enableVertexAttribArray(o.attributes.outlineColor), r.vertexAttribPointer(o.attributes.outlineColor, 4, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.outlineColor, 1), r.bindBuffer(r.ARRAY_BUFFER, this.nodesOutlineWidthBuffer), r.enableVertexAttribArray(o.attributes.outlineWidth), r.vertexAttribPointer(o.attributes.outlineWidth, 1, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.outlineWidth, 1), r.bindBuffer(r.ARRAY_BUFFER, this.nodesIndexBuffer), r.enableVertexAttribArray(o.attributes.encodedIndex), r.vertexAttribPointer(o.attributes.encodedIndex, 4, r.FLOAT, false, 0, 0), i.vertexAttribDivisorANGLE(o.attributes.encodedIndex, 1), this.nodesGeometry.indexObject ? i.drawElementsInstancedANGLE(r.TRIANGLES, this.nodesGeometry.numIndices, this.nodesGeometry.indexType, 0, this.network.positions.length / 3) : i.drawArraysInstancedANGLE(r.TRIANGLE_STRIP, 0, this.nodesGeometry.numIndices, this.network.positions.length / 3), o.attributes.disable("vertex"), o.attributes.disable("position"), o.attributes.disable("size"), o.attributes.disable("outlineWidth"), o.attributes.disable("outlineColor"), o.attributes.disable("encodedIndex");
  }
  /** Helper function to redraw the edges
   * @method _redrawEdges
   * @memberof Helios
   * @instance
   * @private
   * @param {WebGLFramebuffer} destination - The destination framebuffer.
   * @param {String} framebufferType - The type of framebuffer to render to (normal, picking, or tracking).
   */
  _redrawEdges(e, n) {
    typeof n > "u" && (n = "normal");
    let r = this.onEdgeClickCallback || this.onEdgeHoverMoveCallback || this.onEdgeHoverStartCallback || this.onEdgeHoverEndCallback || this.onEdgeDoubleClickCallback || this.onEdgeClickCallback;
    if (n != "normal" && (this.fastEdges || !r))
      return;
    let i = 1 / Math.pow(this._zoomFactor, this._semanticZoomExponent);
    n != "normal" && (i = 1 / Math.pow(this._zoomFactor, 0.5 * this._semanticZoomExponent));
    const a = this.gl;
    let o = a.getExtension("ANGLE_instanced_arrays"), s;
    n == "normal" ? (a.enable(a.BLEND), this.useAdditiveBlending ? a.blendFunc(a.SRC_ALPHA, a.ONE) : a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE), this.fastEdges ? s = this.edgesFastShaderProgram : s = this.edgesShaderProgram) : (a.disable(a.BLEND), s = this.edgesPickingShaderProgram), this.fastEdges ? (s.use(a), s.attributes.enable("vertex"), s.attributes.enable("color"), a.bindBuffer(a.ARRAY_BUFFER, this.fastEdgesGeometry.vertexObject), a.vertexAttribPointer(s.attributes.vertex, 3, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(s.attributes.vertex, 0), a.bindBuffer(a.ARRAY_BUFFER, this.fastEdgesGeometry.colorObject), a.vertexAttribPointer(s.attributes.color, 4, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(s.attributes.color, 0), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.fastEdgesGeometry.indexObject), a.uniformMatrix4fv(s.uniforms.projectionViewMatrix, false, this.projectionViewMatrix), a.uniform1f(s.uniforms.globalOpacityScale, this._edgesGlobalOpacityScale), a.uniform1f(s.uniforms.globalOpacityBase, this._edgesGlobalOpacityBase), a.drawElements(a.LINES, this.fastEdgesGeometry.numIndices, this.fastEdgesGeometry.indexType, 0), s.attributes.disable("vertex"), s.attributes.disable("color")) : (s.use(a), s.attributes.enable("fromVertex"), s.attributes.enable("toVertex"), s.attributes.enable("vertexType"), s.attributes.enable("fromColor"), s.attributes.enable("toColor"), s.attributes.enable("fromSize"), s.attributes.enable("toSize"), s.attributes.enable("encodedIndex"), a.bindBuffer(a.ARRAY_BUFFER, this.edgesGeometry.edgeVertexTypeBuffer), a.vertexAttribPointer(s.attributes.vertexType, 2, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(s.attributes.vertexType, 0), a.bindBuffer(a.ARRAY_BUFFER, this.edgesGeometry.verticesBuffer), a.vertexAttribPointer(s.attributes.fromVertex, 3, a.FLOAT, false, 4 * 3 * 2, 0), o.vertexAttribDivisorANGLE(s.attributes.fromVertex, 1), a.bindBuffer(a.ARRAY_BUFFER, this.edgesGeometry.verticesBuffer), a.vertexAttribPointer(s.attributes.toVertex, 3, a.FLOAT, false, 4 * 3 * 2, 4 * 3), o.vertexAttribDivisorANGLE(s.attributes.toVertex, 1), a.bindBuffer(a.ARRAY_BUFFER, this.edgesGeometry.colorBuffer), a.vertexAttribPointer(s.attributes.fromColor, 4, a.FLOAT, false, 4 * 4 * 2, 0), o.vertexAttribDivisorANGLE(s.attributes.fromColor, 1), a.vertexAttribPointer(s.attributes.toColor, 4, a.FLOAT, false, 4 * 4 * 2, 4 * 4), o.vertexAttribDivisorANGLE(s.attributes.toColor, 1), a.bindBuffer(a.ARRAY_BUFFER, this.edgesGeometry.sizeBuffer), a.vertexAttribPointer(s.attributes.fromSize, 1, a.FLOAT, false, 4 * 2, 0), o.vertexAttribDivisorANGLE(s.attributes.fromSize, 1), a.vertexAttribPointer(s.attributes.toSize, 1, a.FLOAT, false, 4 * 2, 4), o.vertexAttribDivisorANGLE(s.attributes.toSize, 1), a.bindBuffer(a.ARRAY_BUFFER, this.edgesGeometry.indexBuffer), a.enableVertexAttribArray(s.attributes.encodedIndex), a.vertexAttribPointer(s.attributes.encodedIndex, 4, a.FLOAT, false, 0, 0), o.vertexAttribDivisorANGLE(s.attributes.encodedIndex, 1), a.uniformMatrix4fv(s.uniforms.projectionMatrix, false, this.projectionMatrix), a.uniformMatrix4fv(s.uniforms.viewMatrix, false, this.viewMatrix), a.uniform1f(s.uniforms.globalOpacityScale, this._edgesGlobalOpacityScale), a.uniform1f(s.uniforms.globalOpacityBase, this._edgesGlobalOpacityBase), a.uniform1f(s.uniforms.globalWidthScale, this._edgesGlobalWidthScale), a.uniform1f(s.uniforms.globalWidthBase, this._edgesGlobalWidthBase), a.uniform1f(s.uniforms.globalSizeScale, this._nodesGlobalSizeScale * i), a.uniform1f(s.uniforms.globalSizeBase, this._nodesGlobalSizeBase * i), o.drawArraysInstancedANGLE(a.TRIANGLE_STRIP, 0, 4, this.edgesGeometry.count), s.attributes.disable("fromVertex"), s.attributes.disable("toVertex"), s.attributes.disable("vertexType"), s.attributes.disable("fromColor"), s.attributes.disable("toColor"), s.attributes.disable("fromSize"), s.attributes.disable("toSize"), s.attributes.disable("encodedIndex"));
  }
  /** Helper function to redraw the scene.
   * @method _redrawAll
   * @memberof Helios
   * @instance
   * @private
   * @param {Object} destination - The destination to draw to. If undefined, the canvas will be used.
   * @param {String} framebufferType - Type of the framebuffer to draw "normal", "picking", "tracking" . Default is "normal"
   */
  _redrawAll(e, n) {
    typeof n > "u" && (n = "normal");
    const r = this.gl;
    this._redrawPrepare(e, n), n == "normal" && this.densityPlot && (r.disable(this.gl.DEPTH_TEST), (e == null ? void 0 : e.size.width) || this.canvasElement.width, (e == null ? void 0 : e.size.height) || this.canvasElement.height, this.densityMap.drawScene(this.projectionMatrix, this.viewMatrix)), r.depthMask(true), this._use2D ? (r.disable(r.DEPTH_TEST), r.depthMask(false), n != "tracking" && this._edgesGlobalOpacityScale > 0 && this._redrawEdges(e, n), this._redrawNodes(e, n)) : (r.enable(r.DEPTH_TEST), this._redrawNodes(e, n), r.depthMask(false), n != "tracking" && this._edgesGlobalOpacityScale > 0 && this._redrawEdges(e, n), r.depthMask(true));
  }
  // onResizeCallback
  // onNodeClickCallback
  // onNodeHoverStartCallback 
  // onNodeHoverEndCallback
  // onNodeHoverMoveCallback
  // onZoomCallback
  // onRotationCallback
  // onLayoutStartCallback
  // onLayoutFinishCallback
  // onDrawCallback
  /** Helper function to update the center nodes position.
   * @method _updateCenterNodesPosition
   * @memberof Helios
   * @instance
   * @private
   */
  _updateCenterNodesPosition() {
    if (this.targetTranslatePosition[0] = 0, this.targetTranslatePosition[1] = 0, this.targetTranslatePosition[2] = 0, this._centerNodes && this._centerNodes.length > 0) {
      for (let n = 0; n < this._centerNodes.length; n++) {
        let i = this._centerNodes[n].position;
        this.targetTranslatePosition[0] -= i[0], this.targetTranslatePosition[1] -= i[1], this.targetTranslatePosition[2] -= i[2];
      }
      let e = this._centerNodes.length;
      this.targetTranslatePosition[0] /= e, this.targetTranslatePosition[1] /= e, this.targetTranslatePosition[2] /= e;
    }
  }
  /** Center view on nodes with animation.
   * @method centerOnNodes
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number[]|Node} nodes - The nodes to center on.
   * @param {number} duration - The duration of the animation in milliseconds.
   * @example
   * // Center on node with id 1
   * helios.centerOnNodes([1], 1000);
   * @example
   * // Center on node with id 1 and 2
   * helios.centerOnNodes([1, 2], 1000);
   * @example
   * // Center on node with id 1 and node object
   * helios.centerOnNodes([1, helios.network.nodes[2]], 1000);
   * return {this} The current instance of Helios for chaining.
   */
  centerOnNodes(e, n) {
    this._centerNodes = [];
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i.ID === void 0 && (i = this.network.nodes[i]), this._centerNodes.push(i);
    }
    return this._updateCameraInteraction(), this.lastTranslatePosition[0] = this.translatePosition[0], this.lastTranslatePosition[1] = this.translatePosition[1], this.lastTranslatePosition[2] = this.translatePosition[2], this.lastPanX = this.panX, this.lastPanY = this.panY, n === void 0 || n <= 0 ? (this.translateDuration = 0, this.translateStartTime = null) : (this.translateDuration = n, this.translateStartTime = performance.now()), this._scheduleCameraInterpolation(), this;
  }
  /** Get the nodes being centered on.
   * @method getCenterNodes
   * @memberof Helios
   * @instance
   * @return {Array<Node>} The nodes being centered on.
   * @example
   * // Get the nodes being centered on
   * let nodes = helios.getCenterNodes();
   */
  centeredNodes() {
    return this._centerNodes;
  }
  /** Helper method to update the camera interpolation.
   * @method _updateCameraInterpolation
   * @memberof Helios
   * @instance
   * @private
   * @param {Boolean} ignoreInstantaneousUpdate - Ignore instantaneous update.
   * @return {Boolean} True if the camera interpolation needs to continue, false otherwise.
   */
  _updateCameraInterpolation(e = false) {
    if (this.translateDuration == 0)
      return e || (this.translatePosition[0] = this.targetTranslatePosition[0], this.translatePosition[1] = this.targetTranslatePosition[1], this.translatePosition[2] = this.targetTranslatePosition[2], this.panX = 0, this.panY = 0, this._use2D), false;
    {
      let r = (performance.now() - this.translateStartTime) / this.translateDuration;
      return r > 1 && (r = 1), this.translatePosition[0] = (1 - r) * this.lastTranslatePosition[0], this.translatePosition[1] = (1 - r) * this.lastTranslatePosition[1], this.translatePosition[2] = (1 - r) * this.lastTranslatePosition[2], this.translatePosition[0] += r * this.targetTranslatePosition[0], this.translatePosition[1] += r * this.targetTranslatePosition[1], this.translatePosition[2] += r * this.targetTranslatePosition[2], this.panX = (1 - r) * this.lastPanX, this.panY = (1 - r) * this.lastPanY, this.panX += r * this.targetPanX, this.panY += r * this.targetPanY, this._use2D, !(r >= 1);
    }
  }
  /** Helper method to schedule the camera interpolation.
   * @method _scheduleCameraInterpolation
   * @memberof Helios
   * @instance
   * @private
   */
  _scheduleCameraInterpolation() {
    let e = {
      name: "1.1.cameraInterpolator",
      callback: (n, r) => {
        this._updateCenterNodesPosition(), this._updateCameraInterpolation() || this.scheduler.unschedule("1.1.cameraInterpolator");
      },
      delay: 0,
      repeat: true,
      synchronized: true,
      immediateUpdates: false,
      redraw: true,
      updateNodesGeometry: false,
      updateEdgesGeometry: false
    };
    this.scheduler.schedule({
      name: "1.0.cameraInterpolator",
      callback: (n, r) => {
        this.scheduler.schedule(e);
      },
      delay: 0,
      repeat: false,
      synchronized: true,
      immediateUpdates: false,
      redraw: false,
      updateNodesGeometry: false,
      updateEdgesGeometry: false
    });
  }
  //#region Events
  /** Set the callback for the resize event.
   * @method onResize
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the resize event
   * helios.onResize((width, height) => {
   * 	console.log("The canvas was resized to " + width + "x" + height);
   * });
   */
  onResize(e) {
    return this.onResizeCallback = e, this;
  }
  /** Set the callback for the node click event.
   * @method onNodeClick
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the node click event
   * helios.onNodeClick((node) => {
   * 	console.log("The node " + node.id + " was clicked");
   * });
   */
  onNodeClick(e) {
    return this.onNodeClickCallback = e, this;
  }
  /** Set the callback for the node double click event.
   * @method onNodeDoubleClick
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the node double click event
   * helios.onNodeDoubleClick((node) => {
   * 	console.log("The node " + node.id + " was double clicked");
   * });
   * @see {@link Helios#onNodeClick}
   */
  onNodeDoubleClick(e) {
    return this.onNodeDoubleClickCallback = e, this;
  }
  /** Set the callback for the node hover start event.
   * @method onNodeHoverStart
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the node hover start event
   * helios.onNodeHoverStart((node) => {
   * 	console.log("The node " + node.id + " was hovered");
   * });
   * @see {@link Helios#onNodeHoverEnd}
   * @see {@link Helios#onNodeHoverMove}
   */
  onNodeHoverStart(e) {
    return this.onNodeHoverStartCallback = e, this;
  }
  /** Set the callback for the node hover end event.
   * @method onNodeHoverEnd
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the node hover end event
   * helios.onNodeHoverEnd((node) => {
   * 	console.log("The node " + node.id + " was no longer hovered");
   * });
   * @see {@link Helios#onNodeHoverStart}
   * @see {@link Helios#onNodeHoverMove}
   */
  onNodeHoverEnd(e) {
    return this.onNodeHoverEndCallback = e, this;
  }
  /** Set the callback for the node hover move event.
   * @method onNodeHoverMove
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @category Events
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the node hover move event
   * helios.onNodeHoverMove((node) => {
   * 	console.log("The node " + node.id + " was hovered");
   * });
   * @see {@link Helios#onNodeHoverStart}
   * @see {@link Helios#onNodeHoverEnd}
   */
  onNodeHoverMove(e) {
    return this.onNodeHoverMoveCallback = e, this;
  }
  /** Set the callback for the edge click event.
   * @method onEdgeClick
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the edge click event
   * helios.onEdgeClick((edge) => {
   * 	console.log("The edge " + edge.id + " was clicked");
   * });
   * @see {@link Helios#onEdgeDoubleClick}
   * @see {@link Helios#onEdgeHoverStart}
   * @see {@link Helios#onEdgeHoverEnd}
   * @see {@link Helios#onEdgeHoverMove}
   */
  onEdgeClick(e) {
    return this.onEdgeClickCallback = e, this;
  }
  /** Set the callback for the edge double click event.
   * @method onEdgeDoubleClick
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the edge double click event
   * helios.onEdgeDoubleClick((edge) => {
   * 	console.log("The edge " + edge.id + " was double clicked");
   * });
   * @see {@link Helios#onEdgeClick}
   * @see {@link Helios#onEdgeHoverStart}
   * @see {@link Helios#onEdgeHoverEnd}
   * @see {@link Helios#onEdgeHoverMove}
   */
  onEdgeDoubleClick(e) {
    return this.onEdgeDoubleClickCallback = e, this;
  }
  /** Set the callback for the edge hover start event.
   * @method onEdgeHoverStart
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the edge hover start event
   * helios.onEdgeHoverStart((edge) => {
   * 	console.log("The edge " + edge.id + " was hovered");
   * });
   * @see {@link Helios#onEdgeClick}
   * @see {@link Helios#onEdgeDoubleClick}
   * @see {@link Helios#onEdgeHoverEnd}
   * @see {@link Helios#onEdgeHoverMove}
   */
  onEdgeHoverStart(e) {
    return this.onEdgeHoverStartCallback = e, this;
  }
  /** Set the callback for the edge hover end event.
   * @method onEdgeHoverEnd
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the edge hover end event
   * helios.onEdgeHoverEnd((edge) => {
   * 	console.log("The edge " + edge.id + " was no longer hovered");
   * });
   * @see {@link Helios#onEdgeClick}
   * @see {@link Helios#onEdgeDoubleClick}
   * @see {@link Helios#onEdgeHoverStart}
   * @see {@link Helios#onEdgeHoverMove}
   */
  onEdgeHoverEnd(e) {
    return this.onEdgeHoverEndCallback = e, this;
  }
  /** Set the callback for the edge hover move event.
   * @method onEdgeHoverMove
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the edge hover move event
   * helios.onEdgeHoverMove((edge) => {
   * 	console.log("The edge " + edge.id + " was hovered");
   * });
   * @see {@link Helios#onEdgeClick}
   * @see {@link Helios#onEdgeDoubleClick}
   * @see {@link Helios#onEdgeHoverStart}
   * @see {@link Helios#onEdgeHoverEnd}
   */
  onEdgeHoverMove(e) {
    return this.onEdgeHoverMoveCallback = e, this;
  }
  /** Set the callback for the zoom event.
   * @method onZoom
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the zoom event
   * helios.onZoom((zoom) => {
   * 	console.log("The zoom is now " + zoom);
   * });
   * @see {@link Helios#onRotation}
   */
  onZoom(e) {
    return this.onZoomCallback = e, this;
  }
  /** Set the callback for the rotation event.
   * @method onRotation
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the rotation event
   * helios.onRotation((rotation) => {
   * 	console.log("The rotation is now " + rotation);
   * });
   * @see {@link Helios#onZoom}
   */
  onRotation(e) {
    return this.onRotationCallback = e, this;
  }
  /** Set the callback for the layout start event.
   * @method onLayoutStart
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the layout start event
   * helios.onLayoutStart(() => {
   * 	console.log("The layout has started");
   * });
   * @see {@link Helios#onLayoutStop}
   * @see {@link Helios#onLayoutTick}
   * @see {@link Helios#onLayoutEnd}
   */
  onLayoutStart(e) {
    return this.onLayoutStartCallback = e, this == null ? void 0 : this.layoutWorker.onStart(() => {
      var _a2;
      (_a2 = this.onLayoutStartCallback) == null ? void 0 : _a2.call(this);
    }), this;
  }
  /** Set the callback for the layout stop event.
   * @method onLayoutStop
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the layout stop event
   * helios.onLayoutStop(() => {
   * 	console.log("The layout has stopped");
   * });
   * @see {@link Helios#onLayoutStart}
   * @see {@link Helios#onLayoutTick}
   */
  onLayoutStop(e) {
    return this.onLayoutStopCallback = e, this == null ? void 0 : this.layoutWorker.onStop(() => {
      var _a2;
      (_a2 = this.onLayoutStopCallback) == null ? void 0 : _a2.call(this);
    }), this;
  }
  /** Set the callback for the draw event.
   * @method onDraw
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for the draw event
   * helios.onDraw(() => {
   * 	console.log("The graph was drawn");
   * });
   * @see {@link Helios#onReady}
   */
  onDraw(e) {
    return this.onDrawCallback = e, this;
  }
  /** Set the callback for when Helios is ready and properly initialized.
   * @method onReady
   * @memberof Helios
   * @instance
   * @param {Function} callback - The callback function.
   * @chainable
   * @return {this} The current Helios instance for chaining.
   * @example
   * // Set the callback for when Helios is ready
   * let helios = Helios("elementID",networkData);
   * helios.onReady(() => {
   * 	console.log("Helios is ready");
   * });
   */
  onReady(e) {
    this.isReady ? e == null ? void 0 : e(this) : this.onReadyCallback = e;
  }
  //#endregion
  //#region Style attributes
  /** Set the background color of the graph.
   * @method backgroundColor
   * @memberof Helios
   * @instance
   * @param {Array<number>} color - The background color of the graph in RGB or RGBA formats as 3 or 4 float entries from 0.0 to 1.0.
   * @chainable
   * @return {Array<number>|this} The background color of the panel or the current Helios instance for chaining.
   * @example
   * // Set the background color of the graph to red
   * helios.backgroundColor([1.0,0,0,1.0]);
   * @example
   * // Get the background color of the graph
   * let backgroundColor = helios.backgroundColor();
   */
  backgroundColor(e) {
    return typeof e > "u" ? this._backgroundColor : (this._backgroundColor = e, this);
  }
  /** Set the color of the nodes.
   * @method nodeColor
   * @memberof Helios
   * @instance
   * @param {Array<number>|Function} colorInput - The color of the nodes in RGB or RGBA formats as 3 or 4 float entries from 0.0 to 1.0 or a function that returns the color of the nodes.
   * @param {string} [nodeID] - The ID of the node to set the color of. If not specified, the color of all nodes will be set.
   * @chainable
   * @return {Array<number>|this} The color of the nodes or the current Helios instance for chaining.
   * @example
   * // Set the color of all nodes to red
   * helios.nodeColor([1.0,0,0,1.0]);
   * @example
   * // Set the color of a specific node to red
   * helios.nodeColor([1.0,0,0,1.0], "nodeID");
   * @example
   * // Set the color of all nodes to a random color
   * helios.nodeColor((node) => {
   * 	return [Math.random(), Math.random(), Math.random(), 1.0];
   * });
   * @example
   * // Set the color of all nodes based on an node attribute called `altColor`
   * helios.nodeColor((node) => {
   * 	return node.altColor;
   * });
   */
  nodeColor(e, n) {
    if (typeof n > "u") {
      if (typeof e > "u")
        return this.network.colors;
      if (typeof e == "function") {
        let r = this.network.index2Node;
        for (let i = 0; i < r.length; i++) {
          let a = r[i], o = e(a, i, this.network);
          this.network.colors[i * 4 + 0] = o[0], this.network.colors[i * 4 + 1] = o[1], this.network.colors[i * 4 + 2] = o[2], o.length > 3 && (this.network.colors[i * 4 + 3] = o[3]);
        }
      } else {
        if (typeof e == "number")
          return this.network.colors[this.network.ID2index[e]];
        {
          let r = this.network.index2Node;
          for (let i = 0; i < r.length; i++)
            this.network.colors[i * 4 + 0] = e[0], this.network.colors[i * 4 + 1] = e[1], this.network.colors[i * 4 + 2] = e[2], e.length > 3 && (this.network.colors[i * 4 + 3] = e[3]);
        }
      }
    } else if (typeof e == "function") {
      let r = this.network.ID2index[n], i = e(n, r, this.network);
      this.network.colors[r * 4 + 0] = i[0], this.network.colors[r * 4 + 1] = i[1], this.network.colors[r * 4 + 2] = i[2], i.length > 3 && (this.network.colors[r * 4 + 3] = i[3]);
    } else {
      let r = this.network.ID2index[n];
      this.network.colors[r * 4 + 0] = e[0], this.network.colors[r * 4 + 1] = e[1], this.network.colors[r * 4 + 2] = e[2], e.length > 3 && (this.network.colors[r * 4 + 3] = e[3]);
    }
    return this;
  }
  /** Set the size of the nodes.
   * @method nodeSize
   * @memberof Helios
   * @instance
   * @param {number|Function} sizeInput - The size of the nodes or a function that returns the size of the nodes.
   * @param {string} [nodeID] - The ID of the node to set the size of. If not specified, the size of all nodes will be set.
   * @chainable
   * @return {number|this} The size of the nodes or the current Helios instance for chaining.
   * @example
   * // Set the size of all nodes to 10
   * helios.nodeSize(10);
   * @example
   * // Set the size of a specific node to 10
   * helios.nodeSize(10, "nodeID");
   * @example
   * // Set the size of all nodes to a random size
   * helios.nodeSize(() => {
   * 	return Math.random() * 10;
   * });
   * @example
   * // Set the size of all nodes based on an node attribute called `altSize`
   * helios.nodeSize((node) => {
   * 	return node.altSize;
   * });
   */
  nodeSize(e, n) {
    if (typeof n > "u") {
      if (typeof e > "u")
        return this.network.sizes;
      if (typeof e == "function") {
        let r = this.network.index2Node;
        for (let i = 0; i < r.length; i++) {
          let a = r[i], o = e(a, this.network);
          this.network.sizes[i] = o;
        }
      } else {
        let r = this.network.index2Node;
        for (let i = 0; i < r.length; i++)
          this.network.sizes[i] = e;
      }
    } else if (typeof e == "function") {
      let r = e(n, this.network), i = this.network.ID2index[n];
      this.network.sizes[i] = r;
    } else {
      let r = this.network.ID2index[n];
      this.network.sizes[r] = e;
    }
    return this;
  }
  /** Set the color of the node outlines.
   * @method nodeOutlineColor
   * @memberof Helios
   * @instance
   * @param {number[]|Function} colorInput - The color of the node outlines or a function that returns the color of the node outlines. Uses RGBA or RGBA formatted array.
   * @param {string} [nodeID] - The ID of the node to set the color of. If not specified, the color of all nodes will be set.
   * @chainable
   * @return {number[]|this} The color of the node outlines or the current Helios instance for chaining.
   * @example
   * // Set the color of all node outlines to red
   * helios.nodeOutlineColor([1, 0, 0, 1]);
   * @example
   * // Set the color of a specific node outline to red
   * helios.nodeOutlineColor([1, 0, 0, 1], "nodeID");
   * @example
   * // Set the color of all node outlines to a random color
   * helios.nodeOutlineColor(() => {
   * 	return [Math.random(), Math.random(), Math.random(), 1];
   * });
   * @example
   * // Set the color of all node outlines based on an node attribute called `altColor`
   * helios.nodeOutlineColor((node) => {
   * 	return node.altColor;
   * });
   */
  nodeOutlineColor(e, n) {
    if (typeof n > "u") {
      if (typeof e > "u")
        return this.network.outlineColors;
      if (typeof e == "function") {
        let r = this.network.index2Node;
        for (let i = 0; i < r.length; i++) {
          let a = r[i], o = e(a, i, this.network);
          this.network.outlineColors[i * 4 + 0] = o[0], this.network.outlineColors[i * 4 + 1] = o[1], this.network.outlineColors[i * 4 + 2] = o[2], o.length > 3 && (this.network.outlineColors[i * 4 + 3] = o[3]);
        }
      } else {
        if (typeof e == "number")
          return this.network.outlineColors[this.network.ID2index[e]];
        {
          let r = this.network.index2Node;
          for (let i = 0; i < r.length; i++)
            this.network.outlineColors[i * 4 + 0] = e[0], this.network.outlineColors[i * 4 + 1] = e[1], this.network.outlineColors[i * 4 + 2] = e[2], e.length > 3 && (this.network.outlineColors[i * 4 + 3] = e[3]);
        }
      }
    } else if (typeof e == "function") {
      let r = this.network.ID2index[n], i = e(n, r, this.network);
      this.network.outlineColors[r * 4 + 0] = i[0], this.network.outlineColors[r * 4 + 1] = i[1], this.network.outlineColors[r * 4 + 2] = i[2], i.length > 3 && (this.network.outlineColors[r * 4 + 3] = i[3]);
    } else {
      let r = this.network.ID2index[n];
      this.network.outlineColors[r * 4 + 0] = e[0], this.network.outlineColors[r * 4 + 1] = e[1], this.network.outlineColors[r * 4 + 2] = e[2], e.length > 3 && (this.network.outlineColors[r * 4 + 3] = e[3]);
    }
    return this;
  }
  /** Set the width of the node outlines.
   * @method nodeOutlineWidth
   * @memberof Helios
   * @instance
   * @param {number|Function} widthInput - The width of the node outlines or a function that returns the width of the node outlines.
   * @param {string} [nodeID] - The ID of the node to set the width of. If not specified, the width of all nodes will be set.
   * @chainable
   * @return {number|this} The width of the node outlines or the current Helios instance for chaining.
   * @example
   * // Set the width of all node outlines to 5
   * helios.nodeOutlineWidth(5);
   * @example
   * // Set the width of a specific node outline to 5
   * helios.nodeOutlineWidth(5, "nodeID");
   * @example
   * // Set the width of all node outlines to a random width
   * helios.nodeOutlineWidth(() => {
   * 	return Math.random() * 10;
   * });
   * @example
   * // Set the width of all node outlines based on an node attribute called `altWidth`
   * helios.nodeOutlineWidth((node) => {
   * 	return node.altWidth;
   * });
   * @example
   * // Set the width of all node outlines based on an node attribute called `altWidth`
   * helios.nodeOutlineWidth((node) => {
   * 	return node.altWidth;
   * });
   */
  nodeOutlineWidth(e, n) {
    if (typeof n > "u") {
      if (typeof e > "u")
        return this.network.outlineWidths;
      if (typeof e == "function") {
        let r = this.network.index2Node;
        for (let i = 0; i < r.length; i++) {
          let a = r[i], o = e(a, this.network);
          this.network.outlineWidths[a.index] = o;
        }
      } else {
        let r = this.network.index2Node;
        for (let i = 0; i < r.length; i++)
          this.network.outlineWidths[i] = e;
      }
    } else if (typeof e == "function") {
      let r = e(n, this.network), i = this.network.ID2index[n];
      this.network.outlineWidths[i] = r;
    } else {
      let r = this.network.ID2index[n];
      this.network.outlineWidths[r] = e;
    }
    return this;
  }
  /** Set the color of the edges.
   * @method edgeColor
   * @memberof Helios
   * @instance
   * @param {number|Function} colorInput - The color of the edges or a function that returns the color of the edges.
   * @param {string} [edgeID] - The ID of the edge to set the color of. If not specified, the color of all edges will be set.
   * @chainable
   * @return {number|this} The color of the edges or the current Helios instance for chaining.
   * @example
   * // Set the color of all edges to red
   * helios.edgeColor([1, 0, 0, 1]);
   * @example
   * // Set the color of a specific edge to red
   * helios.edgeColor([1, 0, 0, 1], "edgeID");
   * @example
   * // Set the color of all edges to a random color
   * helios.edgeColor(() => {
   * 	return [Math.random(), Math.random(), Math.random(), 1];
   * });
   * @example
   * // Set the color of all edges based on an edge attribute called `altColor`
   * helios.edgeColor((edge) => {
   * 	return edge.altColor;
   * });
   */
  edgeColor(e, n) {
    if (typeof n > "u") {
      if (typeof e > "u")
        return this.network.edgeColors;
      if (typeof e == "function") {
        let r = this.network.index2Node, i = this.network.indexedEdges;
        for (let a = 0; a < i.length / 2; a++) {
          let o = r[i[a * 2]], s = r[i[a * 2 + 1]], l = e(a, o, s, this.network);
          l.length == 2 ? (this.network.edgeColors[a * 2 * 4 + 0] = l[0][0], this.network.edgeColors[a * 2 * 4 + 1] = l[0][1], this.network.edgeColors[a * 2 * 4 + 2] = l[0][2], this.network.edgeColors[(a * 2 + 1) * 4 + 0] = l[1][0], this.network.edgeColors[(a * 2 + 1) * 4 + 1] = l[1][1], this.network.edgeColors[(a * 2 + 1) * 4 + 2] = l[1][2], l[0].length > 3 && (this.network.edgeColors[(a * 2 + 1) * 4 + 3] = l[0][3]), l[1].length > 3 && (this.network.edgeColors[(a * 2 + 1) * 4 + 3] = l[1][3])) : (this.network.edgeColors[a * 2 * 4 + 0] = l[0], this.network.edgeColors[a * 2 * 4 + 1] = l[1], this.network.edgeColors[a * 2 * 4 + 2] = l[2], this.network.edgeColors[(a * 2 + 1) * 4 + 0] = l[0], this.network.edgeColors[(a * 2 + 1) * 4 + 1] = l[1], this.network.edgeColors[(a * 2 + 1) * 4 + 2] = l[2], l.length > 3 && (this.network.edgeColors[(a * 2 + 1) * 4 + 3] = l[3], this.network.edgeColors[(a * 2 + 1) * 4 + 3] = l[3]));
        }
      } else {
        if (typeof e == "number")
          return [this.network.edgeColors[e * 2 + 0], this.network.edgeColors[e * 2 + 1]];
        {
          let r = this.network.index2Node, i = this.network.indexedEdges;
          for (let a = 0; a < i.length / 2; a++)
            r[i[a * 2]], r[i[a * 2 + 1]], e.length == 2 ? (this.network.edgeColors[a * 2 * 4 + 0] = e[0][0], this.network.edgeColors[a * 2 * 4 + 1] = e[0][1], this.network.edgeColors[a * 2 * 4 + 2] = e[0][2], this.network.edgeColors[(a * 2 + 1) * 4 + 0] = e[1][0], this.network.edgeColors[(a * 2 + 1) * 4 + 1] = e[1][1], this.network.edgeColors[(a * 2 + 1) * 4 + 2] = e[1][2], e[0].length > 3 && (this.network.edgeColors[(a * 2 + 1) * 4 + 3] = e[0][3]), e[1].length > 3 && (this.network.edgeColors[(a * 2 + 1) * 4 + 3] = e[1][3])) : (this.network.edgeColors[a * 2 * 4 + 0] = e[0], this.network.edgeColors[a * 2 * 4 + 1] = e[1], this.network.edgeColors[a * 2 * 4 + 2] = e[2], this.network.edgeColors[(a * 2 + 1) * 4 + 0] = e[0], this.network.edgeColors[(a * 2 + 1) * 4 + 1] = e[1], this.network.edgeColors[(a * 2 + 1) * 4 + 2] = e[2], e.length > 3 && (this.network.edgeColors[(a * 2 + 1) * 4 + 3] = e[3], this.network.edgeColors[(a * 2 + 1) * 4 + 3] = e[3]));
        }
      }
    } else {
      typeof e == "function" && e(nodeID, r, this.network);
      let r = this.network.ID2index[nodeID];
      e.length == 2 ? (this.network.edgeColors[edgeIndex * 2 * 4 + 0] = e[0][0], this.network.edgeColors[edgeIndex * 2 * 4 + 1] = e[0][1], this.network.edgeColors[edgeIndex * 2 * 4 + 2] = e[0][2], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 0] = e[1][0], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 1] = e[1][1], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 2] = e[1][2], e[0].length > 3 && (this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 3] = e[0][3]), e[1].length > 3 && (this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 3] = e[1][3])) : (this.network.edgeColors[edgeIndex * 2 * 4 + 0] = e[0], this.network.edgeColors[edgeIndex * 2 * 4 + 1] = e[1], this.network.edgeColors[edgeIndex * 2 * 4 + 2] = e[2], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 0] = e[0], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 1] = e[1], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 2] = e[2], e.length > 3 && (this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 3] = e[3], this.network.edgeColors[(edgeIndex * 2 + 1) * 4 + 3] = e[3]));
    }
    return this;
  }
  /** Set the width of the edges. 
   * @method edgeWidth
   * @memberof Helios
   * @instance
   * @param {number|function} widthInput - The width of the edges. If a function is provided, it will be called for each edge. The function should return a number or an array of two numbers, the width at the source and target.
   * @param {number} [edgeIndex] - The index of the edge. If not provided, the width will be set for all edges.
   * @return {number|this} - The width of the edge if no arguments are provided, otherwise the Helios instance for chaining.
   * @example
   * // Set the width of all edges to 5.
   * helios.edgeWidth(5);
   * @example
   * // Set the width of the edge with index 0 to 5.
   * helios.edgeWidth(5, 0);
   * @example
   * // Set the width of all edges to a random number between 1 and 10.
   * helios.edgeWidth(sourceNode, targetNode, edgeIndex) => {
   *    return Math.random() * 9 + 1;
   * });
   * @example
   * // Set the width of all edges to 5 at source and 2 at target.
   * helios.edgeWidth(sourceNode, targetNode, edgeIndex) => {
   *   return [5, 2];
   * });
   * @example
   * // Set the width of the edge with altSizes properties from source and target.
   * helios.edgeWidth(sourceNode, targetNode, edgeIndex) => {
   *  return [sourceNode.altSizes, targetNode.altSizes];
   * });
   */
  edgeWidth(e, n) {
    if (typeof n > "u") {
      if (typeof e > "u")
        return this.network.edgeColors;
      if (typeof e == "function") {
        let r = this.network.index2Node, i = this.network.indexedEdges;
        for (let a = 0; a < i.length / 2; a++) {
          let o = r[i[a * 2]], s = r[i[a * 2 + 1]], l = e(o, s, a, this.network);
          typeof l == "number" ? (this.network.edgeSizes[a * 2] = l, this.network.edgeSizes[a * 2 + 1] = l) : (this.network.edgeSizes[a * 2] = l[0], this.network.edgeSizes[a * 2 + 1] = l[1]);
        }
      } else {
        let r = this.network.indexedEdges;
        for (let i = 0; i < r.length / 2; i++)
          typeof e == "number" ? (this.network.edgeSizes[i * 2] = e, this.network.edgeSizes[i * 2 + 1] = e) : (this.network.edgeSizes[i * 2] = e[0], this.network.edgeSizes[i * 2 + 1] = e[1]);
      }
    } else if (typeof e == "function") {
      let r = this.network.index2Node, i = this.network.indexedEdges, a = r[i[n * 2]], o = r[i[n * 2 + 1]], s = e(a, o, n, this.network);
      typeof s == "number" ? (this.network.edgeSizes[n * 2] = s, this.network.edgeSizes[n * 2 + 1] = s) : (this.network.edgeSizes[n * 2] = s[0], this.network.edgeSizes[n * 2 + 1] = s[1]);
    } else
      typeof e == "number" ? (this.network.edgeSizes[n * 2] = e, this.network.edgeSizes[n * 2 + 1] = e) : (this.network.edgeSizes[n * 2] = e[0], this.network.edgeSizes[n * 2 + 1] = e[1]);
    return this;
  }
  /** Project the positions of the nodes provided to the screen (using the projection matrix).
   * @method getProjectedPositions
   * @memberof Helios
   * @instance
   * @param {Node[]|number} nodes - The nodes or indices of nodes to project.
   * @return {Float32Array} - The projected positions of the nodes.
   * @example
   * // Get the projected positions of all nodes.
   * let projectedPositions = helios.getProjectedPositions(helios.network.nodes);
   */
  getProjectedPositions(e) {
    if (e === void 0 && (e = this.network.nodes), e.length > 0) {
      this.gl;
      let n = new Uint32Array(e.length);
      if (typeof e[0] == "number")
        for (let s = 0; s < e.length; s++)
          n[s] = e[s];
      else {
        n = new Uint32Array(e.length);
        for (let s = 0; s < e.length; s++)
          n[s] = e[s].index;
      }
      let r = this.network.positions, i = new Float32Array(e.length * 4), [a, o] = this._lastCanvasDimensions;
      for (let s = 0; s < e.length; s++) {
        let l = n[s], h = [r[l * 3], r[l * 3 + 1], r[l * 3 + 2], 1], u = mr();
        oo(u, h, this.projectionViewMatrix);
        let f = 1 / u[3], c = a / 2 + u[0] * a * 0.5 * f, d = o / 2 - u[1] * o * 0.5 * f;
        i[s * 4] = c, i[s * 4 + 1] = d, i[s * 4 + 2] = u[2], i[s * 4 + 3] = u[3];
      }
      return i;
    } else
      return Float32Array(0);
  }
  /** Pick a node at the given screen coordinates.
   * @method pickNode
   * @memberof Helios
   * @instance
   * @param {number} x - The x coordinate of the point to pick.
   * @param {number} y - The y coordinate of the point to pick.
   * @return {Node} - The node at the given point, or null if no node was picked.
   * @example
   * // Pick a node at the center of the canvas.
   * let node = helios.pickNode(helios.canvasElement.width / 2, helios.canvasElement.height / 2);
   * if(node !== null) {
   *    console.log("Picked node " + node.index);
   * }
   * @example
   * // Pick a node at the center of the canvas, and highlight it.
   * let node = helios.pickNode(helios.canvasElement.width / 2, helios.canvasElement.height / 2);
   * if(node !== null) {
   *   console.log("Picked node " + node.index);
   *  helios.highlightNode(node);
   * }
   */
  pickPoint(e, n) {
    const r = this.canvasElement.width * this.pickingResolutionRatio, i = this.canvasElement.height * this.pickingResolutionRatio, a = Math.round(e * r / this.canvasElement.clientWidth - 0.5), o = Math.round(i - n * i / this.canvasElement.clientHeight - 0.5), s = new Uint8Array(4), l = this.gl;
    return l.bindFramebuffer(l.FRAMEBUFFER, this.pickingFramebuffer), l.readPixels(
      a,
      // x
      o,
      // y
      1,
      // width
      1,
      // height
      l.RGBA,
      // format
      l.UNSIGNED_BYTE,
      // type
      s
    ), s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24) - 1;
  }
  _consolidateCentroids(e, n) {
    for (const [r, i] of e) {
      const a = n.get(r);
      i[0] /= a, i[1] /= a;
    }
  }
  _calculateCentroidForAttribute(e, n, r, i) {
    r.has(e) || (r.set(e, [0, 0]), i.set(e, 0));
    const a = r.get(e);
    a[0] += n[0], a[1] += n[1];
    const o = i.get(e);
    i.set(e, o + 1);
  }
  _updateTrackerNodesData() {
    const e = this.gl, n = this._trackingBufferPixels, r = this._nodesOnScreen;
    e.bindFramebuffer(e.FRAMEBUFFER, this._trackingFramebuffer), e.readPixels(
      0,
      // x
      0,
      // y
      this._trackingFramebuffer.size.width,
      // width
      this._trackingFramebuffer.size.height,
      // height
      e.RGBA,
      // format
      e.UNSIGNED_BYTE,
      // type
      n
    );
    for (let i = 0; i < n.length; i += 4) {
      const a = n[i] + (n[i + 1] << 8) + (n[i + 2] << 16) + (n[i + 3] << 24) - 1;
      r[i / 4] = a;
    }
  }
  /** Pick a node at the given screen coordinates.
   * @method updateAttributeTrackers
   * @memberof Helios
   * @instance
   * @chainable
   * @return {Helios|this} - The Helios instance (for chaining).
   */
  updateAttributeTrackers(e = false) {
    if (!this._trackingBufferEnabled || Object.keys(this._attributeTrackers).length === 0)
      return this;
    const n = this._attributeTrackers, r = this._trackingFramebuffer.size.width * this._trackingFramebuffer.size.height, i = this._nodesOnScreen, a = this._pixelXYOnScreen;
    e || this._updateTrackerNodesData();
    for (let o in n) {
      const s = n[o], l = s.pixelCounter, h = l.getSortedKeys();
      s.smoothness;
      const u = s.minProportion, f = s.calculateCentroid, c = s.centroidPositions, d = s.attribute, v = s.maxLabels, g = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map(), x = performance.now();
      let w = x - this._trackingLastTime || x;
      w > 1e3 && (w = 1e3);
      const b = Math.exp(-w / 300);
      this._trackingLastTime = x;
      for (let m = 0; m < h.length; m++) {
        h[m];
        const _ = l.get(h[m]) * b;
        if (_ > u) {
          if (l.set(h[m], _), f && c.has(h[m])) {
            const A = c.get(h[m]);
            A && (A[0] *= b, A[1] *= b);
          }
        } else
          l.delete(h[m]), f && c.delete(h[m]);
      }
      if (d == "index")
        for (let m = 0; m < i.length; m++) {
          const _ = i[m];
          if (_ >= 0) {
            const A = (l.get(_) || 0) + 1 / r * (1 - b);
            l.set(_, A), f && this._calculateCentroidForAttribute(_, a[m], g, p);
          }
        }
      else if (d == "node")
        for (let m = 0; m < i.length; m++) {
          const _ = this.network.index2Node;
          if (nodeIndex >= 0) {
            const A = _[nodeIndex], C = (l.get(A) || 0) + 1 / r * (1 - b);
            l.set(A, C), f && this._calculateCentroidForAttribute(A, a[m], g, p);
          }
        }
      else if (typeof d == "function") {
        const m = this.network.index2Node;
        for (let _ = 0; _ < i.length; _++) {
          const A = i[_];
          if (A >= 0) {
            const C = m[A], k = d(C, A), M = (l.get(k) || 0) + 1 / r * (1 - b);
            l.set(k, M), f && this._calculateCentroidForAttribute(k, a[_], g, p);
          }
        }
      } else {
        const m = this.network.index2Node;
        for (let _ = 0; _ < i.length; _++) {
          const A = i[_];
          if (A >= 0) {
            const k = m[A][d], M = (l.get(k) || 0) + 1 / r * (1 - b);
            l.set(k, M), f && this._calculateCentroidForAttribute(k, a[_], g, p);
          }
        }
      }
      if (f) {
        this._consolidateCentroids(g, p);
        for (let [m, _] of g) {
          const A = c.get(m), C = _;
          A ? (A[0] += C[0] * (1 - b), A[1] += C[1] * (1 - b)) : c.set(m, C);
        }
      }
      if (v >= 0) {
        let m = l.getSortedKeys(), _ = m.slice(v, m.length);
        for (let A = 0; A < _.length; A++)
          l.delete(_[A]), c.delete(_[A]);
      }
    }
    return this;
  }
  /** Returns the attributes on screen
   * @method trackedAttributesOnScreen
   * @memberof Helios
   * @instance
   * @private
   * @param {string} trackerName - Name of the tracker to get the attributes from.
   * @return {Array} - Array of attributes on screen. Each entry is an array of two or four elements. 
   * if the tracker saves the centroid, 4 elements are returned: [attribute,proportion, x, y], otherwise [attribute,proportion]
   */
  trackedAttributesOnScreen(e) {
    if (this._trackingBufferEnabled && this._attributeTrackers[e]) {
      const n = this._attributeTrackers[e], r = n.pixelCounter;
      if (n.calculateCentroid) {
        const i = n.centroidPositions, a = r.getSortedPairs();
        for (let o = 0; o < a.length; o++) {
          const s = a[o][0], l = a[o][1], h = i.get(s);
          a[o] = [s, l, h[0], h[1]];
        }
        return a;
      } else
        return r.getSortedPairs();
    }
  }
  /** Returns tracked attributes centroids
   * @method trackedAttributesCentroids
   * @memberof Helios
   * @instance
   * @private
   * @param {string} trackerName - Name of the tracker to get the attributes from.
   * 
   * @return {Array} - Centroid of trackerName.
   * 
   */
  trackedAttributesCentroids(e) {
    if (this._trackingBufferEnabled && this._attributeTrackers[e])
      return this._attributeTrackers[e].centroidPositions;
  }
  /** Update the attribute trackers Schedule.
   * @method _updateTrackerScheduleTask
   * @memberof Helios
   * @instance
   * @private
   */
  _updateTrackerScheduleTask() {
    const e = "9.5.tracker_update";
    !this._trackingBufferEnabled || Object.keys(this._attributeTrackers).length === 0 ? this.scheduler.hasTask(e) && this.scheduler.unschedule(e) : this.scheduler.hasTask(e) || this.scheduler.schedule({
      name: e,
      callback: (n, r) => {
        this.updateAttributeTrackers(true);
        for (let i in this._attributeTrackers) {
          const a = this._attributeTrackers[i];
          a.onTrack && a.onTrack(this.trackedAttributesOnScreen(i), a);
        }
      },
      delay: 0,
      repeatInterval: this._trackingNodeMinimumUpdateInterval,
      repeat: true,
      synchronized: true,
      afterRedraw: true,
      immediateUpdates: false,
      redraw: false,
      updateNodesGeometry: false,
      updateEdgesGeometry: false
    });
  }
  /** Set the attribute to track.
   * @method trackAttribute
   * @memberof Helios
   * @instance
   * @chainable
   * @param {string} trackerName - A tracker name so that it can be untracked later.
   * @param {string|function} attribute - The attribute to track. If a string, it is the name of the attribute of the node to track (use "index" for index and "node" for the node itself). If a function, it is a function that takes a node and its index as arguments and returns the attribute to track.
   * 	 * @param {Object} options - The configuration object
   * @param {string} [options.minProportion=0.001] - The minimum proportion of the screen that a node must occupy to be tracked.
   * @param {string} [options.smoothness=0.8] - The smoothness of the tracking. The higher the value, the more the tracking is smoothed.
   * @param {string} [options.maxLabels=20] - The maximum number of labels to display. If -1, all labels are displayed.
   * @param {string} [options.calculateCentroid=false] - If true, the centroid of the tracked nodes is calculated and expored as the 3rd and 4th (x and y) elements of the tracker results.
   * @param {function} [options.onTrack=null] - A callback function that is called when a node is tracked. It takes the attribute entries and relative proportions as argument and the tracker (attributeProportions,tracker)=>{} 
   * @return {Helios|this} - The Helios instance for chaining.
   * @example
   * // Track the index of the nodes, with a minimum proportion of 0.001, a smoothness of 0.8 and a maximum of 10 labels.
   * helios.trackAttribute("indexTracker","index",{minProportion:0.001,smoothness:0.8,maxLabels:20});
   * @example
   * // Track the community attribute of the nodes, with a minimum proportion of 0.001, a smoothness of 0.8 and a maximum of 20 labels.
   * helios.trackAttribute("communityTracker","community",{minProportion:0.001,smoothness:0.8,maxLabels:20});
   */
  trackAttribute(e, n, { minProportion: r = 1e-3, smoothness: i = 0.8, maxLabels: a = 20, calculateCentroid: o = false, onTrack: s = null } = {}) {
    return e in this._attributeTrackers && this.untrackAttribute(e), this._attributeTrackers[e] = {
      attribute: n,
      pixelCounter: new Cl(false),
      minProportion: r,
      smoothness: i,
      maxLabels: a,
      calculateCentroid: o,
      centroidPositions: /* @__PURE__ */ new Map(),
      onTrack: s
    }, this._updateTrackerScheduleTask(), this;
  }
  /** Untrack the attribute.
   * @method untrackAttribute
   * @memberof Helios
   * @instance
   * @chainable
   * @param {string|function} attribute - The attribute to untrack. If a string, it is the name of the attribute of the node to untrack (use "index" for index and "node" for the node itself). If a function, it is a function that takes a node and its index as arguments and returns the attribute to untrack.
   * @return {Helios|this} - The Helios instance for chaining.
   * @example
   * // Untrack the index of the nodes.
   * helios.untrackAttribute("indexTracker");
   */
  untrackAttribute(e) {
    return this._attributeTrackers = this._attributeTrackers.filter((n) => n.attribute !== e), this._updateTrackerScheduleTask(), this;
  }
  /** attributesTrackers getter.
   * @method attributesTrackers
   * @memberof Helios
   * @instance
   * @return {Object} - The tracked attributes.
   * @example
   * // Get the tracked attributes.
   * let attributesTrackers = helios.attributesTrackers();
   */
  attributesTrackers() {
    return Object.assign({}, this._attributeTrackers);
  }
  /** Set/get tracker node update interval.
   * @method trackingNodeUpdateInterval
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} interval - The interval in milliseconds.
   * @return {Helios|this} - The Helios instance for chaining, or the current interval if no argument is provided.
   * @example
   * // Set the tracker node update interval to 200ms.
   * helios._trackingBufferUpdateInterval(200);
   * @example
   * // Get the tracker node update interval.
   * let interval = helios._trackingBufferUpdateInterval();
   * console.log(interval);
   */
  trackingBufferUpdateInterval(e) {
    return typeof e > "u" ? this._trackingBufferUpdateInterval : (this._trackingBufferUpdateInterval = e, this._updateTrackerScheduleTask(), this);
  }
  /** Set/get tracker update interval
   * @method trackingUpdateInterval
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} interval - The interval in milliseconds.
   * @return {Helios|this} - The Helios instance for chaining, or the current interval if no argument is provided.
   * @example
   * // Set the tracker update interval to 33ms.
   * helios._trackingUpdateInterval(33);
   * @example
   * // Get the tracker update interval.
   * let interval = helios._trackingUpdateInterval();
   * console.log(interval);
   */
  trackingUpdateInterval(e) {
    return typeof e > "u" ? this._trackingUpdateInterval : (this._trackingUpdateInterval = e, this._updateTrackerScheduleTask(), this);
  }
  /** Set/get edge global opacity scale. The opacity of each edge is calculated as: opacity = globalBase + globalScale * edgeOpacity
   * @method edgesGlobalOpacityScale
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} opacity - The global opacity scale of the edges.
   * @return {Helios|this} - The Helios instance for chaining, or the current global opacity if no argument is provided.
   * @example
   * // Set the global opacity of the edges to 0.5.
   * helios.edgesGlobalOpacityScale(0.5);
   */
  edgesGlobalOpacityScale(e) {
    return typeof e > "u" ? this._edgesGlobalOpacityScale : (this._edgesGlobalOpacityScale = e, this);
  }
  /** Set/get edge global opacity base. The opacity of each edge is calculated as: opacity = globalBase + globalScale * edgeOpacity
   * @method edgesGlobalOpacityBase
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} opacity - The global opacity base of the edges.
   * @return {Helios|this} - The Helios instance for chaining, or the current global opacity if no argument is provided.
   * @example
   * // Set the global opacity base of the edges to 0.5.
   * helios.edgesGlobalOpacityBase(0.5);
   */
  edgesGlobalOpacityBase(e) {
    return typeof e > "u" ? this._edgesGlobalOpacityBase : (this._edgesGlobalOpacityBase = e, this);
  }
  /** Set/get edge global width scale. The width of each edge is calculated as: width = globalBase + globalScale * edgeWidth
   * @method edgesGlobalWidthScale
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} width - The global width scale of the edges.
   * @return {Helios|this} - The Helios instance for chaining, or the current global width if no argument is provided.
   * @example
   * // Set the global width of the edges to 0.5.
   * helios.edgesGlobalWidthScale(0.5);
   */
  edgesGlobalWidthScale(e) {
    return typeof e > "u" ? this._edgesGlobalWidthScale : (this._edgesGlobalWidthScale = e, this);
  }
  /** Set/get edge global width base. The width of each edge is calculated as: width = globalBase + globalScale * edgeWidth
   * @method edgesGlobalWidthBase
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} width - The global width base of the edges.
   * @return {Helios|this} - The Helios instance for chaining, or the current global width if no argument is provided.
   * @example
   * // Set the global width base of the edges to 0.5.
   * helios.edgesGlobalWidthBase(0.5);
   */
  edgesGlobalWidthBase(e) {
    return typeof e > "u" ? this._edgesGlobalWidthBase : (this._edgesGlobalWidthBase = e, this);
  }
  /** Set/get node global opacity scale. The opacity of each node is calculated as: opacity = globalBase + globalScale * nodeOpacity
   * @method nodesGlobalOpacityScale
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} opacity - The global opacity scale of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global opacity if no argument is provided.
   * @example
   * // Set the global opacity of the nodes to 0.5.
   * helios.nodesGlobalOpacityScale(0.5);
   * @example
   * // Get the global opacity of the nodes.
   * let scale = helios.nodesGlobalOpacityScale();
   */
  nodesGlobalOpacityScale(e) {
    return typeof e > "u" ? this._nodesGlobalOpacityScale : (this._nodesGlobalOpacityScale = e, this);
  }
  /** Set/get node global opacity base. The opacity of each node is calculated as: opacity = globalBase + globalScale * nodeOpacity
   * @method nodesGlobalOpacityBase
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} opacity - The global opacity base of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global opacity if no argument is provided.
   * @example
   * // Set the global opacity base of the nodes to 0.5.
   * helios.nodesGlobalOpacityBase(0.5);
   * @example
   * // Get the global opacity base of the nodes.
   * let base = helios.nodesGlobalOpacityBase();
   */
  nodesGlobalOpacityBase(e) {
    return typeof e > "u" ? this._nodesGlobalOpacityBase : (this._nodesGlobalOpacityBase = e, this);
  }
  /** Set/get node global size scale. The size of each node is calculated as: size = globalBase + globalScale * nodeSize
   * @method nodesGlobalSizeScale
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} size - The global size scale of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global size if no argument is provided.
   * @example
   * // Set the global size of the nodes to 0.5.
   * helios.nodesGlobalSizeScale(0.5);
   * @example
   * // Get the global size of the nodes.
   * let scale = helios.nodesGlobalSizeScale();
   */
  nodesGlobalSizeScale(e) {
    return typeof e > "u" ? this._nodesGlobalSizeScale : (this._nodesGlobalSizeScale = e, this);
  }
  /** Set/get node global size base. The size of each node is calculated as: size = globalBase + globalScale * nodeSize
   * @method nodesGlobalSizeBase
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} size - The global size base of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global size if no argument is provided.
   * @example
   * // Set the global size base of the nodes to 0.5.
   * helios.nodesGlobalSizeBase(0.5);
   * @example
   * // Get the global size base of the nodes.
   * let base = helios.nodesGlobalSizeBase();
   */
  nodesGlobalSizeBase(e) {
    return typeof e > "u" ? this._nodesGlobalSizeBase : (this._nodesGlobalSizeBase = e, this);
  }
  /** Set/get node global outline width scale. The outline width of each node is calculated as: width = globalBase + globalScale * nodeOutlineWidth
   * @method nodesGlobalOutlineWidthScale
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} width - The global outline width scale of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global outline width if no argument is provided.
   * @example
   * // Set the global outline width of the nodes to 0.5.
   * helios.nodesGlobalOutlineWidthScale(0.5);
   * @example
   * // Get the global outline width of the nodes.
   * let scale = helios.nodesGlobalOutlineWidthScale();
   */
  nodesGlobalOutlineWidthScale(e) {
    return typeof e > "u" ? this._nodesGlobalOutlineWidthScale : (this._nodesGlobalOutlineWidthScale = e, this);
  }
  /** Set/get node global outline width base. The outline width of each node is calculated as: width = globalBase + globalScale * nodeOutlineWidth
   * @method nodesGlobalOutlineWidthBase
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} width - The global outline width base of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global outline width if no argument is provided.
   * @example
   * // Set the global outline width base of the nodes to 0.5.
   * helios.nodesGlobalOutlineWidthBase(0.5);
   * @example
   * // Get the global outline width base of the nodes.
   * let base = helios.nodesGlobalOutlineWidthBase();
   */
  nodesGlobalOutlineWidthBase(e) {
    return typeof e > "u" ? this._nodesGlobalOutlineWidthBase : (this._nodesGlobalOutlineWidthBase = e, this);
  }
  /** Set/get node global outline opacity scale. The outline opacity of each node is calculated as: opacity = globalBase + globalScale * nodeOutlineOpacity
   * @method nodesGlobalOutlineOpacityScale
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} opacity - The global outline opacity scale of the nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current global outline opacity if no argument is provided.
   * @example
   * // Set the global outline opacity of the nodes to 0.5.
   * helios.nodesGlobalOutlineOpacityScale(0.5);
   * @example
   * // Get the global outline opacity of the nodes.
   * let scale = helios.nodesGlobalOutlineOpacityScale();
   */
  nodeOpacity(e) {
    if (typeof e > "u")
      return this.network.colors.map((n) => n[3]);
    if (typeof e == "function") {
      let n = this.network.index2Node;
      for (let r = 0; r < n.length; r++) {
        let i = n[r], a = e(i, r, this.network);
        this.network.colors[r * 4 + 3] = a;
      }
    } else
      for (let n = 0; n < allNodes.length; n++)
        this.network.colors[n * 4 + 3] = e;
    return this;
  }
  /** Enables or disables updating the edge colors to match the node colors.
   * @method edgesColorsFromNodes
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} edgesColorsFromNodes - Whether to update the edge colors to match the node colors.
   * @return {Helios|this} - The Helios instance for chaining, or the current value if no argument is provided.
   * @example
   * // Enable updating the edge colors to match the node colors.
   * helios.edgesColorsFromNodes(true);
   */
  edgesColorsFromNodes(e) {
    return typeof e > "u" ? this._edgesColorsFromNodes : (this._edgesColorsFromNodes = e, this);
  }
  /** Enables or disables updating the edge widths to match the node widths.
   * @method edgesWidthFromNodes
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} edgesWidthFromNodes - Whether to update the edge widths to match the node widths.
   * @return {Helios|this} - The Helios instance for chaining, or the current value if no argument is provided.
   * @example
   * // Enable updating the edge widths to match the node widths.
   * helios.edgesWidthFromNodes(true);
   */
  edgesWidthFromNodes(e) {
    return typeof e > "u" ? this._edgesWidthFromNodes : (this._edgesWidthFromNodes = e, this);
  }
  //#endregion
  /** Enables or disables additive blending (Useful for dark backgrounds).
   * @method additiveBlending
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} enableAdditiveBlending - Whether to enable additive blending.
   * @return {Helios|this} - The Helios instance for chaining, or the current value if no argument is provided.
   * @example
   * // Enable additive blending.
   * helios.additiveBlending(true);
   * @example
   * // Disable additive blending.
   * helios.additiveBlending(false);
   */
  additiveBlending(e) {
    return typeof e > "u" ? this.useAdditiveBlending : (this.useAdditiveBlending = e, this);
  }
  /** Enables or disables shaded nodes.
   * @method shadedNodes
   * @memberof Helios
   * @instance
   * @chainable
   * @param {boolean} enableShadedNodes - Whether to enable shaded nodes.
   * @return {Helios|this} - The Helios instance for chaining, or the current value if no argument is provided.
   * @example
   * // Enable shaded nodes.
   * helios.shadedNodes(true);
   */
  shadedNodes(e) {
    return typeof e > "u" ? this.useShadedNodes : (this.useShadedNodes = e, this);
  }
  /** Enables or disables edges that can be pickeable
   * @method pickeableEdges
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number[]|"all"} pickables - The indices of the edges that can be pickeable, or "all" to make all edges pickeable.
   * @return {Helios|this} - The Helios instance for chaining, or the current value if no argument is provided.
   * @example
   * // Enable pickeable edges for [0,1,2,3]
   * helios.pickeableEdges([0, 1, 2, 3]);
   * @example
   * // Enable pickeable edges for all edges
   * helios.pickeableEdges("all");
   */
  pickeableEdges(e) {
    if (typeof e > "u")
      return this._pickeableEdges;
    if (this._pickeableEdges = new Set(e), e == "all") {
      for (let n = 0; n < this.network.edges.length; n++)
        this._pickeableEdges.add(n);
      this._edgeIndicesUpdate = true, this.update();
    } else
      this._edgeIndicesUpdate = true, this.update();
    return this;
  }
  /** Get or set labels buffer size
   * @method labelsMaxPixels
   * @memberof Helios
   * @instance
   * @chainable
   * @param {number} labelsMaxPixels - The maximum number of pixels for the labels buffer.
   * @return {Helios|this} - The Helios instance for chaining, or the current value if no argument is provided.
   * @example
   * // Set the maximum number of pixels for the labels buffer to 10000.
   * helios.labelsMaxPixels(10000);
   */
  labelsMaxPixels(e) {
    return typeof e > "u" ? this._trackingMaxPixels : (this._trackingMaxPixels = e, _willResizeEvent(0), this);
  }
  /** Manually cleanup the Helios instance.
   * @method cleanup
   * @memberof Helios
   * @instance
   * @param {boolean} keepGLContext - Whether to keep the WebGL context alive.
   * @example
   * // Cleanup the Helios instance.
   * helios.cleanup();
   * @example
   * // Cleanup the Helios instance and keep the WebGL context alive.
   * helios.cleanup(true);
   */
  cleanup(e) {
    var _a2, _b;
    this.isReady = false, this.layoutWorker.cleanup(), this.scheduler.stop(), this.layoutWorker = null;
    const n = this.gl;
    if (this.onReadyCallback = null, this.onNodeClickCallback = null, this.onNodeDoubleClickCallback = null, this.onNodeHoverStartCallback = null, this.onNodeHoverMoveCallback = null, this.onNodeHoverEndCallback = null, this.onEdgeClickCallback = null, this.onEdgeDoubleClickCallback = null, this.onEdgeHoverStartCallback = null, this.onEdgeHoverMoveCallback = null, this.onEdgeHoverEndCallback = null, this.onZoomCallback = null, this.onRotationCallback = null, this.onResizeCallback = null, this.onLayoutStartCallback = null, this.onLayoutStopCallback = null, this.onDrawCallback = null, this.onReadyCallback = null, this.isReady = false, this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), this.canvasElement && (this.canvasElement.removeEventListener("click", this._clickEventListener), this.canvasElement.removeEventListener("dblclick", this._doubleClickEventListener), this.canvasElement.removeEventListener("mousemove", this._hoverMoveEventListener), this.canvasElement.removeEventListener("mouseleave", this._hoverLeaveEventListener), document.body.removeEventListener("mouseout", this._hoverLeaveWindowEventListener)), !e && n) {
      let r = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);
      (_a2 = this.pickingFramebuffer) == null ? void 0 : _a2.discard(), (_b = this._trackingFramebuffer) == null ? void 0 : _b.discard();
      for (let i = 0; i < r; ++i)
        n.activeTexture(n.TEXTURE0 + i), n.bindTexture(n.TEXTURE_2D, null), n.bindTexture(n.TEXTURE_CUBE_MAP, null);
      n.bindBuffer(n.ARRAY_BUFFER, null), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), n.bindRenderbuffer(n.RENDERBUFFER, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteBuffer(this.nodesPositionBuffer), n.deleteBuffer(this.nodesColorBuffer), n.deleteBuffer(this.nodesSizeBuffer), n.deleteBuffer(this.nodesSizeBuffer), n.deleteBuffer(this.nodesOutlineWidthBuffer), n.deleteBuffer(this.nodesOutlineColorBuffer), n.deleteBuffer(this.nodesIndexBuffer), this.edgesGeometry && (n.deleteBuffer(this.edgesGeometry.edgeVertexTypeBuffer), n.deleteBuffer(this.edgesGeometry.verticesBuffer), n.deleteBuffer(this.edgesGeometry.colorBuffer), n.deleteBuffer(this.edgesGeometry.sizeBuffer)), this.fastEdgesGeometry && (n.deleteBuffer(this.fastEdgesGeometry.indexBuffer), n.deleteBuffer(this.fastEdgesGeometry.vertexObject), n.deleteBuffer(this.fastEdgesGeometry.colorObject), n.deleteBuffer(this.fastEdgesGeometry.indexObject));
    }
    this.densityMap && this.densityMap.cleanup(), this._autoCleanup && (this._mutationObserver.disconnect(), this._mutationObserver = null), this.canvasElement && (this.canvasElement.remove(), this.canvasElement = null), this._hasCleanup = true;
  }
  /** Destroys the Helios instance.
   * @method destroy
   * @memberof Helios
   * @instance
   */
  destroy() {
    this._hasCleanup || this.cleanup();
  }
};
export {
  Ml as Helios,
  Fl as xnet
};
/*! Bundled license information:

helios-web/dist/helios.js:
  (*!
  
  pica
  https://github.com/nodeca/pica
  
  *)
*/
//# sourceMappingURL=helios-web.js.map
